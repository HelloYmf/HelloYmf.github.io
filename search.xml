<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>assembly basic</title>
      <link href="/2022/09/12/assembly-basic/"/>
      <url>/2022/09/12/assembly-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="1-EFLAGS"><a href="#1-EFLAGS" class="headerlink" title="1.EFLAGS"></a>1.EFLAGS</h2><p><img src="/./assembly-basic/eflags.png" alt="eflags"></p><h2 id="2-测试与比较"><a href="#2-测试与比较" class="headerlink" title="2.测试与比较"></a>2.测试与比较</h2><h3 id="2-1-test"><a href="#2-1-test" class="headerlink" title="2.1 test"></a>2.1 test</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">test rax, rbx; 等价形式如下push raxand rax, rbxpop rax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-cmp"><a href="#2-2-cmp" class="headerlink" title="2.2 cmp"></a>2.2 cmp</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">cmp rax, rbx; 等价形式如下push raxsub rax, rbxpop rax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-跳转"><a href="#3-跳转" class="headerlink" title="3.跳转"></a>3.跳转</h2><h3 id="3-1-JCC条件跳转"><a href="#3-1-JCC条件跳转" class="headerlink" title="3.1 JCC条件跳转"></a>3.1 JCC条件跳转</h3><ul><li><strong>短跳：</strong>2字节，1字节硬编码 + 1字节有符号偏移</li><li><strong>长跳：</strong>6字节，2字节硬编码 + 4字节有符号地址</li></ul><table><thead><tr><th>指令</th><th>短跳</th><th>长跳</th><th>含义</th><th>EFLAGS</th></tr></thead><tbody><tr><td>JZ&#x2F;JE</td><td>0x74</td><td>0x0F 0X84</td><td>相等则跳转</td><td>ZF &#x3D;&#x3D; 1</td></tr><tr><td>JNZ&#x2F;JNE</td><td>0x75</td><td>0x0F 0X85</td><td>不相等则跳转</td><td>ZF &#x3D;&#x3D; 0</td></tr><tr><td>JS</td><td>0x78</td><td>0x0F 0X88</td><td>负数则跳转</td><td>SF &#x3D;&#x3D; 1</td></tr><tr><td>JNS</td><td>0x79</td><td>0x0F 0X89</td><td>正数则跳转</td><td>SF &#x3D;&#x3D; 0</td></tr><tr><td>JP&#x2F;JPE</td><td>0x7A</td><td>0x0F 0X8A</td><td>1出现次数为偶数则跳转</td><td>PF &#x3D;&#x3D; 1</td></tr><tr><td>JNP&#x2F;JPO</td><td>0x7B</td><td>0x0F 0X8B</td><td>1出现次数为奇数则跳转</td><td>PF &#x3D;&#x3D; 0</td></tr><tr><td>JC&#x2F;JB&#x2F;JNAE</td><td>0x72</td><td>0x0F 0X82</td><td>无符号数 (进位)低于则跳转</td><td>CF &#x3D;&#x3D; 1</td></tr><tr><td>JNC&#x2F;JNB&#x2F;JAE</td><td>0x73</td><td>0x0F 0X83</td><td>无符号数 (不进位)高于等于则跳转</td><td>CF &#x3D;&#x3D; 0</td></tr><tr><td>JO</td><td>0x70</td><td>0x0F 0X80</td><td>有符号数 溢出则跳转</td><td>OF &#x3D;&#x3D; 1</td></tr><tr><td>JNO</td><td>0x71</td><td>0x0F 0X81</td><td>有符号数 无溢出则跳转</td><td>OF &#x3D;&#x3D; 0</td></tr><tr><td>JBE&#x2F;JNA</td><td>0x76</td><td>0x0F 0X86</td><td>无符号数 低于等于则跳转</td><td>ZF &#x3D;&#x3D; 1 || CF &#x3D;&#x3D; 1</td></tr><tr><td>JNBE&#x2F;JA</td><td>0x77</td><td>0x0F 0X87</td><td>无符号数 高于则跳转</td><td>ZF &#x3D;&#x3D; 0 || CF &#x3D;&#x3D; 0</td></tr><tr><td>JL&#x2F;JNGE</td><td>0x7C</td><td>0x0F 0X8C</td><td>有符号数 小于则跳转</td><td>SF !&#x3D; OF</td></tr><tr><td>JNL&#x2F;JGE</td><td>0x7D</td><td>0x0F 0X8D</td><td>有符号数 大于等于则跳转</td><td>SF &#x3D;&#x3D; OF</td></tr><tr><td>JLE&#x2F;JNG</td><td>0x7E</td><td>0x0F 0X8E</td><td>有符号数 小于等于则跳转</td><td>ZF !&#x3D; OF || ZF &#x3D;&#x3D; 1</td></tr><tr><td>JNLE&#x2F;JG</td><td>0x7F</td><td>0x0F 0X8F</td><td>有符号数 大于则跳转</td><td>SF &#x3D;&#x3D; 0F &amp;&amp; ZF &#x3D;&#x3D; 0</td></tr></tbody></table><h3 id="3-2-CALL无条件跳转"><a href="#3-2-CALL无条件跳转" class="headerlink" title="3.2 CALL无条件跳转"></a>3.2 CALL无条件跳转</h3><hr><p><strong>E8 + 4字节有符号偏移：</strong>偏移CALL，最常见用法。</p><p>​<strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 4字节偏移</strong></p><hr><p><strong>FF 15 + 4字节：</strong>间接CALL，长用于调用导入表中函数。</p><ul><li><p>x86：后面跟4字节内存地址。</p><p><strong>跳转目标地址 &#x3D; ptr:[ 4字节内存地址 ]</strong></p></li><li><p>x64：后面跟4字节偏移，再使用偏移计算公式得到4字节内存地址。</p></li></ul><p>​<strong>跳转目标地址 &#x3D; ptr:[ 当前指令地址 + 当前指令长度 + 4字节偏移 ]</strong></p><hr><p><strong>9A + 4字节地址 + 目标cs：</strong>绝对CALL，仅x86有效，可以跳转到绝对地址同时改变cs的值，far常用于实现调用门。</p><p>​<strong>跳转目标地址 &#x3D; 4字节地址、cs &#x3D; 目标cs</strong></p><hr><h3 id="3-3-JMP无条件跳转"><a href="#3-3-JMP无条件跳转" class="headerlink" title="3.3 JMP无条件跳转"></a>3.3 JMP无条件跳转</h3><p><strong>EB + 1字节有符号偏移：</strong>偏移短跳转</p><p>​<strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 1字节偏移</strong></p><hr><p><strong>E9 + 4字节有符号偏移：</strong>偏移近跳转</p><p>​<strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 4字节偏移</strong></p><hr><p><strong>FF 25 + 4字节：</strong>间接跳转</p><ul><li><p>x86：后面跟4字节内存地址。</p><p><strong>跳转目标地址 &#x3D; ptr:[ 4字节内存地址 ]</strong></p></li><li><p>x64：后面跟4字节偏移，再使用偏移计算公式得到4字节内存地址。</p></li></ul><p>​<strong>跳转目标地址 &#x3D; ptr:[ 当前指令地址 + 当前指令长度 + 4字节偏移 ]</strong></p><hr><p><strong>EA + 4字节地址 + 目标cs：</strong>绝对跳转，仅x86有效，可以跳转到绝对地址同时改变cs的值，far常用于实现调用门。</p><p>​<strong>跳转目标地址 &#x3D; 4字节地址、cs &#x3D; 目标cs</strong></p><hr><h3 id="3-4-x64下的Inline-HOOK"><a href="#3-4-x64下的Inline-HOOK" class="headerlink" title="3.4 x64下的Inline HOOK"></a>3.4 x64下的Inline HOOK</h3><p>进入</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">方法1：12字节mov rax, 0x123456789jmp rax方法2：12字节mov rax, 0x123456789push raxret方法3：不破坏寄存器  13字节push raxmov rax, 0x123456789jmp rax&#96;&#96;&#96;pop rax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">方法1：20字节sub rsp, 0x8mov dword ptr ss:[rsp], 0x1234mov dword ptr ss:[rsp+0x4], 0x56789ABCret方法2：14字节push 0x12345678mov dword ptr ss:[rsp+4], 0x9ABCret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-基本运算"><a href="#4-基本运算" class="headerlink" title="4.基本运算"></a>4.基本运算</h2><h3 id="4-1-除法"><a href="#4-1-除法" class="headerlink" title="4.1 除法"></a>4.1 除法</h3><p>无符号：div + 除数</p><p>有符号：idiv + 除数，余数的符号与被除数相同。</p><table><thead><tr><th>被除数</th><th>除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td>ax</td><td>reg&#x2F;mem8</td><td>al</td><td>ah</td></tr><tr><td>dx:ax</td><td>reg&#x2F;mem16</td><td>ax</td><td>dx</td></tr><tr><td>edx:eax</td><td>reg&#x2F;mem32</td><td>eax</td><td>edx</td></tr><tr><td>rdx:rax</td><td>reg&#x2F;mem64</td><td>rax</td><td>rdx</td></tr></tbody></table><h3 id="4-2-乘法"><a href="#4-2-乘法" class="headerlink" title="4.2 乘法"></a>4.2 乘法</h3><p><strong>单操作数：</strong></p><p>​无符号：mul + 乘数</p><p>​有符号：imul + 乘数</p><table><thead><tr><th>被乘数</th><th>乘数</th><th>乘积</th></tr></thead><tbody><tr><td>al</td><td>reg&#x2F;mem8</td><td>ax</td></tr><tr><td>ax</td><td>reg&#x2F;mem16</td><td>dx:ax</td></tr><tr><td>eax</td><td>reg&#x2F;mem32</td><td>edx:eax</td></tr><tr><td>rax</td><td>reg&#x2F;mem64</td><td>rdx:rax</td></tr></tbody></table><p>对于无符号数，计算后如果dx&#x2F;edx&#x2F;rdx寄存器不为0，则CF位被置位。</p><p>对于有符号数，计算后如果dx&#x2F;edx&#x2F;rdx寄存器不为ax&#x2F;eax&#x2F;rax的符号扩展，则OF和CF位被置位。</p><p><strong>双操作数：</strong>不支持8位，必须是有符号数。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">imul reg1, reg2&#x2F;mem&#x2F;imm; 等价形式如下reg1 &#x3D; reg1 * reg2&#x2F;mem&#x2F;imm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>三操作数：</strong>不支持8位，必须是有符号数。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">imul reg1, reg2&#x2F;mem, imm; 等价形式如下reg1 &#x3D; reg2&#x2F;mem * imm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-3-移位"><a href="#4-3-移位" class="headerlink" title="4.3 移位"></a>4.3 移位</h3><p><strong>逻辑：</strong>shl、shr</p><p><strong>算数：</strong>sal、sar</p><p>逻辑左移与逻辑左移没区别，算数右移左边补符号位，逻辑右移坐标补0。右移除以2，左移乘以2。</p><h2 id="5-数据传送"><a href="#5-数据传送" class="headerlink" title="5.数据传送"></a>5.数据传送</h2><h3 id="5-1-扩展传送"><a href="#5-1-扩展传送" class="headerlink" title="5.1 扩展传送"></a>5.1 扩展传送</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movsx：符号位扩展movzx：0扩展<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-2-隐式传送"><a href="#5-2-隐式传送" class="headerlink" title="5.2 隐式传送"></a>5.2 隐式传送</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movs_b&#x2F;w&#x2F;d&#x2F;q; 等价形式如下if(DF &#x3D;&#x3D; 0); cld&#123;[edi++] &#x3D; [esi++]&#125;else; std&#123;[edi--] &#x3D; [esi--]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-字符串获取"><a href="#5-3-字符串获取" class="headerlink" title="5.3 字符串获取"></a>5.3 字符串获取</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lods_b&#x2F;w&#x2F;d&#x2F;q; 等价形式如下if(DF &#x3D;&#x3D; 0); cld&#123;eax &#x3D; [esi++]&#125;else; std&#123;eax &#x3D; [esi--]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-4-字符串加载"><a href="#5-4-字符串加载" class="headerlink" title="5.4 字符串加载"></a>5.4 字符串加载</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">stos_b&#x2F;w&#x2F;d&#x2F;q; 等价形式如下if(DF &#x3D;&#x3D; 0); cld&#123;[edi++] &#x3D; eax &#125;else; std&#123;[edi--] &#x3D; eax &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> x86/x64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>assembly basic</title>
      <link href="/2022/09/12/asmbasic/"/>
      <url>/2022/09/12/asmbasic/</url>
      
        <content type="html"><![CDATA[<h2 id="1-EFLAGS"><a href="#1-EFLAGS" class="headerlink" title="1.EFLAGS"></a>1.EFLAGS</h2><p><img src="/2022/09/12/asmbasic/eflags.png" alt="eflags"></p><h2 id="2-测试与比较"><a href="#2-测试与比较" class="headerlink" title="2.测试与比较"></a>2.测试与比较</h2><h3 id="2-1-test"><a href="#2-1-test" class="headerlink" title="2.1 test"></a>2.1 test</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">test rax, rbx; 等价形式如下push raxand rax, rbxpop rax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-cmp"><a href="#2-2-cmp" class="headerlink" title="2.2 cmp"></a>2.2 cmp</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">cmp rax, rbx; 等价形式如下push raxsub rax, rbxpop rax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-跳转"><a href="#3-跳转" class="headerlink" title="3.跳转"></a>3.跳转</h2><h3 id="3-1-JCC条件跳转"><a href="#3-1-JCC条件跳转" class="headerlink" title="3.1 JCC条件跳转"></a>3.1 JCC条件跳转</h3><ul><li><strong>短跳：</strong>2字节，1字节硬编码 + 1字节有符号偏移</li><li><strong>长跳：</strong>6字节，2字节硬编码 + 4字节有符号地址</li></ul><table><thead><tr><th>指令</th><th>短跳</th><th>长跳</th><th>含义</th><th>EFLAGS</th></tr></thead><tbody><tr><td>JZ&#x2F;JE</td><td>0x74</td><td>0x0F 0X84</td><td>相等则跳转</td><td>ZF &#x3D;&#x3D; 1</td></tr><tr><td>JNZ&#x2F;JNE</td><td>0x75</td><td>0x0F 0X85</td><td>不相等则跳转</td><td>ZF &#x3D;&#x3D; 0</td></tr><tr><td>JS</td><td>0x78</td><td>0x0F 0X88</td><td>负数则跳转</td><td>SF &#x3D;&#x3D; 1</td></tr><tr><td>JNS</td><td>0x79</td><td>0x0F 0X89</td><td>正数则跳转</td><td>SF &#x3D;&#x3D; 0</td></tr><tr><td>JP&#x2F;JPE</td><td>0x7A</td><td>0x0F 0X8A</td><td>1出现次数为偶数则跳转</td><td>PF &#x3D;&#x3D; 1</td></tr><tr><td>JNP&#x2F;JPO</td><td>0x7B</td><td>0x0F 0X8B</td><td>1出现次数为奇数则跳转</td><td>PF &#x3D;&#x3D; 0</td></tr><tr><td>JC&#x2F;JB&#x2F;JNAE</td><td>0x72</td><td>0x0F 0X82</td><td>无符号数 (进位)低于则跳转</td><td>CF &#x3D;&#x3D; 1</td></tr><tr><td>JNC&#x2F;JNB&#x2F;JAE</td><td>0x73</td><td>0x0F 0X83</td><td>无符号数 (不进位)高于等于则跳转</td><td>CF &#x3D;&#x3D; 0</td></tr><tr><td>JO</td><td>0x70</td><td>0x0F 0X80</td><td>有符号数 溢出则跳转</td><td>OF &#x3D;&#x3D; 1</td></tr><tr><td>JNO</td><td>0x71</td><td>0x0F 0X81</td><td>有符号数 无溢出则跳转</td><td>OF &#x3D;&#x3D; 0</td></tr><tr><td>JBE&#x2F;JNA</td><td>0x76</td><td>0x0F 0X86</td><td>无符号数 低于等于则跳转</td><td>ZF &#x3D;&#x3D; 1 || CF &#x3D;&#x3D; 1</td></tr><tr><td>JNBE&#x2F;JA</td><td>0x77</td><td>0x0F 0X87</td><td>无符号数 高于则跳转</td><td>ZF &#x3D;&#x3D; 0 || CF &#x3D;&#x3D; 0</td></tr><tr><td>JL&#x2F;JNGE</td><td>0x7C</td><td>0x0F 0X8C</td><td>有符号数 小于则跳转</td><td>SF !&#x3D; OF</td></tr><tr><td>JNL&#x2F;JGE</td><td>0x7D</td><td>0x0F 0X8D</td><td>有符号数 大于等于则跳转</td><td>SF &#x3D;&#x3D; OF</td></tr><tr><td>JLE&#x2F;JNG</td><td>0x7E</td><td>0x0F 0X8E</td><td>有符号数 小于等于则跳转</td><td>ZF !&#x3D; OF || ZF &#x3D;&#x3D; 1</td></tr><tr><td>JNLE&#x2F;JG</td><td>0x7F</td><td>0x0F 0X8F</td><td>有符号数 大于则跳转</td><td>SF &#x3D;&#x3D; 0F &amp;&amp; ZF &#x3D;&#x3D; 0</td></tr></tbody></table><h3 id="3-2-CALL无条件跳转"><a href="#3-2-CALL无条件跳转" class="headerlink" title="3.2 CALL无条件跳转"></a>3.2 CALL无条件跳转</h3><hr><p><strong>E8 + 4字节有符号偏移：</strong>偏移CALL，最常见用法。</p><p>​<strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 4字节偏移</strong></p><hr><p><strong>FF 15 + 4字节：</strong>间接CALL，长用于调用导入表中函数。</p><ul><li><p>x86：后面跟4字节内存地址。</p><p><strong>跳转目标地址 &#x3D; ptr:[ 4字节内存地址 ]</strong></p></li><li><p>x64：后面跟4字节偏移，再使用偏移计算公式得到4字节内存地址。</p></li></ul><p>​<strong>跳转目标地址 &#x3D; ptr:[ 当前指令地址 + 当前指令长度 + 4字节偏移 ]</strong></p><hr><p><strong>9A + 4字节地址 + 目标cs：</strong>绝对CALL，仅x86有效，可以跳转到绝对地址同时改变cs的值，far常用于实现调用门。</p><p>​<strong>跳转目标地址 &#x3D; 4字节地址、cs &#x3D; 目标cs</strong></p><hr><h3 id="3-3-JMP无条件跳转"><a href="#3-3-JMP无条件跳转" class="headerlink" title="3.3 JMP无条件跳转"></a>3.3 JMP无条件跳转</h3><p><strong>EB + 1字节有符号偏移：</strong>偏移短跳转</p><p>​<strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 1字节偏移</strong></p><hr><p><strong>E9 + 4字节有符号偏移：</strong>偏移近跳转</p><p>​<strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 4字节偏移</strong></p><hr><p><strong>FF 25 + 4字节：</strong>间接跳转</p><ul><li><p>x86：后面跟4字节内存地址。</p><p><strong>跳转目标地址 &#x3D; ptr:[ 4字节内存地址 ]</strong></p></li><li><p>x64：后面跟4字节偏移，再使用偏移计算公式得到4字节内存地址。</p></li></ul><p>​<strong>跳转目标地址 &#x3D; ptr:[ 当前指令地址 + 当前指令长度 + 4字节偏移 ]</strong></p><hr><p><strong>EA + 4字节地址 + 目标cs：</strong>绝对跳转，仅x86有效，可以跳转到绝对地址同时改变cs的值，far常用于实现调用门。</p><p>​<strong>跳转目标地址 &#x3D; 4字节地址、cs &#x3D; 目标cs</strong></p><hr><h3 id="3-4-x64下的Inline-HOOK"><a href="#3-4-x64下的Inline-HOOK" class="headerlink" title="3.4 x64下的Inline HOOK"></a>3.4 x64下的Inline HOOK</h3><p>进入</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">方法1：12字节mov rax, 0x123456789jmp rax方法2：12字节mov rax, 0x123456789push raxret方法3：不破坏寄存器  13字节push raxmov rax, 0x123456789jmp rax&#96;&#96;&#96;pop rax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">方法1：20字节sub rsp, 0x8mov dword ptr ss:[rsp], 0x1234mov dword ptr ss:[rsp+0x4], 0x56789ABCret方法2：14字节push 0x12345678mov dword ptr ss:[rsp+4], 0x9ABCret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-基本运算"><a href="#4-基本运算" class="headerlink" title="4.基本运算"></a>4.基本运算</h2><h3 id="4-1-除法"><a href="#4-1-除法" class="headerlink" title="4.1 除法"></a>4.1 除法</h3><p>无符号：div + 除数</p><p>有符号：idiv + 除数，余数的符号与被除数相同。</p><table><thead><tr><th>被除数</th><th>除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td>ax</td><td>reg&#x2F;mem8</td><td>al</td><td>ah</td></tr><tr><td>dx:ax</td><td>reg&#x2F;mem16</td><td>ax</td><td>dx</td></tr><tr><td>edx:eax</td><td>reg&#x2F;mem32</td><td>eax</td><td>edx</td></tr><tr><td>rdx:rax</td><td>reg&#x2F;mem64</td><td>rax</td><td>rdx</td></tr></tbody></table><h3 id="4-2-乘法"><a href="#4-2-乘法" class="headerlink" title="4.2 乘法"></a>4.2 乘法</h3><p><strong>单操作数：</strong></p><p>​无符号：mul + 乘数</p><p>​有符号：imul + 乘数</p><table><thead><tr><th>被乘数</th><th>乘数</th><th>乘积</th></tr></thead><tbody><tr><td>al</td><td>reg&#x2F;mem8</td><td>ax</td></tr><tr><td>ax</td><td>reg&#x2F;mem16</td><td>dx:ax</td></tr><tr><td>eax</td><td>reg&#x2F;mem32</td><td>edx:eax</td></tr><tr><td>rax</td><td>reg&#x2F;mem64</td><td>rdx:rax</td></tr></tbody></table><p>对于无符号数，计算后如果dx&#x2F;edx&#x2F;rdx寄存器不为0，则CF位被置位。</p><p>对于有符号数，计算后如果dx&#x2F;edx&#x2F;rdx寄存器不为ax&#x2F;eax&#x2F;rax的符号扩展，则OF和CF位被置位。</p><p><strong>双操作数：</strong>不支持8位，必须是有符号数。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">imul reg1, reg2&#x2F;mem&#x2F;imm; 等价形式如下reg1 &#x3D; reg1 * reg2&#x2F;mem&#x2F;imm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>三操作数：</strong>不支持8位，必须是有符号数。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">imul reg1, reg2&#x2F;mem, imm; 等价形式如下reg1 &#x3D; reg2&#x2F;mem * imm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-3-移位"><a href="#4-3-移位" class="headerlink" title="4.3 移位"></a>4.3 移位</h3><p><strong>逻辑：</strong>shl、shr</p><p><strong>算数：</strong>sal、sar</p><p>逻辑左移与逻辑左移没区别，算数右移左边补符号位，逻辑右移坐标补0。右移除以2，左移乘以2。</p><h2 id="5-数据传送"><a href="#5-数据传送" class="headerlink" title="5.数据传送"></a>5.数据传送</h2><h3 id="5-1-扩展传送"><a href="#5-1-扩展传送" class="headerlink" title="5.1 扩展传送"></a>5.1 扩展传送</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movsx：符号位扩展movzx：0扩展<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-2-隐式传送"><a href="#5-2-隐式传送" class="headerlink" title="5.2 隐式传送"></a>5.2 隐式传送</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movs_b&#x2F;w&#x2F;d&#x2F;q; 等价形式如下if(DF &#x3D;&#x3D; 0); cld&#123;[edi++] &#x3D; [esi++]&#125;else; std&#123;[edi--] &#x3D; [esi--]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-字符串获取"><a href="#5-3-字符串获取" class="headerlink" title="5.3 字符串获取"></a>5.3 字符串获取</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lods_b&#x2F;w&#x2F;d&#x2F;q; 等价形式如下if(DF &#x3D;&#x3D; 0); cld&#123;eax &#x3D; [esi++]&#125;else; std&#123;eax &#x3D; [esi--]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-4-字符串加载"><a href="#5-4-字符串加载" class="headerlink" title="5.4 字符串加载"></a>5.4 字符串加载</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">stos_b&#x2F;w&#x2F;d&#x2F;q; 等价形式如下if(DF &#x3D;&#x3D; 0); cld&#123;[edi++] &#x3D; eax &#125;else; std&#123;[edi--] &#x3D; eax &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> x86/x64 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
