<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++常见问题汇总</title>
    <link href="/2022/10/01/c-chang-jian-wen-ti-hui-zong/"/>
    <url>/2022/10/01/c-chang-jian-wen-ti-hui-zong/</url>
    
    <content type="html"><![CDATA[<h2 id="1-关键字"><a href="#1-关键字" class="headerlink" title="1.关键字"></a>1.关键字</h2><h3 id="1-1-const"><a href="#1-1-const" class="headerlink" title="1.1 const"></a>1.1 const</h3><p><strong>底层const指针：</strong>可以修改指向，不可以改值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> dwVal1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> dwVal2 = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p1 = &amp;dwVal1;<br><br>p1 = &amp;dwVal2;<span class="hljs-comment">// 正确</span><br>*p1 = <span class="hljs-number">5</span>;<span class="hljs-comment">// 不正确</span><br></code></pre></td></tr></table></figure><p><strong>底层const指针：</strong>可以改值，不可以改指向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> dwVal1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> dwVal2 = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p1 = &amp;dwVal1;<br><br>p1 = &amp;dwVal2;<span class="hljs-comment">// 不正确</span><br>*p1 = <span class="hljs-number">5</span>;<span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><p><strong>成员函数指针：</strong>表示这个函数不会修改成员变量的内容，mutable关键字修饰的成员变量除外，同时该函数不能被static关键字修饰。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">m_fun1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>m_dwVal1 = <span class="hljs-number">5</span>;<span class="hljs-comment">// 错误</span><br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_dwVal1;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-2-static"><a href="#1-2-static" class="headerlink" title="1.2 static"></a>1.2 static</h3><p>static本质与全局符号的概念一致，只是在语法层面存在细微差别。</p><ul><li>修饰全局变量：语法层面限制该变量只在当前文件内有效。</li><li>修饰全局函数：语法层面限制该函数只在当前文件内有效。</li><li>修饰局部变量：语法层面用来扩展栈变量的生命周期。</li><li>修饰成员变量：语法层面表示多个对象中共享数据，可以通过类名访问，需要在类外初始化，可以被普通成员函数访问。</li><li>修饰成员函数：语法层面可以被类名直接调用，不传递this指针，不能访问普通成员变量。</li></ul><h3 id="1-3-virtual"><a href="#1-3-virtual" class="headerlink" title="1.3 virtual"></a>1.3 virtual</h3><p>用于声明一个类成员函数为虚函数。存在虚函数的类对象，首个成员固定为一个指针，指向该类的虚函数表。</p><p>当父类指针指向子类对象，子类重写父类虚函数，此时虚函数会以指针寻址的方式动态调用，构成多态性。</p><p>构造函数中完成虚表指针的初始化，所以构造函数不能被定义为虚函数。</p><p><strong>析构函数声明为虚函数的原因：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Base* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br><span class="hljs-keyword">delete</span> p;<br></code></pre></td></tr></table></figure><p>如果析构函数不为虚函数，上面的代码会只调用父类的析构函数，子类的对象没有被正确释放。</p><p>当析构函数声明为虚函数时，会在子类虚函数表中找到子类的析构函数进行调用，先析构子类再析构父类，整个派生类被完全释放。</p><p><img src="/2022/10/01/c-chang-jian-wen-ti-hui-zong/image-20221001164349840.png" alt="image-20221001164349840"></p><h3 id="1-4-volatile"><a href="#1-4-volatile" class="headerlink" title="1.4 volatile"></a>1.4 volatile</h3><p>告诉编译器，这个变量的值需要每次都从内存中去读取，不允许暂存到寄存器中，可以用在多线程对某个全局标志的访问时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-type">int</span> g_Flag = <span class="hljs-number">0</span>;<br><br><span class="hljs-function">DWORD <span class="hljs-title">ThreadProc1</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">LPVOID lpThreadParameter</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br>g_Flag = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (g_Flag) &#123;&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">DWORD <span class="hljs-title">ThreadProc2</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">LPVOID lpThreadParameter</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>::<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">5000</span>);<br>g_Flag = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>HANDLE hThread1 = ::<span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)ThreadProc1, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>HANDLE hThread2 = ::<span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)ThreadProc2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码在Release版编译下，会死循环，汇编如下：</p><p><img src="/2022/10/01/c-chang-jian-wen-ti-hui-zong/image-20221001171456415.png" alt="image-20221001171456415"></p><p>在将g_Flag使用volatile修饰后，不会产生死循环，汇编代码如下：</p><p><img src="/2022/10/01/c-chang-jian-wen-ti-hui-zong/image-20221001171816455.png" alt="image-20221001171816455"></p><h3 id="1-5-explict"><a href="#1-5-explict" class="headerlink" title="1.5 explict"></a>1.5 explict</h3><p>用于修饰类构造函数，不允许对象发生隐式类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A::constor\n&quot;</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a = <span class="hljs-number">2</span>;<span class="hljs-comment">// 错误</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-字节对齐"><a href="#2-字节对齐" class="headerlink" title="2.字节对齐"></a>2.字节对齐</h2><h3 id="2-1-规则"><a href="#2-1-规则" class="headerlink" title="2.1 规则"></a>2.1 规则</h3><ul><li>结构体成员：第一个成员放在offset为0的位置，之后的每个数据成员按照#pragma pack指定的数值和sizeof()中的较小值进行对齐。</li><li>结构体总体：总大小按照#pragma pack指定的数值和sizeof()中的较小值进行对齐。</li></ul><h3 id="2-2-原因"><a href="#2-2-原因" class="headerlink" title="2.2 原因"></a>2.2 原因</h3><ul><li><p>平台原因：某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p></li><li><p>性能原因：访问未对齐的内存，处理器需要作两次访问；而访问对齐的内存仅需要一次访问。</p><p>如int类型的四字节存储在0x1地址上，cpu需要首先从0x0位置读4字节，舍去0x0这1个字节，再从0x4位置读4字节，舍去0x5开始的3个字节，最终拼接得到最终结果。</p></li></ul><h2 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3.类型转换"></a>3.类型转换</h2><ul><li><p>const_cast</p><p>用于对指针或引用去const属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* pCa = &amp;a;<br><span class="hljs-comment">// *p = 10;// 错误</span><br><span class="hljs-comment">// b= 20;// 错误</span><br><span class="hljs-type">int</span>* pa = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(pCa);<span class="hljs-comment">// 指针去const</span><br><span class="hljs-type">int</span>&amp; rb = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(b);<span class="hljs-comment">// 引用去const</span><br><br>*pa = <span class="hljs-number">10</span>;<span class="hljs-comment">// 正确</span><br>rb = <span class="hljs-number">20</span>;<span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure></li><li><p>static_cast</p><p>与C风格强制类型转换基本一样，不存在运行时类型检查。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">float fVal1 <span class="hljs-operator">=</span> <span class="hljs-number">3.1415926</span>f<span class="hljs-comment">;</span><br>int dwVal2 <span class="hljs-operator">=</span> static_cast&lt;int&gt;(fVal1)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>dynamic_cast</p><p>具有运行时类型检查，可以防止在具有虚函数的派生关系中，将父类对象地址交给子类指针，会返回NULL。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Base *base = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base</span>();<br>Sub  *pSub = <span class="hljs-built_in">dynamic_cast</span>&lt;Sub*&gt;(base);<span class="hljs-comment">// 转换失败，此时pSub为NULL</span><br><span class="hljs-keyword">if</span>(pSub != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-comment">// do something.</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>reinterpret_cast</p><p>对要转换的二进制流重新解释，常用于指针与整数之间的转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-title">Hash</span><span class="hljs-params">(<span class="hljs-type">void</span> *p)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(p);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)(val ^ (val &gt;&gt; <span class="hljs-number">16</span>));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>To do list</title>
    <link href="/2022/09/30/to-do-list/"/>
    <url>/2022/09/30/to-do-list/</url>
    
    <content type="html"><![CDATA[<h2 id="1-国庆假期学习计划"><a href="#1-国庆假期学习计划" class="headerlink" title="1.国庆假期学习计划"></a>1.国庆假期学习计划</h2><ul><li><p><input disabled type="checkbox"> <strong>复习C++</strong></p></li><li><p><input disabled type="checkbox"> <strong>STL源码</strong></p><ul><li><p><input disabled type="checkbox"> 分配器实现</p></li><li><p><input disabled type="checkbox"> string实现</p></li><li><p><input disabled type="checkbox"> vector实现</p></li><li><p><input disabled type="checkbox"> hash-map实现</p></li></ul></li><li><p><input disabled type="checkbox"> <strong>学习国外恶意代码分析文章</strong></p><ul><li><input disabled type="checkbox"> 测试环境搭建</li><li><input disabled type="checkbox"> 分析报告编写</li></ul></li><li><p><input disabled type="checkbox"> <strong>学习TCP&#x2F;IP协议</strong></p><ul><li><input disabled type="checkbox"> TCP底层原理</li><li><input disabled type="checkbox"> IP底层原理</li></ul></li></ul><h2 id="2-项目计划"><a href="#2-项目计划" class="headerlink" title="2.项目计划"></a>2.项目计划</h2><ul><li><input disabled type="checkbox"> <strong>实现Tiny Kernel</strong></li><li><input disabled type="checkbox"> <strong>实现武器库（高阶HOOK、注入、ShellCode生成、PE变形）</strong></li><li><input disabled type="checkbox"> <strong>原始套接字实现TCP&#x2F;IP协议栈</strong></li><li><input disabled type="checkbox"> <strong>学习编译原理，实现脚本引擎</strong></li><li><input disabled type="checkbox"> <strong>实现STL</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>tasks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>goal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特征码搜索</title>
    <link href="/2022/09/23/te-zheng-ma-sou-suo/"/>
    <url>/2022/09/23/te-zheng-ma-sou-suo/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Sunday字符串搜索算法"><a href="#1-Sunday字符串搜索算法" class="headerlink" title="1.Sunday字符串搜索算法"></a>1.Sunday字符串搜索算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">String2Bytes</span><span class="hljs-params">(<span class="hljs-type">char</span>* szSrc, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>* szDst)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>WORD TzmLength = <span class="hljs-built_in">strlen</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)szSrc) / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//将十六进制特征码转为十进制</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)szSrc); )<br>&#123;<br><span class="hljs-type">char</span> num[<span class="hljs-number">2</span>];<br>num[<span class="hljs-number">0</span>] = szSrc[i++];<br>num[<span class="hljs-number">1</span>] = szSrc[i++];<br>i++;<br><span class="hljs-keyword">if</span> (num[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;?&#x27;</span> &amp;&amp; num[<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;?&#x27;</span>)<br>&#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>WORD a[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (num[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; num[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br>a[i] = num[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; num[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>&#123;<br>a[i] = num[i] - <span class="hljs-number">87</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; num[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)<br>&#123;<br>a[i] = num[i] - <span class="hljs-number">55</span>;<br>&#125;<br><br>&#125;<br>sum = a[<span class="hljs-number">0</span>] * <span class="hljs-number">16</span> + a[<span class="hljs-number">1</span>];<br>szDst[len++] = sum;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>szDst[len++] = <span class="hljs-number">256</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> TzmLength;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SundayStrSearch</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* szSrc, <span class="hljs-type">char</span>* szDst, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; vRes)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">size_t</span> sSrc = <span class="hljs-built_in">strlen</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)szSrc);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>* pDst = (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span> * (<span class="hljs-built_in">strlen</span>(szDst) / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>));<br><span class="hljs-type">size_t</span> sDst = <span class="hljs-built_in">String2Bytes</span>(szDst, pDst);<br><br><span class="hljs-comment">// 构造Next数组</span><br><span class="hljs-type">short</span> szNext[<span class="hljs-number">260</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">260</span>; i++)<br>szNext[i] = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sDst; i++)<br>szNext[pDst[i]] = i;<br><br><span class="hljs-comment">// 字符串匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j, k; i &lt; sSrc;)<br>&#123;<br>j = i; k = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (; k &lt; sDst &amp;&amp; j &lt; sSrc &amp;&amp; (pDst[k] == szSrc[j] || pDst[k] == <span class="hljs-number">256</span>); k++, j++);<br><br><span class="hljs-keyword">if</span> (k == sDst)<br>&#123;<br>vRes.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">size_t</span>)(i + sDst) &gt;= sSrc)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-type">int</span> num = szNext[szSrc[sDst + i]];<br><span class="hljs-keyword">if</span> (num == <span class="hljs-number">-1</span>)<br>i += (sDst - szNext[<span class="hljs-number">256</span>]);<br><span class="hljs-keyword">else</span><br>i += (sDst - num);<br>&#125;<br><span class="hljs-keyword">if</span> (pDst)<br>&#123;<br><span class="hljs-built_in">free</span>(pDst);<br>pDst = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> pSrc[] = <br>&#123;<br><span class="hljs-number">0xFF</span>, <span class="hljs-number">0x87</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0x00</span><br>&#125;;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br><span class="hljs-built_in">SundayStrSearch</span>(pSrc, <span class="hljs-string">&quot;88 ?? 67&quot;</span>, res);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); i++)<br>cout &lt;&lt; res[i] &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>lib</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++类逆向</title>
    <link href="/2022/09/14/class-reverse/"/>
    <url>/2022/09/14/class-reverse/</url>
    
    <content type="html"><![CDATA[<h2 id="1-对象内存布局"><a href="#1-对象内存布局" class="headerlink" title="1.对象内存布局"></a>1.对象内存布局</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span>: <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>    &#123;<br>        <span class="hljs-comment">// 虚表指针</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Base_vtable</span>*<br>    <span class="hljs-comment">// 父类成员结构</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Base_member</span><br>        &#123;<br>            <span class="hljs-type">int</span> m_iVal1;<br>            <span class="hljs-type">char</span> m_cVal2;<br>        &#125;;<br>    &#125;;<br>    <span class="hljs-comment">// 子类自身成员结构</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">A1_member</span><br>    &#123;<br>        <span class="hljs-type">float</span> m_fVal1;<br>        <span class="hljs-type">char</span>* m_pcVal2;<br>    &#125;;<br>&#125;;<br><br><span class="hljs-comment">// Base虚表结构</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base_vtable</span><br>&#123;<br>   int64 fun1;<br>   int64 fun2;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-1-基本类"><a href="#1-1-基本类" class="headerlink" title="1.1 基本类"></a>1.1 基本类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">short</span> z)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br><span class="hljs-keyword">this</span>-&gt;z = z;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; x &lt;&lt; std::endl;<br>std::cout &lt;&lt; y &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">char</span> y;<br><span class="hljs-type">short</span> z;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-function">A1 <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>)</span></span>;<br>a1.<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于基本类，从对象创建的地方找到构造函数，根据结构偏移使用情况来确定边界和成员类型，并在之后分析过程中不断修改完善。</p><p><strong>结构体定义模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914173617123.png" alt="基本结构模板"></p><h3 id="1-2-组合类"><a href="#1-2-组合类" class="headerlink" title="1.2 组合类"></a>1.2 组合类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A2</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetX</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetY</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> y;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">float</span> x;<br><span class="hljs-type">float</span> y;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">short</span> z)<br>:<span class="hljs-built_in">a2</span>(<span class="hljs-number">3.2</span>, <span class="hljs-number">4.3</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;y[i] = i+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;z = z;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; x &lt;&lt; std::endl;<br>std::cout &lt;&lt; y &lt;&lt; std::endl;<br><br>std::cout &lt;&lt; y[<span class="hljs-number">5</span>] &lt;&lt; std::endl;<br><br>std::cout &lt;&lt; a2.<span class="hljs-built_in">GetX</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; a2.<span class="hljs-built_in">GetY</span>() &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">char</span> y[<span class="hljs-number">20</span>];<br><span class="hljs-type">short</span> z;<br>A2 a2;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-function">A1 <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>)</span></span>;<br>a1.<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>组合类在分析的时候可以看见很明显的特征，就是在class1的构造函数中会将 this + x 的地址传入class2的构造函数中进行初始化，这个偏移x的位置就是class2的起始位置。</p><p><img src="/2022/09/14/class-reverse/image-20220914104738064.png" alt="组合类特征"></p><p><strong>结构体定义模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914173829653.png" alt="组合类结构模板"></p><h3 id="1-3-单继承类"><a href="#1-3-单继承类" class="headerlink" title="1.3 单继承类"></a>1.3 单继承类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A2</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> len)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>(len);<br><span class="hljs-built_in">strcpy</span>(b, <span class="hljs-string">&quot;Base&quot;</span>);<br>&#125;<br>~<span class="hljs-built_in">A2</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;b)<br>&#123;<br><span class="hljs-built_in">free</span>(<span class="hljs-keyword">this</span>-&gt;b);<br><span class="hljs-keyword">this</span>-&gt;b = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">char</span> *b;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>: <span class="hljs-keyword">public</span> A2<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">short</span> c)<br>:<span class="hljs-built_in">A2</span>(<span class="hljs-number">8</span>, <span class="hljs-number">12</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br><span class="hljs-keyword">this</span>-&gt;c = c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">encrypt</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> key + b[<span class="hljs-number">3</span>] + b[<span class="hljs-number">5</span>] * arr[<span class="hljs-number">1</span>] / a + c;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">short</span> c;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-function">A1 <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span></span>;<br>std::cout &lt;&lt; a.<span class="hljs-built_in">encrypt</span>(<span class="hljs-number">10</span>) &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于继承关系的类识别，可以看构造函数中是否有将原始this指针直接传递给父类构造函数的操作。实际上在不含有虚函数的继承关系中，可以把子类和父类合并来看待。<strong>普通继承关系实际上就是把父类的成员原封不动的拷贝过来，作为子类对象结构开头的一部分。</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914113639610.png" alt="继承关系特征"></p><p><strong>结构体定义标准模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914165807726.png" alt="单继承结构模板"></p><h3 id="1-4-多继承类"><a href="#1-4-多继承类" class="headerlink" title="1.4 多继承类"></a>1.4 多继承类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TopBase</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">TopBase</span>(<span class="hljs-type">int</span> id, <span class="hljs-type">char</span>* name)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;dwId = id;<br><span class="hljs-keyword">this</span>-&gt;sName = name;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> dwId;<br><span class="hljs-type">char</span>* sName;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mid1</span><br>:<span class="hljs-keyword">public</span> TopBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Mid1</span>(<span class="hljs-type">int</span> age)<br>:<span class="hljs-built_in">TopBase</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;jack&quot;</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;age = age;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mid2</span><br>:<span class="hljs-keyword">public</span> TopBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Mid2</span>(<span class="hljs-type">char</span> high)<br>:<span class="hljs-built_in">TopBase</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;tom&quot;</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;high = high;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">char</span> high;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bottom</span><br>:<span class="hljs-keyword">public</span> Mid1, Mid2<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Bottom</span>(<span class="hljs-type">char</span>* grade, <span class="hljs-type">char</span>* name)<br>:<span class="hljs-built_in">Mid1</span>(<span class="hljs-number">20</span>), <span class="hljs-built_in">Mid2</span>(<span class="hljs-number">185</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;grade = grade;<br><span class="hljs-keyword">this</span>-&gt;sName = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; age &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span>* grade;<br><span class="hljs-type">char</span>* sName;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Bottom <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-string">&quot;100&quot;</span>, <span class="hljs-string">&quot;xiaoming&quot;</span>)</span></span>;<br>obj.<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>继承关系呈现菱形结构，就是有两个类继承自同一个类，同时又有另外一个类同时继承自这两个。多重继承会在子类中出现<strong>多个父类的members结构</strong>，并根据先后顺序排列，可以从最上层依次分析，逐渐向下递进，直至分析出继承树结构。</p><p><strong>多重继承结构体定义标准模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914173422053.png" alt="多重继承结构定义模板"></p><h3 id="1-4-虚表类"><a href="#1-4-虚表类" class="headerlink" title="1.4 虚表类"></a>1.4 虚表类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base1</span>(<span class="hljs-type">char</span>* str)<br>&#123;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str);<br>pa = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len];<br><span class="hljs-built_in">strcpy</span>(pa, str);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Base1&quot;</span> &lt;&lt; std::endl;<br>std::cout &lt;&lt; pa &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base1</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (pa)<br>&#123;<br><span class="hljs-built_in">free</span>(pa);<br>pa = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">char</span>* pa;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base2</span>(<span class="hljs-type">int</span> a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base2</span>()<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;destory Base2&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> a;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>:<span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>()<br>:<span class="hljs-built_in">Base1</span>(<span class="hljs-string">&quot;Hello&quot;</span>), <span class="hljs-built_in">Base2</span>(<span class="hljs-number">5</span>)<br>&#123;<br><span class="hljs-built_in">strcpy</span>(buf, <span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;A1&quot;</span> &lt;&lt; std::endl;<br>std::cout &lt;&lt; buf &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">A1</span>()<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;A1 destory&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A1 a1;<br>Base1* p = &amp;a1;<br>p-&gt;<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>虚表指针属于基类，不属于子类，子类只是将其继承过来。</strong>所以在子类的结构中应包含父类的结构，在父类的结构中包含虚表结构和父类成员结构。多个父类结构在子类结构中顺序排列。</p><p><strong>多重继承虚表结构定义标准模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914162409783.png" alt="多重继承下的虚表结构模板"></p><h2 id="2-对象创建方式"><a href="#2-对象创建方式" class="headerlink" title="2.对象创建方式"></a>2.对象创建方式</h2><h3 id="2-1-局部对象"><a href="#2-1-局部对象" class="headerlink" title="2.1 局部对象"></a>2.1 局部对象</h3><p>局部对象是最常见的创建方式，反汇编可以看见直接将栈内存地址传给构造函数。</p><p><img src="/2022/09/14/class-reverse/image-20220914181153384.png" alt="局部对象创建"></p><h3 id="2-2-堆对象"><a href="#2-2-堆对象" class="headerlink" title="2.2 堆对象"></a>2.2 堆对象</h3><p>对象存在new关键字动态申请出来的内存中，反汇编可以看见直接将new得到的地址传入构造函数。</p><p><img src="/2022/09/14/class-reverse/image-20220914181409983.png" alt="堆对象创建"></p><h3 id="2-3-全局对象和静态对象"><a href="#2-3-全局对象和静态对象" class="headerlink" title="2.3 全局对象和静态对象"></a>2.3 全局对象和静态对象</h3><p>对于全局对象和静态对象，都是在.data段分配内存，区别就是静态对象说明对象作用域在当前文件中。识别全局对象的调用可以寻找 lea rcx, qword_xxx 指令。</p><p>全局对象的构造函数在main函数前完成，在 crt-&gt;initterm 中完成初始化。</p><p><img src="/2022/09/14/class-reverse/image-20220915114054354.png" alt="initterm"></p><p>可以在First到Last区间内找到所有的代理构造函数地址，代理构造函数负责调用构造函数完成初始化以及调用 atexit 函数来注册析构函数，以便在main函数结束后调用。</p><p><img src="/2022/09/14/class-reverse/image-20220915114452944.png" alt="代理构造函数"></p><h3 id="2-4-参数对象"><a href="#2-4-参数对象" class="headerlink" title="2.4 参数对象"></a>2.4 参数对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_dwVal1 = a;<br><span class="hljs-keyword">this</span>-&gt;m_cVal2[<span class="hljs-number">5</span>] = b;<br>&#125;<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">const</span> A1&amp; c)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_dwVal1 = c.m_dwVal1;<br><span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;m_cVal2, c.m_cVal2);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_dwVal1 &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_cVal2[<span class="hljs-number">8</span>] &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_dwVal1;<br><span class="hljs-type">char</span> m_cVal2[<span class="hljs-number">20</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(A1 arg)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; arg.m_cVal2[<span class="hljs-number">3</span>] &lt;&lt; std::endl;<br>arg.<span class="hljs-built_in">show</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-function">A1 <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-built_in">Show</span>(a1);<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用拷贝构造函数或直接复制对象空间内存来在参数区构造一个新的对象，并将新对象的内存首地址给调用的函数。</p><p><img src="/2022/09/14/class-reverse/image-20220915144147889.png" alt="参数对象传递"></p><h3 id="2-5-返回对象"><a href="#2-5-返回对象" class="headerlink" title="2.5 返回对象"></a>2.5 返回对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_dwVal1 = a;<br><span class="hljs-keyword">this</span>-&gt;m_cVal2[<span class="hljs-number">5</span>] = b;<br>&#125;<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">const</span> A1&amp; c)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_dwVal1 = c.m_dwVal1;<br><span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;m_cVal2, c.m_cVal2);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_dwVal1 &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_cVal2[<span class="hljs-number">8</span>] &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_dwVal1;<br><span class="hljs-type">char</span> m_cVal2[<span class="hljs-number">20</span>];<br>&#125;;<br><br><span class="hljs-function">A1 <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">A1 <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-keyword">return</span> a1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>A1 a1 = <span class="hljs-built_in">Show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对象作为返回值传递会先在调用之前将缓冲区首地址提前传进去（即使那个函数没有参数）。</p><p><img src="/2022/09/14/class-reverse/image-20220915145145190.png" alt="main函数"></p><p>在函数里面调用构造函数，在函数返回前根据传进来的上一个函数缓冲区的首地址和当前这个对象的首地址作为参数来调用拷贝构造函数。</p><p><img src="/2022/09/14/class-reverse/image-20220915145215817.png" alt="Show函数"></p>]]></content>
    
    
    <categories>
      
      <category>reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ida基础用法</title>
    <link href="/2022/09/13/ida-basic/"/>
    <url>/2022/09/13/ida-basic/</url>
    
    <content type="html"><![CDATA[<h2 id="1-常用快捷键"><a href="#1-常用快捷键" class="headerlink" title="1.常用快捷键"></a>1.常用快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Shift + F12</td><td>打开字符串窗口</td></tr><tr><td>Y</td><td>改变函数原型或变量类型</td></tr><tr><td>D</td><td>宽度转换以及结构体中新增成员</td></tr><tr><td>R</td><td>字符转换</td></tr><tr><td>H</td><td>进制转换</td></tr><tr><td>&#x2F;</td><td>伪代码中添加注释</td></tr><tr><td>X</td><td>查看交叉引用</td></tr><tr><td>TAB</td><td>汇编指令和伪代码之间切换</td></tr><tr><td>Shift + E</td><td>得到数组</td></tr><tr><td>Alt + T</td><td>搜索字符串</td></tr><tr><td>Alt + I</td><td>搜索立即数</td></tr><tr><td>Alt + B</td><td>搜索二进制</td></tr></tbody></table><h2 id="2-伪代码修复"><a href="#2-伪代码修复" class="headerlink" title="2.伪代码修复"></a>2.伪代码修复</h2><h3 id="2-1-逆向命名规则"><a href="#2-1-逆向命名规则" class="headerlink" title="2.1 逆向命名规则"></a>2.1 逆向命名规则</h3><h4 id="2-1-1-类型命名"><a href="#2-1-1-类型命名" class="headerlink" title="2.1.1 类型命名"></a><strong>2.1.1 类型命名</strong></h4><table><thead><tr><th>类型</th><th>前缀</th></tr></thead><tbody><tr><td>数组</td><td>a</td></tr><tr><td>布尔</td><td>b</td></tr><tr><td>字符byte</td><td>c</td></tr><tr><td>短整型word</td><td>w</td></tr><tr><td>整型dowrd</td><td>dw</td></tr><tr><td>整形qword</td><td>qw</td></tr><tr><td>指针</td><td>p</td></tr><tr><td>类成员</td><td>m_</td></tr><tr><td>字符串</td><td>sz</td></tr></tbody></table><h4 id="2-1-2-符号命名"><a href="#2-1-2-符号命名" class="headerlink" title="2.1.2 符号命名"></a><strong>2.1.2 符号命名</strong></h4><table><thead><tr><th>符号类型</th><th>规则</th><th>示例</th></tr></thead><tbody><tr><td>栈变量</td><td>类型前缀 + 名字</td><td>szWelcome</td></tr><tr><td>全局变量</td><td>g_类型前缀 + 名字</td><td>g_dwTime</td></tr><tr><td>普通函数</td><td>大功能 + 具体功能</td><td>memAlloc</td></tr><tr><td>成员函数</td><td>类名字::函数名</td><td>Student::getNum</td></tr></tbody></table><h3 id="2-2-不规则代码"><a href="#2-2-不规则代码" class="headerlink" title="2.2 不规则代码"></a>2.2 不规则代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">def <span class="hljs-title function_">LOBYTE</span><span class="hljs-params">(x)</span>:     <span class="hljs-keyword">return</span> x &amp; 0xff<br>def <span class="hljs-title function_">HIBYTE</span><span class="hljs-params">(x)</span>:     <span class="hljs-title function_">return</span> <span class="hljs-params">(x &gt;&gt; <span class="hljs-number">8</span>)</span> &amp; 0xff<br>def <span class="hljs-title function_">LOWORD</span><span class="hljs-params">(x)</span>:     <span class="hljs-keyword">return</span> x &amp; 0xffff<br>def <span class="hljs-title function_">HIWORD</span><span class="hljs-params">(x)</span>:     <span class="hljs-title function_">return</span> <span class="hljs-params">(x &gt;&gt; <span class="hljs-number">16</span>)</span> &amp; 0xffff<br>def <span class="hljs-title function_">LODWORD</span><span class="hljs-params">(x)</span>:    <span class="hljs-keyword">return</span> x &amp; 0xffffffff<br>def <span class="hljs-title function_">HIDWORD</span><span class="hljs-params">(x)</span>:    <span class="hljs-title function_">return</span> <span class="hljs-params">(x &gt;&gt; <span class="hljs-number">32</span>)</span> &amp; 0xffffffff<br></code></pre></td></tr></table></figure><h3 id="2-3-修复函数原型"><a href="#2-3-修复函数原型" class="headerlink" title="2.3 修复函数原型"></a>2.3 修复函数原型</h3><h4 id="2-3-1-返回值类型"><a href="#2-3-1-返回值类型" class="headerlink" title="2.3.1 返回值类型"></a>2.3.1 返回值类型</h4><p>​当分析出某个函数的返回值类型始终（交叉引用）不会被使用后，可以将函数原型的返回值类型改成void，可以优化掉多余代码。</p><h4 id="2-3-2-参数个数和类型"><a href="#2-3-2-参数个数和类型" class="headerlink" title="2.3.2 参数个数和类型"></a>2.3.2 参数个数和类型</h4><p>​在x64下，有些函数没有参数，但由于调用约定，F5后的伪代码中可能出现参数，将多余的参数删除，可以优化代码。而且有些参数是使用寄存器传递，如浮点寄存器，这时伪代码中可能无法正确识别，需要结合汇编分析，并手动添加参数，可以增加可读性。</p><h3 id="2-4-修复变量类型"><a href="#2-4-修复变量类型" class="headerlink" title="2.4 修复变量类型"></a>2.4 修复变量类型</h3><h4 id="2-4-1-结构体定义"><a href="#2-4-1-结构体定义" class="headerlink" title="2.4.1 结构体定义"></a>2.4.1 结构体定义</h4><p>​恢复结构体类型可以大大代码可读性，可以根据new的大小和分析成员使用情况来确定结构体边界和成员类型。下面展示类的结构定义模板：</p><p><img src="/2022/09/13/ida-basic/image-20220913182821578.png" alt="类结构模板"></p><h4 id="2-4-2-数组定义"><a href="#2-4-2-数组定义" class="headerlink" title="2.4.2 数组定义"></a>2.4.2 数组定义</h4><p>​对于连续的内存空间的操作，可以酌情还原为数组，增加可读性。</p><h2 id="3-符号还原"><a href="#3-符号还原" class="headerlink" title="3.符号还原"></a>3.符号还原</h2><h3 id="3-1-基于签名文件的符号还原"><a href="#3-1-基于签名文件的符号还原" class="headerlink" title="3.1 基于签名文件的符号还原"></a>3.1 基于签名文件的符号还原</h3><h3 id="3-2-基于Bindff的符号还原"><a href="#3-2-基于Bindff的符号还原" class="headerlink" title="3.2 基于Bindff的符号还原"></a>3.2 基于Bindff的符号还原</h3>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
      <tag>ida</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编指令基础</title>
    <link href="/2022/09/12/asm-basic/"/>
    <url>/2022/09/12/asm-basic/</url>
    
    <content type="html"><![CDATA[<h2 id="1-EFLAGS"><a href="#1-EFLAGS" class="headerlink" title="1.EFLAGS"></a>1.EFLAGS</h2><p><img src="/2022/09/12/asm-basic/eflags.png" alt="eflags"></p><h2 id="2-测试与比较"><a href="#2-测试与比较" class="headerlink" title="2.测试与比较"></a>2.测试与比较</h2><h3 id="2-1-test"><a href="#2-1-test" class="headerlink" title="2.1 test"></a>2.1 test</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">test rax, rbx<br>; 等价形式如下<br>push rax<br>and rax, rbx<br>pop rax<br></code></pre></td></tr></table></figure><h3 id="2-2-cmp"><a href="#2-2-cmp" class="headerlink" title="2.2 cmp"></a>2.2 cmp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp rax, rbx<br>; 等价形式如下<br>push rax<br>sub rax, rbx<br>pop rax<br></code></pre></td></tr></table></figure><h2 id="3-跳转"><a href="#3-跳转" class="headerlink" title="3.跳转"></a>3.跳转</h2><h3 id="3-1-JCC条件跳转"><a href="#3-1-JCC条件跳转" class="headerlink" title="3.1 JCC条件跳转"></a>3.1 JCC条件跳转</h3><ul><li><strong>短跳：</strong>2字节，1字节硬编码 + 1字节有符号偏移</li><li><strong>长跳：</strong>6字节，2字节硬编码 + 4字节有符号地址</li></ul><table><thead><tr><th>指令</th><th>短跳</th><th>长跳</th><th>含义</th><th>EFLAGS</th></tr></thead><tbody><tr><td>JZ&#x2F;JE</td><td>0x74</td><td>0x0F 0x84</td><td>相等则跳转</td><td>ZF &#x3D;&#x3D; 1</td></tr><tr><td>JNZ&#x2F;JNE</td><td>0x75</td><td>0x0F 0x85</td><td>不相等则跳转</td><td>ZF &#x3D;&#x3D; 0</td></tr><tr><td>JS</td><td>0x78</td><td>0x0F 0x88</td><td>负数则跳转</td><td>SF &#x3D;&#x3D; 1</td></tr><tr><td>JNS</td><td>0x79</td><td>0x0F 0x89</td><td>正数则跳转</td><td>SF &#x3D;&#x3D; 0</td></tr><tr><td>JP&#x2F;JPE</td><td>0x7A</td><td>0x0F 0x8A</td><td>1出现次数为偶数则跳转</td><td>PF &#x3D;&#x3D; 1</td></tr><tr><td>JNP&#x2F;JPO</td><td>0x7B</td><td>0x0F 0x8B</td><td>1出现次数为奇数则跳转</td><td>PF &#x3D;&#x3D; 0</td></tr><tr><td>JC&#x2F;JB&#x2F;JNAE</td><td>0x72</td><td>0x0F 0x82</td><td>无符号数 (进位)低于则跳转</td><td>CF &#x3D;&#x3D; 1</td></tr><tr><td>JNC&#x2F;JNB&#x2F;JAE</td><td>0x73</td><td>0x0F 0x83</td><td>无符号数 (不进位)高于等于则跳转</td><td>CF &#x3D;&#x3D; 0</td></tr><tr><td>JO</td><td>0x70</td><td>0x0F 0x80</td><td>有符号数 溢出则跳转</td><td>OF &#x3D;&#x3D; 1</td></tr><tr><td>JNO</td><td>0x71</td><td>0x0F 0x81</td><td>有符号数 无溢出则跳转</td><td>OF &#x3D;&#x3D; 0</td></tr><tr><td>JBE&#x2F;JNA</td><td>0x76</td><td>0x0F 0x86</td><td>无符号数 低于等于则跳转</td><td>ZF &#x3D;&#x3D; 1 || CF &#x3D;&#x3D; 1</td></tr><tr><td>JNBE&#x2F;JA</td><td>0x77</td><td>0x0F 0x87</td><td>无符号数 高于则跳转</td><td>ZF &#x3D;&#x3D; 0 || CF &#x3D;&#x3D; 0</td></tr><tr><td>JL&#x2F;JNGE</td><td>0x7C</td><td>0x0F 0x8C</td><td>有符号数 小于则跳转</td><td>SF !&#x3D; OF</td></tr><tr><td>JNL&#x2F;JGE</td><td>0x7D</td><td>0x0F 0x8D</td><td>有符号数 大于等于则跳转</td><td>SF &#x3D;&#x3D; OF</td></tr><tr><td>JLE&#x2F;JNG</td><td>0x7E</td><td>0x0F 0x8E</td><td>有符号数 小于等于则跳转</td><td>ZF !&#x3D; OF || ZF &#x3D;&#x3D; 1</td></tr><tr><td>JNLE&#x2F;JG</td><td>0x7F</td><td>0x0F 0x8F</td><td>有符号数 大于则跳转</td><td>SF &#x3D;&#x3D; 0F &amp;&amp; ZF &#x3D;&#x3D; 0</td></tr></tbody></table><h3 id="3-2-CALL无条件跳转"><a href="#3-2-CALL无条件跳转" class="headerlink" title="3.2 CALL无条件跳转"></a>3.2 CALL无条件跳转</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E8</span> + <span class="hljs-number">4</span>字节有符号偏移：偏移CALL，最常见用法。<br></code></pre></td></tr></table></figure><p><strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 4字节偏移</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**FF 15 + 4字节：**</span>间接CALL，长用于调用导入表中函数。<br></code></pre></td></tr></table></figure><ul><li><p>x86：后面跟4字节内存地址。</p><p><strong>跳转目标地址 &#x3D; ptr:[ 4字节内存地址 ]</strong></p></li><li><p>x64：后面跟4字节偏移，再使用偏移计算公式得到4字节内存地址。</p></li></ul><p>​<strong>跳转目标地址 &#x3D; ptr:[ 当前指令地址 + 当前指令长度 + 4字节偏移 ]</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">9A + <span class="hljs-number">4</span>字节地址 + 目标<span class="hljs-built_in">cs</span>：绝对<span class="hljs-keyword">CALL</span>，仅x86有效，可以跳转到绝对地址同时改变<span class="hljs-built_in">cs</span>的值，<span class="hljs-built_in">far</span>常用于实现调用门。<br></code></pre></td></tr></table></figure><p>​<strong>跳转目标地址 &#x3D; 4字节地址、cs &#x3D; 目标cs</strong></p><h3 id="3-3-JMP无条件跳转"><a href="#3-3-JMP无条件跳转" class="headerlink" title="3.3 JMP无条件跳转"></a>3.3 JMP无条件跳转</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EB</span> + <span class="hljs-number">1</span>字节有符号偏移：偏移短跳转<br></code></pre></td></tr></table></figure><p>​<strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 1字节偏移</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E9</span> + <span class="hljs-number">4</span>字节有符号偏移：偏移近跳转<br></code></pre></td></tr></table></figure><p>​<strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 4字节偏移</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FF</span> <span class="hljs-number">25</span> + <span class="hljs-number">4</span>字节：间接跳转<br></code></pre></td></tr></table></figure><ul><li><p>x86：后面跟4字节内存地址。</p><p><strong>跳转目标地址 &#x3D; ptr:[ 4字节内存地址 ]</strong></p></li><li><p>x64：后面跟4字节偏移，再使用偏移计算公式得到4字节内存地址。</p></li></ul><p>​<strong>跳转目标地址 &#x3D; ptr:[ 当前指令地址 + 当前指令长度 + 4字节偏移 ]</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">EA + <span class="hljs-number">4</span>字节地址 + 目标<span class="hljs-built_in">cs</span>：绝对跳转，仅x86有效，可以跳转到绝对地址同时改变<span class="hljs-built_in">cs</span>的值，<span class="hljs-built_in">far</span>常用于实现调用门。<br></code></pre></td></tr></table></figure><p>​<strong>跳转目标地址 &#x3D; 4字节地址、cs &#x3D; 目标cs</strong></p><h3 id="3-4-x64下的Inline-HOOK"><a href="#3-4-x64下的Inline-HOOK" class="headerlink" title="3.4 x64下的Inline HOOK"></a>3.4 x64下的Inline HOOK</h3><p>enter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">方法1：12字节<br>mov rax, 0x123456789<br>jmp rax<br>方法2：12字节<br>mov rax, 0x123456789<br>push rax<br>ret<br>方法3：不破坏寄存器  13字节<br>push rax<br>mov rax, 0x123456789<br>jmp rax<br>```<br>pop rax<br></code></pre></td></tr></table></figure><p>ret</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">方法1：20字节<br>sub rsp, 0x8<br>mov dword ptr ss:[rsp], 0x1234<br>mov dword ptr ss:[rsp+0x4], 0x56789ABC<br>ret<br><br>方法2：14字节<br>push 0x12345678<br>mov dword ptr ss:[rsp+4], 0x9ABC<br>ret<br></code></pre></td></tr></table></figure><h2 id="4-基本运算"><a href="#4-基本运算" class="headerlink" title="4.基本运算"></a>4.基本运算</h2><h3 id="4-1-除法"><a href="#4-1-除法" class="headerlink" title="4.1 除法"></a>4.1 除法</h3><p>无符号：div + 除数</p><p>有符号：idiv + 除数，余数的符号与被除数相同。</p><table><thead><tr><th>被除数</th><th>除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td>ax</td><td>reg&#x2F;mem8</td><td>al</td><td>ah</td></tr><tr><td>dx:ax</td><td>reg&#x2F;mem16</td><td>ax</td><td>dx</td></tr><tr><td>edx:eax</td><td>reg&#x2F;mem32</td><td>eax</td><td>edx</td></tr><tr><td>rdx:rax</td><td>reg&#x2F;mem64</td><td>rax</td><td>rdx</td></tr></tbody></table><h3 id="4-2-乘法"><a href="#4-2-乘法" class="headerlink" title="4.2 乘法"></a>4.2 乘法</h3><p><strong>单操作数：</strong></p><p>​无符号：mul + 乘数</p><p>​有符号：imul + 乘数</p><table><thead><tr><th>被乘数</th><th>乘数</th><th>乘积</th></tr></thead><tbody><tr><td>al</td><td>reg&#x2F;mem8</td><td>ax</td></tr><tr><td>ax</td><td>reg&#x2F;mem16</td><td>dx:ax</td></tr><tr><td>eax</td><td>reg&#x2F;mem32</td><td>edx:eax</td></tr><tr><td>rax</td><td>reg&#x2F;mem64</td><td>rdx:rax</td></tr></tbody></table><p>对于无符号数，计算后如果dx&#x2F;edx&#x2F;rdx寄存器不为0，则CF位被置位。</p><p>对于有符号数，计算后如果dx&#x2F;edx&#x2F;rdx寄存器不为ax&#x2F;eax&#x2F;rax的符号扩展，则OF和CF位被置位。</p><p><strong>双操作数：</strong>不支持8位，必须是有符号数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul reg1, reg2/mem/imm<br>; 等价形式如下<br>reg1 = reg1 * reg2/mem/imm<br></code></pre></td></tr></table></figure><p><strong>三操作数：</strong>不支持8位，必须是有符号数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul reg1, reg2/mem, imm<br>; 等价形式如下<br>reg1 = reg2/mem * imm<br></code></pre></td></tr></table></figure><h3 id="4-3-移位"><a href="#4-3-移位" class="headerlink" title="4.3 移位"></a>4.3 移位</h3><p><strong>逻辑：</strong>shl、shr</p><p><strong>算数：</strong>sal、sar</p><p>逻辑左移与逻辑左移没区别，算数右移左边补符号位，逻辑右移坐标补0。右移除以2，左移乘以2。</p><h2 id="5-数据传送"><a href="#5-数据传送" class="headerlink" title="5.数据传送"></a>5.数据传送</h2><h3 id="5-1-扩展传送"><a href="#5-1-扩展传送" class="headerlink" title="5.1 扩展传送"></a>5.1 扩展传送</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movsx：符号位扩展<br>movzx：0扩展<br></code></pre></td></tr></table></figure><h3 id="5-2-隐式传送"><a href="#5-2-隐式传送" class="headerlink" title="5.2 隐式传送"></a>5.2 隐式传送</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movs_b/w/d/q<br>; 等价形式如下<br>if(DF == 0); cld<br>&#123;<br>[edi++] = [esi++]<br>&#125;<br>else; std<br>&#123;<br>[edi--] = [esi--]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-字符串获取"><a href="#5-3-字符串获取" class="headerlink" title="5.3 字符串获取"></a>5.3 字符串获取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lods_b/w/d/q<br>; 等价形式如下<br>if(DF == 0); cld<br>&#123;<br>eax = [esi++]<br>&#125;<br>else; std<br>&#123;<br>eax = [esi--]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-字符串加载"><a href="#5-4-字符串加载" class="headerlink" title="5.4 字符串加载"></a>5.4 字符串加载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">stos_b/w/d/q<br>; 等价形式如下<br>if(DF == 0); cld<br>&#123;<br>[edi++] = eax <br>&#125;<br>else; std<br>&#123;<br>[edi--] = eax <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
      <tag>x86/x64 asm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
