<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ida-basic</title>
      <link href="/2022/09/13/ida-basic/"/>
      <url>/2022/09/13/ida-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="1-常用快捷键"><a href="#1-常用快捷键" class="headerlink" title="1.常用快捷键"></a>1.常用快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Shift + F12</td><td>打开字符串窗口</td></tr><tr><td>Y</td><td>改变函数原型或变量类型</td></tr><tr><td>D</td><td>宽度转换以及结构体中新增成员</td></tr><tr><td>R</td><td>字符转换</td></tr><tr><td>H</td><td>进制转换</td></tr><tr><td>&#x2F;</td><td>伪代码中添加注释</td></tr><tr><td>X</td><td>查看交叉引用</td></tr><tr><td>TAB</td><td>汇编指令和伪代码之间切换</td></tr><tr><td>Shift + E</td><td>得到数组</td></tr><tr><td>Alt + T</td><td>搜索字符串</td></tr><tr><td>Alt + I</td><td>搜索立即数</td></tr><tr><td>Alt + B</td><td>搜索二进制</td></tr></tbody></table><h2 id="2-伪代码修复"><a href="#2-伪代码修复" class="headerlink" title="2.伪代码修复"></a>2.伪代码修复</h2><h3 id="2-1-逆向命名规则"><a href="#2-1-逆向命名规则" class="headerlink" title="2.1 逆向命名规则"></a>2.1 逆向命名规则</h3><h4 id="2-1-1-类型命名"><a href="#2-1-1-类型命名" class="headerlink" title="2.1.1 类型命名"></a><strong>2.1.1 类型命名</strong></h4><table><thead><tr><th>类型</th><th>前缀</th></tr></thead><tbody><tr><td>数组</td><td>a</td></tr><tr><td>布尔</td><td>b</td></tr><tr><td>字符byte</td><td>c</td></tr><tr><td>短整型word</td><td>w</td></tr><tr><td>整型dowrd</td><td>dw</td></tr><tr><td>整形qword</td><td>qw</td></tr><tr><td>指针</td><td>p</td></tr><tr><td>类成员</td><td>m_</td></tr><tr><td>字符串</td><td>sz</td></tr></tbody></table><h4 id="2-1-2-符号命名"><a href="#2-1-2-符号命名" class="headerlink" title="2.1.2 符号命名"></a><strong>2.1.2 符号命名</strong></h4><table><thead><tr><th>符号类型</th><th>规则</th><th>示例</th></tr></thead><tbody><tr><td>栈变量</td><td>类型前缀 + 名字</td><td>szWelcome</td></tr><tr><td>全局变量</td><td>g_类型前缀 + 名字</td><td>g_dwTime</td></tr><tr><td>普通函数</td><td>大功能 + 具体功能</td><td>memAlloc</td></tr><tr><td>成员函数</td><td>类名字::函数名</td><td>Student::getNum</td></tr></tbody></table><h3 id="2-2-不规则代码"><a href="#2-2-不规则代码" class="headerlink" title="2.2 不规则代码"></a>2.2 不规则代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">def <span class="token function">LOBYTE</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">:</span>     <span class="token keyword">return</span> x <span class="token operator">&amp;</span> <span class="token number">0xff</span>def <span class="token function">HIBYTE</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">:</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span>def <span class="token function">LOWORD</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">:</span>     <span class="token keyword">return</span> x <span class="token operator">&amp;</span> <span class="token number">0xffff</span>def <span class="token function">HIWORD</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">:</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xffff</span>def <span class="token function">LODWORD</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">:</span>    <span class="token keyword">return</span> x <span class="token operator">&amp;</span> <span class="token number">0xffffffff</span>def <span class="token function">HIDWORD</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">:</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xffffffff</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-修复函数原型"><a href="#2-3-修复函数原型" class="headerlink" title="2.3 修复函数原型"></a>2.3 修复函数原型</h3><h4 id="2-3-1-返回值类型"><a href="#2-3-1-返回值类型" class="headerlink" title="2.3.1 返回值类型"></a>2.3.1 返回值类型</h4><p>​当分析出某个函数的返回值类型始终（交叉引用）不会被使用后，可以将函数原型的返回值类型改成void，可以优化掉多余代码。</p><h4 id="2-3-2-参数个数和类型"><a href="#2-3-2-参数个数和类型" class="headerlink" title="2.3.2 参数个数和类型"></a>2.3.2 参数个数和类型</h4><p>​在x64下，有些函数没有参数，但由于调用约定，F5后的伪代码中可能出现参数，将多余的参数删除，可以优化代码。而且有些参数是使用寄存器传递，如浮点寄存器，这时伪代码中可能无法正确识别，需要结合汇编分析，并手动添加参数，可以增加可读性。</p><h3 id="2-4-修复变量类型"><a href="#2-4-修复变量类型" class="headerlink" title="2.4 修复变量类型"></a>2.4 修复变量类型</h3><h4 id="2-4-1-结构体定义"><a href="#2-4-1-结构体定义" class="headerlink" title="2.4.1 结构体定义"></a>2.4.1 结构体定义</h4><p>​恢复结构体类型可以大大代码可读性，可以根据new的大小和分析成员使用情况来确定结构体边界和成员类型。下面展示类的结构定义模板：</p><p><img src="/2022/09/13/ida-basic/image-20220913182821578.png" alt="类结构模板"></p><h4 id="2-4-2-数组定义"><a href="#2-4-2-数组定义" class="headerlink" title="2.4.2 数组定义"></a>2.4.2 数组定义</h4><p>​对于连续的内存空间的操作，可以酌情还原为数组，增加可读性。</p><h2 id="3-符号还原"><a href="#3-符号还原" class="headerlink" title="3.符号还原"></a>3.符号还原</h2>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> ida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Assembly Basic</title>
      <link href="/2022/09/12/asm-basic/"/>
      <url>/2022/09/12/asm-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="1-EFLAGS"><a href="#1-EFLAGS" class="headerlink" title="1.EFLAGS"></a>1.EFLAGS</h2><p><img src="/2022/09/12/asm-basic/eflags.png" alt="eflags"></p><h2 id="2-测试与比较"><a href="#2-测试与比较" class="headerlink" title="2.测试与比较"></a>2.测试与比较</h2><h3 id="2-1-test"><a href="#2-1-test" class="headerlink" title="2.1 test"></a>2.1 test</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">test rax, rbx; 等价形式如下push raxand rax, rbxpop rax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-cmp"><a href="#2-2-cmp" class="headerlink" title="2.2 cmp"></a>2.2 cmp</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">cmp rax, rbx; 等价形式如下push raxsub rax, rbxpop rax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-跳转"><a href="#3-跳转" class="headerlink" title="3.跳转"></a>3.跳转</h2><h3 id="3-1-JCC条件跳转"><a href="#3-1-JCC条件跳转" class="headerlink" title="3.1 JCC条件跳转"></a>3.1 JCC条件跳转</h3><ul><li><strong>短跳：</strong>2字节，1字节硬编码 + 1字节有符号偏移</li><li><strong>长跳：</strong>6字节，2字节硬编码 + 4字节有符号地址</li></ul><table><thead><tr><th>指令</th><th>短跳</th><th>长跳</th><th>含义</th><th>EFLAGS</th></tr></thead><tbody><tr><td>JZ&#x2F;JE</td><td>0x74</td><td>0x0F 0x84</td><td>相等则跳转</td><td>ZF &#x3D;&#x3D; 1</td></tr><tr><td>JNZ&#x2F;JNE</td><td>0x75</td><td>0x0F 0x85</td><td>不相等则跳转</td><td>ZF &#x3D;&#x3D; 0</td></tr><tr><td>JS</td><td>0x78</td><td>0x0F 0x88</td><td>负数则跳转</td><td>SF &#x3D;&#x3D; 1</td></tr><tr><td>JNS</td><td>0x79</td><td>0x0F 0x89</td><td>正数则跳转</td><td>SF &#x3D;&#x3D; 0</td></tr><tr><td>JP&#x2F;JPE</td><td>0x7A</td><td>0x0F 0x8A</td><td>1出现次数为偶数则跳转</td><td>PF &#x3D;&#x3D; 1</td></tr><tr><td>JNP&#x2F;JPO</td><td>0x7B</td><td>0x0F 0x8B</td><td>1出现次数为奇数则跳转</td><td>PF &#x3D;&#x3D; 0</td></tr><tr><td>JC&#x2F;JB&#x2F;JNAE</td><td>0x72</td><td>0x0F 0x82</td><td>无符号数 (进位)低于则跳转</td><td>CF &#x3D;&#x3D; 1</td></tr><tr><td>JNC&#x2F;JNB&#x2F;JAE</td><td>0x73</td><td>0x0F 0x83</td><td>无符号数 (不进位)高于等于则跳转</td><td>CF &#x3D;&#x3D; 0</td></tr><tr><td>JO</td><td>0x70</td><td>0x0F 0x80</td><td>有符号数 溢出则跳转</td><td>OF &#x3D;&#x3D; 1</td></tr><tr><td>JNO</td><td>0x71</td><td>0x0F 0x81</td><td>有符号数 无溢出则跳转</td><td>OF &#x3D;&#x3D; 0</td></tr><tr><td>JBE&#x2F;JNA</td><td>0x76</td><td>0x0F 0x86</td><td>无符号数 低于等于则跳转</td><td>ZF &#x3D;&#x3D; 1 || CF &#x3D;&#x3D; 1</td></tr><tr><td>JNBE&#x2F;JA</td><td>0x77</td><td>0x0F 0x87</td><td>无符号数 高于则跳转</td><td>ZF &#x3D;&#x3D; 0 || CF &#x3D;&#x3D; 0</td></tr><tr><td>JL&#x2F;JNGE</td><td>0x7C</td><td>0x0F 0x8C</td><td>有符号数 小于则跳转</td><td>SF !&#x3D; OF</td></tr><tr><td>JNL&#x2F;JGE</td><td>0x7D</td><td>0x0F 0x8D</td><td>有符号数 大于等于则跳转</td><td>SF &#x3D;&#x3D; OF</td></tr><tr><td>JLE&#x2F;JNG</td><td>0x7E</td><td>0x0F 0x8E</td><td>有符号数 小于等于则跳转</td><td>ZF !&#x3D; OF || ZF &#x3D;&#x3D; 1</td></tr><tr><td>JNLE&#x2F;JG</td><td>0x7F</td><td>0x0F 0x8F</td><td>有符号数 大于则跳转</td><td>SF &#x3D;&#x3D; 0F &amp;&amp; ZF &#x3D;&#x3D; 0</td></tr></tbody></table><h3 id="3-2-CALL无条件跳转"><a href="#3-2-CALL无条件跳转" class="headerlink" title="3.2 CALL无条件跳转"></a>3.2 CALL无条件跳转</h3><pre class="line-numbers language-none"><code class="language-none">E8 + 4字节有符号偏移：偏移CALL，最常见用法。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 4字节偏移</strong></p><pre class="line-numbers language-none"><code class="language-none">**FF 15 + 4字节：**间接CALL，长用于调用导入表中函数。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>x86：后面跟4字节内存地址。</p><p><strong>跳转目标地址 &#x3D; ptr:[ 4字节内存地址 ]</strong></p></li><li><p>x64：后面跟4字节偏移，再使用偏移计算公式得到4字节内存地址。</p></li></ul><p>​<strong>跳转目标地址 &#x3D; ptr:[ 当前指令地址 + 当前指令长度 + 4字节偏移 ]</strong></p><pre class="line-numbers language-none"><code class="language-none">9A + 4字节地址 + 目标cs：绝对CALL，仅x86有效，可以跳转到绝对地址同时改变cs的值，far常用于实现调用门。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​<strong>跳转目标地址 &#x3D; 4字节地址、cs &#x3D; 目标cs</strong></p><h3 id="3-3-JMP无条件跳转"><a href="#3-3-JMP无条件跳转" class="headerlink" title="3.3 JMP无条件跳转"></a>3.3 JMP无条件跳转</h3><pre class="line-numbers language-none"><code class="language-none">EB + 1字节有符号偏移：偏移短跳转<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​<strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 1字节偏移</strong></p><pre class="line-numbers language-none"><code class="language-none">E9 + 4字节有符号偏移：偏移近跳转<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​<strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 4字节偏移</strong></p><pre class="line-numbers language-none"><code class="language-none">FF 25 + 4字节：间接跳转<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>x86：后面跟4字节内存地址。</p><p><strong>跳转目标地址 &#x3D; ptr:[ 4字节内存地址 ]</strong></p></li><li><p>x64：后面跟4字节偏移，再使用偏移计算公式得到4字节内存地址。</p></li></ul><p>​<strong>跳转目标地址 &#x3D; ptr:[ 当前指令地址 + 当前指令长度 + 4字节偏移 ]</strong></p><pre class="line-numbers language-none"><code class="language-none">EA + 4字节地址 + 目标cs：绝对跳转，仅x86有效，可以跳转到绝对地址同时改变cs的值，far常用于实现调用门。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​<strong>跳转目标地址 &#x3D; 4字节地址、cs &#x3D; 目标cs</strong></p><h3 id="3-4-x64下的Inline-HOOK"><a href="#3-4-x64下的Inline-HOOK" class="headerlink" title="3.4 x64下的Inline HOOK"></a>3.4 x64下的Inline HOOK</h3><p>enter</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">方法1：12字节mov rax, 0x123456789jmp rax方法2：12字节mov rax, 0x123456789push raxret方法3：不破坏寄存器  13字节push raxmov rax, 0x123456789jmp rax&#96;&#96;&#96;pop rax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ret</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">方法1：20字节sub rsp, 0x8mov dword ptr ss:[rsp], 0x1234mov dword ptr ss:[rsp+0x4], 0x56789ABCret方法2：14字节push 0x12345678mov dword ptr ss:[rsp+4], 0x9ABCret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-基本运算"><a href="#4-基本运算" class="headerlink" title="4.基本运算"></a>4.基本运算</h2><h3 id="4-1-除法"><a href="#4-1-除法" class="headerlink" title="4.1 除法"></a>4.1 除法</h3><p>无符号：div + 除数</p><p>有符号：idiv + 除数，余数的符号与被除数相同。</p><table><thead><tr><th>被除数</th><th>除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td>ax</td><td>reg&#x2F;mem8</td><td>al</td><td>ah</td></tr><tr><td>dx:ax</td><td>reg&#x2F;mem16</td><td>ax</td><td>dx</td></tr><tr><td>edx:eax</td><td>reg&#x2F;mem32</td><td>eax</td><td>edx</td></tr><tr><td>rdx:rax</td><td>reg&#x2F;mem64</td><td>rax</td><td>rdx</td></tr></tbody></table><h3 id="4-2-乘法"><a href="#4-2-乘法" class="headerlink" title="4.2 乘法"></a>4.2 乘法</h3><p><strong>单操作数：</strong></p><p>​无符号：mul + 乘数</p><p>​有符号：imul + 乘数</p><table><thead><tr><th>被乘数</th><th>乘数</th><th>乘积</th></tr></thead><tbody><tr><td>al</td><td>reg&#x2F;mem8</td><td>ax</td></tr><tr><td>ax</td><td>reg&#x2F;mem16</td><td>dx:ax</td></tr><tr><td>eax</td><td>reg&#x2F;mem32</td><td>edx:eax</td></tr><tr><td>rax</td><td>reg&#x2F;mem64</td><td>rdx:rax</td></tr></tbody></table><p>对于无符号数，计算后如果dx&#x2F;edx&#x2F;rdx寄存器不为0，则CF位被置位。</p><p>对于有符号数，计算后如果dx&#x2F;edx&#x2F;rdx寄存器不为ax&#x2F;eax&#x2F;rax的符号扩展，则OF和CF位被置位。</p><p><strong>双操作数：</strong>不支持8位，必须是有符号数。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">imul reg1, reg2&#x2F;mem&#x2F;imm; 等价形式如下reg1 &#x3D; reg1 * reg2&#x2F;mem&#x2F;imm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>三操作数：</strong>不支持8位，必须是有符号数。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">imul reg1, reg2&#x2F;mem, imm; 等价形式如下reg1 &#x3D; reg2&#x2F;mem * imm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-3-移位"><a href="#4-3-移位" class="headerlink" title="4.3 移位"></a>4.3 移位</h3><p><strong>逻辑：</strong>shl、shr</p><p><strong>算数：</strong>sal、sar</p><p>逻辑左移与逻辑左移没区别，算数右移左边补符号位，逻辑右移坐标补0。右移除以2，左移乘以2。</p><h2 id="5-数据传送"><a href="#5-数据传送" class="headerlink" title="5.数据传送"></a>5.数据传送</h2><h3 id="5-1-扩展传送"><a href="#5-1-扩展传送" class="headerlink" title="5.1 扩展传送"></a>5.1 扩展传送</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movsx：符号位扩展movzx：0扩展<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-2-隐式传送"><a href="#5-2-隐式传送" class="headerlink" title="5.2 隐式传送"></a>5.2 隐式传送</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movs_b&#x2F;w&#x2F;d&#x2F;q; 等价形式如下if(DF &#x3D;&#x3D; 0); cld&#123;[edi++] &#x3D; [esi++]&#125;else; std&#123;[edi--] &#x3D; [esi--]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-字符串获取"><a href="#5-3-字符串获取" class="headerlink" title="5.3 字符串获取"></a>5.3 字符串获取</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lods_b&#x2F;w&#x2F;d&#x2F;q; 等价形式如下if(DF &#x3D;&#x3D; 0); cld&#123;eax &#x3D; [esi++]&#125;else; std&#123;eax &#x3D; [esi--]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-4-字符串加载"><a href="#5-4-字符串加载" class="headerlink" title="5.4 字符串加载"></a>5.4 字符串加载</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">stos_b&#x2F;w&#x2F;d&#x2F;q; 等价形式如下if(DF &#x3D;&#x3D; 0); cld&#123;[edi++] &#x3D; eax &#125;else; std&#123;[edi--] &#x3D; eax &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> x86/x64 asm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
