<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Crypto Basic</title>
      <link href="/2022/10/10/crypto-basic/"/>
      <url>/2022/10/10/crypto-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="1-RC4算法"><a href="#1-RC4算法" class="headerlink" title="1.RC4算法"></a>1.RC4算法</h2><h3 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h3><ul><li>对称加密</li><li>key长度1-256字节</li><li>使用KSA生成S盒，使用PRGA生成密钥流</li><li>S盒为256字节的数组</li></ul><h3 id="1-2-原理"><a href="#1-2-原理" class="headerlink" title="1.2 原理"></a>1.2 原理</h3><h4 id="1-2-1-原理图"><a href="#1-2-1-原理图" class="headerlink" title="1.2.1 原理图"></a>1.2.1 原理图</h4><p><img src="/2022/10/10/crypto-basic/image-20221010215125686.png" alt="RC4原理图"></p><h4 id="1-3-1-KSA"><a href="#1-3-1-KSA" class="headerlink" title="1.3.1 KSA"></a>1.3.1 KSA</h4><p>The key-scheduling algorithm算法，用于根据key来生成S盒。</p><p>首先初始化长度为256的数组，第一个for循环将0-255的互补重复的元素装入S盒，第二个for循环根据密钥打乱S盒，伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">from</span> <span class="hljs-number">0</span> to <span class="hljs-number">255</span><br>    S[i] := i<br>endfor<br>j := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">from</span> <span class="hljs-number">0</span> to <span class="hljs-number">255</span><br>    j := (j + S[i] + key[i mod keylength]) mod <span class="hljs-number">256</span><br>    swap values of S[i] <span class="hljs-keyword">and</span> S[j]<br>endfor<br></code></pre></td></tr></table></figure><h4 id="1-3-2-PRGA"><a href="#1-3-2-PRGA" class="headerlink" title="1.3.2 PRGA"></a>1.3.2 PRGA</h4><p>The pseudo-random generation algorithm算法，用于根据S盒生成与明文长度相同的密钥流，使用密钥加密明文，伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">i := <span class="hljs-number">0</span><br>j := <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> GeneratingOutput:<br>    i := (i + <span class="hljs-number">1</span>) mod <span class="hljs-number">256</span><br>    j := (j + S[i]) mod <span class="hljs-number">256</span><br>    swap values of S[i] <span class="hljs-keyword">and</span> S[j]<br>    K := S[(S[i] + S[j]) mod <span class="hljs-number">256</span>]<br>    output K<br>endwhile<br></code></pre></td></tr></table></figure><p>其中3行是以明文长度范围内的循环，4、5行用于定位S盒中的元素，6行在不断的交换S盒的元素，7行在生成密钥流。示意图如下：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/RC4.svg/1920px-RC4.svg.png" alt="密钥生成示意图"></p><h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><h4 id="1-3-1-KSA实现"><a href="#1-3-1-KSA实现" class="headerlink" title="1.3.1 KSA实现"></a>1.3.1 KSA实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">KSA</span><span class="hljs-params">(<span class="hljs-type">char</span>* key, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* s_box)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(s_box, <span class="hljs-number">0</span>, <span class="hljs-number">256</span>);<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<br>s_box[i] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<br>&#123;<br>j = (j + s_box[i] + key[i % <span class="hljs-built_in">strlen</span>(key)]) % <span class="hljs-number">256</span>;<br><span class="hljs-built_in">swap</span>(&amp;s_box[i], &amp;s_box[j]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-2-PRGA实现"><a href="#1-3-2-PRGA实现" class="headerlink" title="1.3.2 PRGA实现"></a>1.3.2 PRGA实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PRGA</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* s_box, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* data, <span class="hljs-type">int</span> data_size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (data_size)<br>&#123;<br>i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>;<br>j = (j + s_box[i]) % <span class="hljs-number">256</span>;<br><span class="hljs-built_in">swap</span>(&amp;s_box[i], &amp;s_box[j]);<br>data[index] = s_box[(s_box[i] + s_box[j]) % <span class="hljs-number">256</span>];<br>index++;<br>data_size--;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-3-异或加密"><a href="#1-3-3-异或加密" class="headerlink" title="1.3.3 异或加密"></a>1.3.3 异或加密</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(<span class="hljs-type">char</span>* key, <span class="hljs-type">char</span>* data)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> s_box[<span class="hljs-number">256</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">KSA</span>(key, s_box);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* key_stream = <span class="hljs-keyword">new</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(data)];<br><span class="hljs-keyword">if</span> (!key_stream) <br><span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">PRGA</span>(s_box, key_stream, <span class="hljs-built_in">strlen</span>(data));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(data); i++)<br>&#123;<br>data[i] ^= key_stream[i];<br>&#125;<br><span class="hljs-keyword">if</span> (key_stream)<br>&#123;<br><span class="hljs-keyword">delete</span>[] key_stream;<br>key_stream = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-4-运行结果"><a href="#1-3-4-运行结果" class="headerlink" title="1.3.4 运行结果"></a>1.3.4 运行结果</h4><p><img src="/2022/10/10/crypto-basic/image-20221010224018062.png" alt="rc4运行结果"></p><h3 id="1-4-逆向特征"><a href="#1-4-逆向特征" class="headerlink" title="1.4 逆向特征"></a>1.4 逆向特征</h3><p>初始化256字节的数组，以及打乱数组元素，可以认为是产生s_box的KSA函数。如下图所示：</p><p><img src="/2022/10/10/crypto-basic/image-20221010224643119.png" alt="rc4_KSA函数"></p><p>定位到s_box再定位PRGA函数会容易的多，如下图所示：</p><p><img src="/2022/10/10/crypto-basic/image-20221010225103811.png" alt="rc4_PRGA函数"></p><p>加密函数如下：</p><p><img src="/2022/10/10/crypto-basic/image-20221010225302532.png" alt="rc4_encode"></p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Malware Analysis Qakbot分析</title>
      <link href="/2022/10/07/malware-analysis-qakbot-fen-xi/"/>
      <url>/2022/10/07/malware-analysis-qakbot-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="0-分析目标"><a href="#0-分析目标" class="headerlink" title="0.分析目标"></a>0.分析目标</h2><ul><li>恶意程序是否加壳？如果是，是常见的壳还是自写壳？</li><li>恶意程序使用什么网络通信手段？Winsock2、Wininet、COM、WSK甚至是自己实现的？</li><li>是否存在注入或者HOOK技术？如果存在，是什么？</li><li>是否存在对抗？反调试、反静态分析、反虚拟机？</li><li>是否存在API&#x2F;DLL被加密？</li><li>是否存在字符串加密或混淆？</li><li>恶意程序使用了什么同步原语？</li><li>恶意程序使用了什么加密算法？</li><li>恶意程序使用了什么持久化手段？</li><li>是否存在ShellCode被注入进系统进程？</li><li>是否存在文件过滤驱动被安装？</li><li>如果安装了驱动，是否存在回调或者定时器？</li></ul><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>BAZAAR 报告：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009101253136.png" alt="BAZARR 数据库报告"></p><p>TRIAGE报告：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009102005149.png" alt="TRIAGE报告1"></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009102123632.png" alt="TRIAGE报告2"></p><p>沙箱报告：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009102209063.png" alt="沙箱报告"></p><p>DIE检测：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009102320523.png" alt="DIE检测"></p><p>PE信息：</p><p>导入表信息</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009103502909.png" alt="导入表信息1"></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009103544072.png" alt="导入表信息2"></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009103721047.png" alt="导入表信息3"></p><p>节表信息</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009103808029.png" alt="节表信息"></p><p>导出表信息</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009104114082.png" alt="导出表信息"></p><p><strong>总结：</strong></p><ul><li>样本来自qakbot家族，属于obama150僵尸网络。</li><li>有遍历进程以及读写其他进程的API被调用，可能存在注入。</li><li>可能是使用计划任务作为持久化。</li><li>可能将自己释放到temp目录下。</li><li>注入的目标进程可能是explorer.exe。</li><li>程序是由Borland Delphi编写的32位DLL。</li><li>导入表中未出现网络相关的API，可能被动态解析或者是加壳了。</li><li>存在不寻常的节区名。</li><li>存在一个导出函数，可以被用于动态调试。</li></ul><h2 id="2-脱壳"><a href="#2-脱壳" class="headerlink" title="2.脱壳"></a>2.脱壳</h2><p>调试参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;C:\Windows\SysWOW64\rundll32.exe&quot;</span> C:\Users\mas\Desktop\mal_lab\test2\mas_2.bin,<span class="hljs-comment">#1</span><br></code></pre></td></tr></table></figure><p>eip指向oep时，在如下API设置断点：</p><ul><li>VirtualAlloc( )ret 0x10&#x2F;&#x2F; 检测自注入</li><li>WriteProcessMemory( )                                    &#x2F;&#x2F; 根据上述信息，可能存在进程注入</li><li>NtResumeThread( )                                           &#x2F;&#x2F; 为了避免失去控制权</li></ul><p>设置好断点后，F9运行，每次断在VirtualAlloc返回位置时，将eax的值放入内存窗口中，按下F9观察内存中的内容。遇见异常按Shift + F9忽略继续执行。直到ResumeThread被断下时，此时会得到两个PE文件，如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009111509538.png" alt="PE1"></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009111612289.png" alt="PE2"></p><p>第一个PE文件的节名异常，可能还没有脱完，将第二个PE所在的内存区域保存到文件rundll32_02900000.bin。</p><p>Trige报告中显示，可能存在注入，动态跟一下，在以下API设置断点：（这里没设置MapViewOfSection断点的原因是经过测试，断不下，API被重写了）</p><ul><li>CreateProcessW( )</li><li>ResumeThread( )</li></ul><p>重新运行，断点断在CreateProcessW()，创建msra.exe系统进程。</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009172558899.png" alt="CreateProcessW()"></p><p>执行到这里直接在ZwMapViewOfSection( )下断断不到想要的结果，这里采用动态跟踪的方式，向下追踪代码，可以得到如下调用ZwMapViewOfSection的方式：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009173724496.png" alt="调用ZwMapViewOfSectiond"></p><p>这里有个对抗技巧，根据eax + 0x14得到的地址根本不在ntdll中，而是在它释放的一个随即名dll中，相当于ntdll中的api被重写了一遍。</p><p>可以看见重写api列表如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009173933234.png" alt="重写的api列表"></p><p>函数地址来自a0f1f0bb.dll模块的.text段，这个模块就是上面得到那个第一个pe文件。</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009174108804.png" alt="a0f1f0bb.dll"></p><p>步过这个函数，可以看见msra.exe被挂起创建，并且多了一个132kb的可执行共享内存，如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009174352387.png" alt="msra.exe"></p><p>映射内存可以直接由memcpy进行读写，这里不去追踪了，直接F9放行，断到ResumeThread( )函数位置：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009181025580.png" alt="ResumeThread"></p><p>此时使用ProcessHacker将即将执行的镜像内存dump下来，可以得知与之前dump文件是同一个pe的两种状态，如图所示：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009181413343.png" alt="010对比"></p><p><strong>手动修复PE：</strong></p><ul><li>将所有节表项的ra用va替换</li><li>计算相邻节表项之间的offset，用作rs和vs</li><li>将ImageBase修改为内存dump的起始位置</li></ul><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010101332082.png" alt="手动修复后"></p><p><strong>工具修复PE：</strong></p><p>使用pe_unmapper修复一下内存中的dump，将其转换成未映射状态：</p><p><a href="https://github.com/hasherezade/libpeconv/tree/master/pe_unmapper">libpeconv&#x2F;pe_unmapper at master · hasherezade&#x2F;libpeconv (github.com)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// pe_unmapper.exe /in 输入文件 /base 映射基址 /out 输出文件<br>pe_unmapper.exe /in msra.exe_0x450000-0x21000.bin /base 00450000 /out msra.exe_0x450000-0x21000_fixed.bin<br></code></pre></td></tr></table></figure><p>转换后的pe文件导入表可以正常解析：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221009183033236.png" alt="查看导入表"></p><h2 id="3-逆向"><a href="#3-逆向" class="headerlink" title="3.逆向"></a>3.逆向</h2><h3 id="3-0-IDA技巧"><a href="#3-0-IDA技巧" class="headerlink" title="3.0 IDA技巧"></a>3.0 IDA技巧</h3><ul><li>Ctrl + F5 反编译整个文件</li><li>Shift + F11 检查 mssdk_win7、ntapi_win7、ntddk_win7 是否存在，如果不存在，按INS添加。将vc32rtf添加到Shift + F5，分析驱动使用win10的库</li><li>运行 Flare Capa Explorer 和 FindCrypt 插件来收集信息</li></ul><h3 id="3-1-自动化处理加密的字符串"><a href="#3-1-自动化处理加密的字符串" class="headerlink" title="3.1 自动化处理加密的字符串"></a>3.1 自动化处理加密的字符串</h3><h4 id="3-1-1-Python脚本模拟算法"><a href="#3-1-1-Python脚本模拟算法" class="headerlink" title="3.1.1 Python脚本模拟算法"></a>3.1.1 Python脚本模拟算法</h4><p>DllEntry向下不远处，会看到两个算法函数，如图所示：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221011200241194.png" alt="DllEntry入口"></p><p>decode_string_table函数实现如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221011200114085.png" alt="decode_string_table"></p><p>参数列表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">j_decode_string_table</span>(加密字符串表长度, 全局加密字符串表，全局解密key，未使用，字符串表索引)<br></code></pre></td></tr></table></figure><p>j_decode_string_table函数实现如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221011200133636.png" alt="j_decode_string_table"></p><p>该函数会根据传入的索引来解密相应的字符串，并申请堆内存来保存结果，返回堆内存指针。</p><p>经过测试，decode_string_table_2函数与decode_string_table功能一致，只不过block和key的地址变换了。</p><p><strong>编写Python脚本模拟算法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydoc <span class="hljs-keyword">import</span> doc<br><span class="hljs-keyword">import</span> pefile<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypter</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, data_string, data_key</span>):<br>    size = <span class="hljs-number">3660</span><br>    index = <span class="hljs-built_in">id</span><br>    index2 = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">id</span> &lt; size ):<br>        flag = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span>(data_key[index % <span class="hljs-number">0x5A</span>] == data_string[index]):<br>                <span class="hljs-keyword">break</span><br>            index += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>(index &gt;= size):<br>                flag = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">False</span>):<br>            index2 = index - <span class="hljs-built_in">id</span><br><br>    decopded_buf = <span class="hljs-string">&#x27;&#x27;</span><br>    index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span>(index2 != <span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            decopded_buf += <span class="hljs-built_in">chr</span>((data_string[<span class="hljs-built_in">id</span>]) ^ (data_key[<span class="hljs-built_in">id</span> % <span class="hljs-number">0x5A</span>]))<br>            <span class="hljs-built_in">id</span> += <span class="hljs-number">1</span><br>            index += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>(index &gt;= index2):<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> decopded_buf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_data</span>(<span class="hljs-params">filepath</span>):<br>    pe = pefile.PE(filepath)<br>    <span class="hljs-keyword">for</span> section <span class="hljs-keyword">in</span> pe.sections:<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;.data&#x27;</span> <span class="hljs-keyword">in</span> section.Name.decode(encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span>).rstrip(<span class="hljs-string">&#x27;x00&#x27;</span>):<br>                <span class="hljs-keyword">return</span> (section.get_data(section.VirtualAddress, section.SizeOfRawData))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc_offsets</span>(<span class="hljs-params">s_seg_start, x_start</span>):<br>    data_offset = <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">int</span>(x_start, <span class="hljs-number">16</span>) - <span class="hljs-built_in">int</span>(s_seg_start, <span class="hljs-number">16</span>))<br>    <span class="hljs-keyword">return</span> data_offset<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">string_decrypter</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, data_seg_start, encrypted_string_addr, key_data_addr</span>):<br>    <span class="hljs-comment"># 两个缓冲区</span><br>    data_1 = <span class="hljs-string">b&#x27;&#x27;</span><br>    data_2 = <span class="hljs-string">b&#x27;&#x27;</span><br><br>    <span class="hljs-comment"># 计算偏移</span><br>    encrypted_string_addr_rel = calc_offsets(data_seg_start, encrypted_string_addr)<br>    key_data_addr_rel = calc_offsets(data_seg_start, key_data_addr)<br><br>    <span class="hljs-comment"># 获取.data数据</span><br>    filepath = <span class="hljs-string">r&quot;C:\\Users\\yuanmingfei\\Desktop\\mas_2\\mas_2_dump.bin &quot;</span><br>    data_encoded_extracted_1 = extract_data(filepath)<br>    data_encoded_extracted_2 = extract_data(filepath)<br><br>    <span class="hljs-comment"># 计算data和key的终止偏移</span><br>    d1_off = <span class="hljs-number">0x0</span><br>    d2_off = <span class="hljs-number">0x0</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">b&#x27;\x00\x00&#x27;</span> <span class="hljs-keyword">in</span> data_encoded_extracted_1[<span class="hljs-built_in">int</span>(encrypted_string_addr_rel, <span class="hljs-number">16</span>): ]):<br>        d1_off = (data_encoded_extracted_1[<span class="hljs-built_in">int</span>(encrypted_string_addr_rel, <span class="hljs-number">16</span>): ]).index(<span class="hljs-string">b&#x27;\x00\x00&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">b&#x27;\x00\x00&#x27;</span> <span class="hljs-keyword">in</span> data_encoded_extracted_2[<span class="hljs-built_in">int</span>(key_data_addr_rel, <span class="hljs-number">16</span>): ]):<br>        d2_off = (data_encoded_extracted_2[<span class="hljs-built_in">int</span>(key_data_addr_rel, <span class="hljs-number">16</span>): ]).index(<span class="hljs-string">b&#x27;\x00\x00&#x27;</span>)<br><br>    <span class="hljs-comment"># 提取data和key</span><br>    data_1 = data_encoded_extracted_1[<span class="hljs-built_in">int</span>(encrypted_string_addr_rel, <span class="hljs-number">16</span>): <span class="hljs-built_in">int</span>(encrypted_string_addr_rel, <span class="hljs-number">16</span>) + d1_off]<br>    data_2 = data_encoded_extracted_2[<span class="hljs-built_in">int</span>(key_data_addr_rel, <span class="hljs-number">16</span>): <span class="hljs-built_in">int</span>(key_data_addr_rel, <span class="hljs-number">16</span>) + d2_off]<br><br>    <span class="hljs-comment"># 解密数据</span><br>    <span class="hljs-built_in">print</span>(decrypter(<span class="hljs-built_in">id</span>, data_1, data_2))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    string_decrypter(<span class="hljs-number">708</span>, <span class="hljs-string">&#x27;0x1001D000&#x27;</span>, <span class="hljs-string">&#x27;0x1001D0B0&#x27;</span>, <span class="hljs-string">&#x27;0x1001D050&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h4 id="3-1-2-编写IDA脚本实现自动注释"><a href="#3-1-2-编写IDA脚本实现自动注释" class="headerlink" title="3.1.2 编写IDA脚本实现自动注释"></a>3.1.2 编写IDA脚本实现自动注释</h4><p>交叉引用后发现，大量位置使用该函数来解密字符串，编写IDA脚本实现自动对引用位置添加注释：</p><p>经过查看参数传递，发现大多数情况index均使用ecx以及push指令传参，并在距离call指令1-2个指令处，脚本遍历解密函数的全部交叉引用，并提取指令中的立即数作为index来解密字符串，再对当前位置添加注释。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydoc <span class="hljs-keyword">import</span> doc<br><span class="hljs-keyword">import</span> pefile<br><span class="hljs-keyword">import</span> idaapi<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> binascii<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypter</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, data_string, data_key</span>):<br>    size = <span class="hljs-number">3660</span><br>    index = <span class="hljs-built_in">id</span><br>    index2 = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">id</span> &lt; size ):<br>        flag = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span>(data_key[index % <span class="hljs-number">0x5A</span>] == data_string[index]):<br>                <span class="hljs-keyword">break</span><br>            index += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>(index &gt;= size):<br>                flag = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">False</span>):<br>            index2 = index - <span class="hljs-built_in">id</span><br><br>    decopded_buf = <span class="hljs-string">&#x27;&#x27;</span><br>    index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span>(index2 != <span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            decopded_buf += <span class="hljs-built_in">chr</span>((data_string[<span class="hljs-built_in">id</span>]) ^ (data_key[<span class="hljs-built_in">id</span> % <span class="hljs-number">0x5A</span>]))<br>            <span class="hljs-built_in">id</span> += <span class="hljs-number">1</span><br>            index += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>(index &gt;= index2):<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> decopded_buf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_data</span>(<span class="hljs-params">filepath</span>):<br>    pe = pefile.PE(filepath)<br>    <span class="hljs-keyword">for</span> section <span class="hljs-keyword">in</span> pe.sections:<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;.data&#x27;</span> <span class="hljs-keyword">in</span> section.Name.decode(encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span>).rstrip(<span class="hljs-string">&#x27;x00&#x27;</span>):<br>                <span class="hljs-keyword">return</span> (section.get_data(section.VirtualAddress, section.SizeOfRawData))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc_offsets</span>(<span class="hljs-params">s_seg_start, x_start</span>):<br>    data_offset = <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">int</span>(x_start, <span class="hljs-number">16</span>) - <span class="hljs-built_in">int</span>(s_seg_start, <span class="hljs-number">16</span>))<br>    <span class="hljs-keyword">return</span> data_offset<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">string_decrypter</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, encrypted_string_addr, key_data_addr</span>):<br>    <span class="hljs-comment"># 两个缓冲区</span><br>    data_1 = <span class="hljs-string">b&#x27;&#x27;</span><br>    data_2 = <span class="hljs-string">b&#x27;&#x27;</span><br><br>    encrypted_string_addr_ref = <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">int</span>(encrypted_string_addr))<br>    key_data_addr_ref = <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">int</span>(key_data_addr))<br><br>    <span class="hljs-comment"># 获取.data地址</span><br>    <span class="hljs-keyword">for</span> segment <span class="hljs-keyword">in</span> idautils.Segments():<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;.data&#x27;</span> == idc.get_segm_name(segment):<br>            data_seg_start = <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">int</span>(idc.get_segm_start(segment)))<br><br>    <span class="hljs-comment"># 计算偏移</span><br>    encrypted_string_addr_rel = calc_offsets(data_seg_start, encrypted_string_addr_ref)<br>    key_data_addr_rel = calc_offsets(data_seg_start, key_data_addr_ref)<br><br>    <span class="hljs-comment"># 获取.data数据</span><br>    filepath = <span class="hljs-string">r&quot;C:\\Users\\yuanmingfei\\Desktop\\mas_2\\mas_2_dump.bin&quot;</span><br>    data_encoded_extracted_1 = extract_data(filepath)<br>    data_encoded_extracted_2 = extract_data(filepath)<br><br>    <span class="hljs-comment"># 计算data和key的终止偏移</span><br>    d1_off = <span class="hljs-number">0x0</span><br>    d2_off = <span class="hljs-number">0x0</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">b&#x27;\x00\x00&#x27;</span> <span class="hljs-keyword">in</span> data_encoded_extracted_1[<span class="hljs-built_in">int</span>(encrypted_string_addr_rel, <span class="hljs-number">16</span>): ]):<br>        d1_off = (data_encoded_extracted_1[<span class="hljs-built_in">int</span>(encrypted_string_addr_rel, <span class="hljs-number">16</span>): ]).index(<span class="hljs-string">b&#x27;\x00\x00&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">b&#x27;\x00\x00&#x27;</span> <span class="hljs-keyword">in</span> data_encoded_extracted_2[<span class="hljs-built_in">int</span>(key_data_addr_rel, <span class="hljs-number">16</span>): ]):<br>        d2_off = (data_encoded_extracted_2[<span class="hljs-built_in">int</span>(key_data_addr_rel, <span class="hljs-number">16</span>): ]).index(<span class="hljs-string">b&#x27;\x00\x00&#x27;</span>)<br><br>    <span class="hljs-comment"># 提取data和key</span><br>    data_1 = data_encoded_extracted_1[<span class="hljs-built_in">int</span>(encrypted_string_addr_rel, <span class="hljs-number">16</span>): <span class="hljs-built_in">int</span>(encrypted_string_addr_rel, <span class="hljs-number">16</span>) + d1_off]<br>    data_2 = data_encoded_extracted_2[<span class="hljs-built_in">int</span>(key_data_addr_rel, <span class="hljs-number">16</span>): <span class="hljs-built_in">int</span>(key_data_addr_rel, <span class="hljs-number">16</span>) + d2_off]<br><br>    <span class="hljs-comment"># 解密数据</span><br>    decryped = decrypter(<span class="hljs-built_in">id</span>, data_1, data_2)<br><br>    <span class="hljs-comment"># 拼接注释</span><br>    comment = (<span class="hljs-string">&quot;string[%d]: %s&quot;</span> % (<span class="hljs-built_in">id</span>, decryped))<br><br>    <span class="hljs-keyword">return</span> comment<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_decompiler_comments</span>(<span class="hljs-params">addr, comment</span>):<br>    c_function = idaapi.decompile(addr)<br>    treeloc_struct = idaapi.treeloc_t()<br>    treeloc_struct.ea = addr<br>    treeloc_struct.itp = idaapi.ITP_SEMI<br>    <span class="hljs-keyword">if</span> c_function:<br>        c_function.set_user_cmt(treeloc_struct, comment)<br>        c_function.save_user_cmts()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">comment_string_offset</span>(<span class="hljs-params">encrypted_string_addr, key_data_addr, fun_offset</span>):<br>    <span class="hljs-comment"># 获取线性地址</span><br>    str_function = idc.get_name_ea_simple(fun_offset)<br>    <span class="hljs-comment"># 遍历函数交叉引用</span><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> idautils.CodeRefsTo(str_function, <span class="hljs-number">0</span>):<br>        <span class="hljs-comment"># 获取前一条指令地址</span><br>        p = idc.prev_head(k)<br>        <span class="hljs-comment"># 获取地址处的反汇编</span><br>        my = idc.print_insn_mnem(p)<br>        <span class="hljs-keyword">if</span> my <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;mov&#x27;</span>, <span class="hljs-string">&#x27;push&#x27;</span>):<br>            <span class="hljs-keyword">if</span> my == <span class="hljs-string">&#x27;mov&#x27;</span>:<br>                <span class="hljs-comment"># 判断汇编操作数类型</span><br>                <span class="hljs-keyword">if</span> idc.get_operand_type(p, <span class="hljs-number">1</span>) == <span class="hljs-number">5</span>:<br>                    <span class="hljs-comment"># 获取操作数</span><br>                    str_off = <span class="hljs-built_in">int</span>(idc.print_operand(p, <span class="hljs-number">1</span>)[:-<span class="hljs-number">1</span>], <span class="hljs-number">16</span>)<br>                    comment_string = string_decrypter(str_off, encrypted_string_addr, key_data_addr)<br>                    <span class="hljs-comment"># 添加注释</span><br>                    idc.set_cmt(k, comment_string, <span class="hljs-number">0</span>)<br>                    make_decompiler_comments(k, comment_string)<br>            <span class="hljs-keyword">if</span> my == <span class="hljs-string">&#x27;push&#x27;</span>:<br>                <span class="hljs-keyword">if</span> idc.get_operand_type(p, <span class="hljs-number">0</span>) == <span class="hljs-number">5</span>:<br>                    str_off = <span class="hljs-built_in">int</span>(idc.print_operand(p, <span class="hljs-number">0</span>)[:-<span class="hljs-number">1</span>], <span class="hljs-number">16</span>)<br>                    comment_string = string_decrypter(str_off, encrypted_string_addr, key_data_addr)<br>                    idc.set_cmt(k, comment_string, <span class="hljs-number">0</span>)<br>                    make_decompiler_comments(k, comment_string)<br>            <span class="hljs-keyword">else</span>:<br>                j = idc.prev_head(p)<br>                my2 = idc.print_insn_mnem(j)<br>                <span class="hljs-keyword">if</span> my2 <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;mov&#x27;</span>, <span class="hljs-string">&#x27;push&#x27;</span>):<br>                    <span class="hljs-keyword">if</span> my2 == <span class="hljs-string">&#x27;mov&#x27;</span>:<br>                        <span class="hljs-keyword">if</span> idc.get_operand_type(j, <span class="hljs-number">1</span>) == <span class="hljs-number">5</span>:<br>                            str_off = <span class="hljs-built_in">int</span>(idc.print_operand(j, <span class="hljs-number">1</span>)[:-<span class="hljs-number">1</span>], <span class="hljs-number">16</span>)<br>                            comment_string = string_decrypter(str_off, encrypted_string_addr, key_data_addr)<br>                            idc.set_cmt(k, comment_string, <span class="hljs-number">0</span>)<br>                            make_decompiler_comments(k, comment_string)<br>                    <span class="hljs-keyword">if</span> my2 == <span class="hljs-string">&#x27;push&#x27;</span>:<br>                        <span class="hljs-keyword">if</span> idc.get_operand_type(j, <span class="hljs-number">0</span>) == <span class="hljs-number">5</span>:<br>                            str_off = <span class="hljs-built_in">int</span>(idc.print_operand(j, <span class="hljs-number">0</span>)[:-<span class="hljs-number">1</span>], <span class="hljs-number">16</span>)<br>                            comment_string = string_decrypter(str_off, encrypted_string_addr, key_data_addr)<br>                            idc.set_cmt(k, comment_string, <span class="hljs-number">0</span>)<br>                            make_decompiler_comments(k, comment_string)<br><br><br>comment_string_offset(<span class="hljs-number">0x1001D5A8</span>, <span class="hljs-number">0x1001E3F8</span>, <span class="hljs-string">&quot;decode_string_table_1_1&quot;</span>)<br>comment_string_offset(<span class="hljs-number">0x1001D5A8</span>, <span class="hljs-number">0x1001E3F8</span>, <span class="hljs-string">&quot;decode_string_table_1_2&quot;</span>)<br>comment_string_offset(<span class="hljs-number">0x1001D0B0</span>, <span class="hljs-number">0x1001D050</span>, <span class="hljs-string">&quot;decode_string_table_2_1&quot;</span>)<br>comment_string_offset(<span class="hljs-number">0x1001D0B0</span>, <span class="hljs-number">0x1001D050</span>, <span class="hljs-string">&quot;decode_string_table_2_2&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done!&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>执行结果如下：</strong></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221011222115285.png" alt="自动注释脚本"></p><p>只有少部分使用寄存器间接传参的，其他的情况均可正常解析。</p><p><strong>使用到的ida_api如下：</strong></p><p><a href="https://www.hex-rays.com/products/ida/support/idapython_docs/ida_idaapi.html#ida_idaapi">ida_idaapi API documentation (hex-rays.com)</a></p><p><a href="https://hex-rays.com/products/ida/support/idapython_docs/idautils.html">idautils API documentation (hex-rays.com)</a></p><p><a href="https://hex-rays.com/products/ida/support/idapython_docs/idc.html">idc API documentation (hex-rays.com)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 头文件</span><br><span class="hljs-keyword">import</span> idaapi<br><span class="hljs-keyword">import</span> idautils<br><br><span class="hljs-comment"># 遍历节表</span><br><span class="hljs-keyword">for</span> segment <span class="hljs-keyword">in</span> idautils.Segments():<br>    <span class="hljs-comment"># 过滤节名字</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;.data&#x27;</span> == idc.get_segm_name(segment):<br>            <span class="hljs-comment"># 获取节首地址</span><br>            data_seg_start = <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">int</span>(idc.get_segm_start(segment)))<br>            <br><span class="hljs-comment"># 根据函数名获取函数地址</span><br>idc.get_name_ea_simple(func_name)<br><br><span class="hljs-comment"># 得到某个地址的交叉引用地址列表</span><br>idautils.CodeRefsTo(addr, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 获取指定地址指令的上一条指令地址</span><br>idc.prev_head(addr)<br><br><span class="hljs-comment"># 获取地址处指令Opcode</span><br>idc.print_insn_mnem(addr)<br><br><span class="hljs-comment"># 获取地址处指令操作数（0: 操作数1；1：操作数2)</span><br>idc.get_operand_type(addr, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 打印地址处的指令操作数（0: 操作数1；1：操作数2)</span><br>idc.print_operand(addr, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 指定地址添加注释</span><br>idc.set_cmt(addr, comment, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 伪代码指定地址的函数中添加注释</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_decompiler_comments</span>(<span class="hljs-params">addr, comment</span>):<br>    c_function = idaapi.decompile(addr)<br>    treeloc_struct = idaapi.treeloc_t()<br>    treeloc_struct.ea = addr<br>    treeloc_struct.itp = idaapi.ITP_SEMI<br>    <span class="hljs-keyword">if</span> c_function:<br>        c_function.set_user_cmt(treeloc_struct, comment)<br>        c_function.save_user_cmts()<br></code></pre></td></tr></table></figure><h3 id="3-2-处理动态解析API"><a href="#3-2-处理动态解析API" class="headerlink" title="3.2 处理动态解析API"></a>3.2 处理动态解析API</h3><h4 id="3-2-1-整体逻辑分析"><a href="#3-2-1-整体逻辑分析" class="headerlink" title="3.2.1 整体逻辑分析"></a>3.2.1 整体逻辑分析</h4><p>字符串解密函数不远处的sub_1000E369函数就是用来解析API的，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012102055748.png" alt="解析API"></p><p>pe文件可能包括导入dll，这个函数根据字符串解密结果来解析指定dll，并在堆中构建新的IAT表，将地址返回。</p><p><strong>整个解析过程如下图所示：</strong></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012103602891.png" alt="API动态解析逻辑图"></p><h4 id="3-2-2-hash化函数名还原"><a href="#3-2-2-hash化函数名还原" class="headerlink" title="3.2.2 hash化函数名还原"></a>3.2.2 hash化函数名还原</h4><p>经过分析，样本中有一块全局数据区，存放的是所有经过hash化的导入函数名，每个hash串长度为4字节，hash算法为crc32，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012101424916.png" alt="crc32"></p><p>hash使用的key为0x218FE95B，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012101523270.png" alt="hash_key">其中的0x218FE95B为hash算法用到的xor key，使用Hash DB插件来自动化解析hash数据，首先在插件中设置xor key，如下图所示：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010154215406.png" alt="插件设置xor_key"></p><p>将参数的data转变成如下格式：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010154621260.png" alt="hash_data"></p><p>对着4字节hash串，右键使用Hash DB来判断算法，如图所示：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010154745559.png" alt="Hash DB判断算法"></p><p>选择算法后，再对这个hash串右键使用Hash DB的Lookup功能来解析，之后对连续的hash串使用Hash DB的Scan IAT即可，Hash DB会自动创建枚举类型，手动将名称全部恢复，如下图所示：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010155527787.png" alt="恢复hash名称"></p><p>对着ma_decode_api函数按 ‘X’ 查看交叉引用，将其他位置的hash名称也恢复出来。</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010155709309.png" alt="ma_decode_api交叉引用"></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010160843541.png" alt="hash函数名全部恢复"></p><h4 id="3-2-3-PE遍历导出表"><a href="#3-2-3-PE遍历导出表" class="headerlink" title="3.2.3 PE遍历导出表"></a>3.2.3 PE遍历导出表</h4><p>首先是初始化PE相关的表指针，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012104341676.png" alt="初始化PE指针"></p><p><strong>PE相关的IDA内置结构如下：</strong></p><p><a href="http://www.sunshine2k.de/reversing/tuts/tut_pe.htm">Sunshine’s Homepage - PE file format (sunshine2k.de)</a></p><ul><li><strong>_IMAGE_DOS_HEADER</strong></li><li><strong>_IMAGE_NT_HEADERS</strong></li><li><strong>_IMAGE_DATA_DIRECTORY</strong></li><li><strong>_IMAGE_EXPORT_DIRECTORY</strong></li><li><strong>_IMAGE_OPTIONAL_HEADER</strong></li><li><strong>_IMAGE_SECTION_HEADER</strong></li><li><strong>_IMAGE_IMPORT_DESCRIPTOR</strong></li></ul><p>遍历导出名字表，计算并比对hash，将得到的索引用来解析导出表三层结构获取导出函数地址，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012104505805.png" alt="遍历导出名字表"></p><p>根据导出函数地址判断是否为导出转发函数，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012104722485.png" alt="判断导出转发函数"></p><p><strong>PE导出转发函数：</strong></p><p>在一些系统dll中，如Kenel32.dll中的AddVectoredExceptionHandler()函数，实际上这个函数的真正代码为ntdll中的RtlAddVectoredExceptionHandler()，如下图所示：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010170809287.png" alt="AddVectoredExceptionHandler转发"></p><p>此时Function RVA指向pe导出表的用于<strong>保存函数名字的内存区</strong>，并且数据格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">NTDLL.RtlAddVectoredExceptionHandler<br></code></pre></td></tr></table></figure><p>此时想要获取这个地址，就需要加载ntdll.dll并调用GetProcAddress来获取。</p><p>解析转发dll，加载，获取导出函数地址，代码如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012104952560.png" alt="处理转发导出函数"></p><h4 id="3-2-4-重建IAT表"><a href="#3-2-4-重建IAT表" class="headerlink" title="3.2.4 重建IAT表"></a>3.2.4 重建IAT表</h4><p>函数将获取到的所有导入函数地址，用一块堆内存来保存（重构IAT表），并将堆首地址返回给上一级，函数如下：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012105211603.png" alt="返回IAT表"></p><p>增强伪代码可读性，为之前得到的全局hash序列创建结构体，如图所示：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010172822764.png" alt="创建api结构"></p><p>并将接收指针的全局变量全部重命名，并将类型修改为指定的结构体指针，如图所示：</p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221010173543546.png" alt="全局API表命名"></p><p>此时去到全局变量引用位置，代码可读性大大提升，对比如下：</p><p><strong>修复前：</strong></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/image-20221012105838431.png" alt="解析API代码修复前"></p><p><strong>修复后：</strong></p><p><img src="/2022/10/07/malware-analysis-qakbot-fen-xi/blogs\fluid_blog\source_posts\Malware-Analysis-Qakbot分析\image-20221012105930028.png" alt="解析API代码修复后"></p><h3 id="3-3-加密算法分析"><a href="#3-3-加密算法分析" class="headerlink" title="3.3 加密算法分析"></a>3.3 加密算法分析</h3><h4 id="3-3-1-随机数"><a href="#3-3-1-随机数" class="headerlink" title="3.3.1 随机数"></a>3.3.1 随机数</h4><h4 id="3-3-2-RC4"><a href="#3-3-2-RC4" class="headerlink" title="3.3.2 RC4"></a>3.3.2 RC4</h4><h4 id="3-3-3-Base64"><a href="#3-3-3-Base64" class="headerlink" title="3.3.3 Base64"></a>3.3.3 Base64</h4><h3 id="3-4-持久化分析"><a href="#3-4-持久化分析" class="headerlink" title="3.4 持久化分析"></a>3.4 持久化分析</h3><h4 id="3-4-1-注册表"><a href="#3-4-1-注册表" class="headerlink" title="3.4.1 注册表"></a>3.4.1 注册表</h4><h4 id="3-4-2-计划任务"><a href="#3-4-2-计划任务" class="headerlink" title="3.4.2 计划任务"></a>3.4.2 计划任务</h4><h3 id="3-5-网络通信分析"><a href="#3-5-网络通信分析" class="headerlink" title="3.5 网络通信分析"></a>3.5 网络通信分析</h3><h3 id="3-6-C2配置提取"><a href="#3-6-C2配置提取" class="headerlink" title="3.6 C2配置提取"></a>3.6 C2配置提取</h3><h3 id="3-7-WMI分析"><a href="#3-7-WMI分析" class="headerlink" title="3.7 WMI分析"></a>3.7 WMI分析</h3>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> malware analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows包管理工具-scoop</title>
      <link href="/2022/10/05/windows-bao-guan-li-gong-ju-scoop/"/>
      <url>/2022/10/05/windows-bao-guan-li-gong-ju-scoop/</url>
      
        <content type="html"><![CDATA[<h2 id="1-scoop包管理"><a href="#1-scoop包管理" class="headerlink" title="1. scoop包管理"></a>1. scoop包管理</h2><ol><li>寻找官方发布的软件源</li><li>下载（指定版本的）软件</li><li>运行软件安装器来安装下载得到的软件</li><li>修改环境，安装后的善后工作等</li></ol><h2 id="2-安装与卸载"><a href="#2-安装与卸载" class="headerlink" title="2.安装与卸载"></a>2.安装与卸载</h2><p><strong>需要在powershell下操作</strong></p><h3 id="2-1-普通用户"><a href="#2-1-普通用户" class="headerlink" title="2.1 普通用户"></a>2.1 普通用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 策略<br>Set-ExecutionPolicy RemoteSigned -scope CurrentUser;<br><br>// 设置路径<br><span class="hljs-variable">$env</span>:SCOOP = <span class="hljs-string">&#x27;C:\Tools\scoop&#x27;</span><br>[Environment]::SetEnvironmentVariable(<span class="hljs-string">&#x27;SCOOP&#x27;</span>, <span class="hljs-variable">$env</span>:SCOOP, <span class="hljs-string">&#x27;User&#x27;</span>)<br><br>// 安装<br>iwr -useb get.scoop.sh | iex<br>scoop install git<br>scoop update<br><br>// 卸载<br>scoop uninstall scoop<br></code></pre></td></tr></table></figure><h3 id="2-2-管理员权限"><a href="#2-2-管理员权限" class="headerlink" title="2.2 管理员权限"></a>2.2 管理员权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 生成ps脚本<br>irm get.scoop.sh -outfile <span class="hljs-string">&#x27;install.ps1&#x27;</span><br><br>// 修改策略<br>Set-ExecutionPolicy RemoteSigned -scope CurrentUser;<br><br>// 设置安装路径（scoop和apps）<br><span class="hljs-variable">$env</span>:SCOOP=<span class="hljs-string">&#x27;D:\SystemTools\scoop_apps&#x27;</span><br>[Environment]::SetEnvironmentVariable(<span class="hljs-string">&#x27;SCOOP&#x27;</span>, <span class="hljs-variable">$env</span>:SCOOP, <span class="hljs-string">&#x27;User&#x27;</span>)<br><br>// 安装<br> iex <span class="hljs-string">&quot;&amp; &#123;<span class="hljs-subst">$(irm get.scoop.sh)</span>&#125; -RunAsAdmin&quot;</span><br> scoop install git<br> scoop update<br> <br> // 卸载<br> scoop uninstall scoop<br></code></pre></td></tr></table></figure><h2 id="3-软件源配置"><a href="#3-软件源配置" class="headerlink" title="3.软件源配置"></a>3.软件源配置</h2><h3 id="3-1-添加软件源"><a href="#3-1-添加软件源" class="headerlink" title="3.1 添加软件源"></a>3.1 添加软件源</h3><h4 id="3-1-1-官方源"><a href="#3-1-1-官方源" class="headerlink" title="3.1.1 官方源"></a>3.1.1 官方源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 列出名字<br>scoop bucket known<br><br>// 直接添加<br>scoop bucket add &lt;bucket-name&gt;<br></code></pre></td></tr></table></figure><h4 id="3-1-2-第三方源"><a href="#3-1-2-第三方源" class="headerlink" title="3.1.2 第三方源"></a>3.1.2 第三方源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop bucket add &lt;bucket-name&gt; &lt;bucket-origin-url&gt;<br></code></pre></td></tr></table></figure><h4 id="3-1-3-自定义源"><a href="#3-1-3-自定义源" class="headerlink" title="3.1.3 自定义源"></a>3.1.3 自定义源</h4><p><a href="https://github.com/ScoopInstaller/Scoop/wiki/App-Manifests">App Manifests · ScoopInstaller&#x2F;Scoop Wiki (github.com)</a></p><p><a href="https://github.com/ScoopInstaller/Scoop/wiki/Buckets">Buckets · ScoopInstaller&#x2F;Scoop Wiki (github.com)</a></p><h3 id="3-2-列出已装软件源"><a href="#3-2-列出已装软件源" class="headerlink" title="3.2 列出已装软件源"></a>3.2 列出已装软件源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop bucket list<br></code></pre></td></tr></table></figure><h3 id="3-3-删除软件源"><a href="#3-3-删除软件源" class="headerlink" title="3.3 删除软件源"></a>3.3 删除软件源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop bucket <span class="hljs-built_in">rm</span> &lt;name&gt;<br></code></pre></td></tr></table></figure><h2 id="4-软件安装与卸载"><a href="#4-软件安装与卸载" class="headerlink" title="4.软件安装与卸载"></a>4.软件安装与卸载</h2><h3 id="4-1-搜索软件"><a href="#4-1-搜索软件" class="headerlink" title="4.1 搜索软件"></a>4.1 搜索软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop search &lt;incomplete-app-name&gt;<br></code></pre></td></tr></table></figure><h3 id="4-2-指定软件源安装"><a href="#4-2-指定软件源安装" class="headerlink" title="4.2 指定软件源安装"></a>4.2 指定软件源安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop install &lt;bucket-name&gt;/&lt;app-name&gt;<br></code></pre></td></tr></table></figure><h3 id="4-3-列出已装软件"><a href="#4-3-列出已装软件" class="headerlink" title="4.3 列出已装软件"></a>4.3 列出已装软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop list<br></code></pre></td></tr></table></figure><h3 id="4-4-更新软件"><a href="#4-4-更新软件" class="headerlink" title="4.4 更新软件"></a>4.4 更新软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop update &lt;app-name&gt;<br></code></pre></td></tr></table></figure><h3 id="4-5-删除软件"><a href="#4-5-删除软件" class="headerlink" title="4.5 删除软件"></a>4.5 删除软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop unistall &lt;app-name&gt;<br></code></pre></td></tr></table></figure><h2 id="5-拓展功能"><a href="#5-拓展功能" class="headerlink" title="5.拓展功能"></a>5.拓展功能</h2><h3 id="5-1-设置scoop自动补全"><a href="#5-1-设置scoop自动补全" class="headerlink" title="5.1 设置scoop自动补全"></a>5.1 设置scoop自动补全</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 安装插件<br>scoop bucket add extras<br>scoop install scoop-completion<br>// 编辑配置文件<br><span class="hljs-keyword">if</span> (!(Test-Path <span class="hljs-variable">$profile</span>)) &#123; New-Item -Path <span class="hljs-variable">$profile</span> -ItemType <span class="hljs-string">&quot;file&quot;</span> -Force &#125;<br><span class="hljs-variable">$profile</span>// 打印出位置<br>// 配置文件中添加<br>Import-Module <span class="hljs-string">&quot;<span class="hljs-subst">$($(Get-Item $(Get-Command scoop.ps1)</span>.Path).Directory.Parent.FullName)\modules\scoop-completion&quot;</span><br></code></pre></td></tr></table></figure><h3 id="5-2-安装aria2加快下载速度"><a href="#5-2-安装aria2加快下载速度" class="headerlink" title="5.2 安装aria2加快下载速度"></a>5.2 安装aria2加快下载速度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop install aria2<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> package-manager </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Malware Analysis 脱壳与C2提取</title>
      <link href="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/"/>
      <url>/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-加密壳的特征"><a href="#1-加密壳的特征" class="headerlink" title="1.加密壳的特征"></a>1.加密壳的特征</h2><ul><li>程序只有很少的导入DLL和函数</li><li>存在很多混淆的字符串</li><li>存在直接的系统调用</li><li>不规范的节区名字</li><li>不常见的可执行节区（应该只用.text&#x2F;.code节是可执行的）</li><li>意外的可写节区</li><li>raw-size和virtual-size之间差异很大</li><li>存在0大小的节区</li><li>缺少网络通信相关的API</li><li>缺乏用于恶意软件功能的基本 API（例如，勒索软件中的 Crypt* 功能）</li><li>不常见的文件格式和头</li><li>OEP指向 .text&#x2F;.code 之外的其他部分</li><li>资源部分（.rsrc 部分）很大，代码中存在 LoadResource( ) 函数</li><li>存在叠加层</li><li>在IDA中的彩条中发现很大的数据和未被探索的代码</li></ul><h2 id="2-虚拟化壳的特征"><a href="#2-虚拟化壳的特征" class="headerlink" title="2.虚拟化壳的特征"></a>2.虚拟化壳的特征</h2><ul><li>通常是64位的</li><li>IAT表被移除或者只有一个导入函数</li><li>大多数字符串都被加密了</li><li>存在内存完整性校验和保护</li><li>指令被虚拟并且被翻译成RISC指令</li><li>虚拟指令在内存中加密存储</li><li>混淆是基于栈的，因此使用静态方法处理虚拟化代码非常困难</li><li>大部分虚拟化代码都是多态的，所以有很多虚拟指令指的是同一条原始指令</li><li>有数千行push指令，其中许多都是没用的</li><li>使用无条件跳转实现代码重排</li><li>存在控制流平坦化、反调试、反虚拟机等技术</li><li>并非所有 x64 指令都是虚拟化的，因此您会发现包含虚拟化和非虚拟化（原始）指令混合的二进制代码</li><li>大多数时候，函数的序言和尾声都没有被虚拟化</li><li>原始代码可以被分散存放，因此指令和数据将混合在一起</li><li>引用导入函数的指令可能被清零或被替换成NOP，因此这些位置将被动态恢复。有时，这些引用位置不为0，被修改为指向一张假的IAT表，此时为IAT混淆</li><li>在 shellcode 和常见恶意软件中使用的 API 名称是经过hash的</li><li>从原始寄存器到虚拟寄存器的转换通常是一对一的，但并非总是如此。此外，还有一个上下文切换组件负责将寄存器和标志信息传输到虚拟机上下文中</li><li>虚拟机处理程序来自data段</li><li>许多原始API被重定向到转发调用的存根代码处</li><li>使用了如常量展开、基于模式的混淆、间接控制、函数内联、代码复用，不透明谓词等混淆技术</li></ul><h2 id="3-调试已加壳程序注意事项"><a href="#3-调试已加壳程序注意事项" class="headerlink" title="3.调试已加壳程序注意事项"></a>3.调试已加壳程序注意事项</h2><ul><li>使用反反调试插件来过掉常规反调试，甚至使用内核调试器</li><li>注意主机名、账户名、以及样本名（程序检测文件名是否是hash）</li><li>为虚拟机分配100GB以上的磁盘空间</li><li>为虚拟机拍摄开机时间超过20分钟的快照</li><li>Process Hacker、Process Explorer、Process Monitor等知名工具的恶意代码检查（建议在使用前重命名这些可执行二进制文件）</li></ul><h2 id="4-脱壳后的修复工作"><a href="#4-脱壳后的修复工作" class="headerlink" title="4.脱壳后的修复工作"></a>4.脱壳后的修复工作</h2><ul><li>修复PE文件头</li><li>修复OEP，可能是0或者是错误的RVA</li><li>修复IAT</li><li>修复ImageBase</li><li>检查dump到的数据是已映射的还是未映射的</li></ul><h2 id="5-恶意代码中常用的注入状态机"><a href="#5-恶意代码中常用的注入状态机" class="headerlink" title="5.恶意代码中常用的注入状态机"></a>5.恶意代码中常用的注入状态机</h2><h3 id="5-1-远程线程注入"><a href="#5-1-远程线程注入" class="headerlink" title="5.1 远程线程注入"></a>5.1 远程线程注入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">OpenProcess</span>( ) -&gt; <br><span class="hljs-built_in">VirtualAllocEx</span>( ) -&gt; <br><span class="hljs-built_in">WriteProcessMemory</span>( ) -&gt; <br><span class="hljs-built_in">CreateRemoteThreat</span>( ) | <span class="hljs-built_in">NtCreateThread</span>( ) | <span class="hljs-built_in">RtlCreateUserThread</span>( )<br></code></pre></td></tr></table></figure><h3 id="5-2-自注入"><a href="#5-2-自注入" class="headerlink" title="5.2 自注入"></a>5.2 自注入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">OpenThread</span>( ) -&gt;<br><span class="hljs-built_in">SuspendThread</span>( ) -&gt;<br><span class="hljs-built_in">VirtualAllocEx</span>( ) -&gt; <br><span class="hljs-built_in">WriteProcessMemory</span>( ) -&gt;<br><span class="hljs-built_in">SetThreatContext</span>( ) -&gt;<br><span class="hljs-built_in">ResumeThreat</span>( ) | <span class="hljs-built_in">NtResumeThread</span>( )<br></code></pre></td></tr></table></figure><h3 id="5-3-反射式注入"><a href="#5-3-反射式注入" class="headerlink" title="5.3 反射式注入"></a>5.3 反射式注入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">Cobalt Strike中使用的一套API：<br><br><span class="hljs-built_in">CreateFileMapping</span>( ) -&gt;<br>Nt/<span class="hljs-built_in">MapViewOfFile</span>( ) -&gt;<br><span class="hljs-built_in">OpenProcess</span>( ) -&gt; <br><span class="hljs-built_in">memcpy</span>( ) -&gt;<br>Nt/<span class="hljs-built_in">MapViewOfSection</span>( ) -&gt;<br><span class="hljs-built_in">OpenProcess</span>( ) -&gt;<br><span class="hljs-built_in">CreateThread</span>( ) | <span class="hljs-built_in">NtQueueApcThread</span>( ) | <span class="hljs-built_in">CreateRemoteThread</span>( ) | <span class="hljs-built_in">RtlCreateUserThread</span>( )<br>    <br><span class="hljs-comment">// 变体</span><br><span class="hljs-built_in">VirtualQueryEx</span>( ) <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">ReadProcessMemory</span><span class="hljs-params">( )</span></span><br></code></pre></td></tr></table></figure><h3 id="5-4-APC注入"><a href="#5-4-APC注入" class="headerlink" title="5.4 APC注入"></a>5.4 APC注入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">SleepEx</span>( ) | <span class="hljs-built_in">SignalObjectAndWait</span>( ) | <span class="hljs-built_in">MsgWaitForMultipleObjectsEx</span>( ) | <span class="hljs-built_in">WaitForMultipleObjectsEx</span>( ) | <span class="hljs-built_in">WaitForSingleObjectEx</span>( )<br><span class="hljs-built_in">CreateToolhelp32Snapshot</span>(), <span class="hljs-built_in">Process32First</span>( ),<span class="hljs-built_in">Process32Next</span>( ), <span class="hljs-built_in">Thread32First</span>( ), <span class="hljs-built_in">Thread32Next</span>( )<br><span class="hljs-built_in">QueueUserAPC</span>( ) <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">KeInitializeAPC</span><span class="hljs-params">( )</span></span><br></code></pre></td></tr></table></figure><h3 id="5-5-傀儡进程"><a href="#5-5-傀儡进程" class="headerlink" title="5.5 傀儡进程"></a>5.5 傀儡进程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">CreateProcess</span>( ), <span class="hljs-built_in">NtQueryProcessInformation</span>( ), <span class="hljs-built_in">GetModuleHandle</span>( ),<br>Zw/<span class="hljs-built_in">NtUnmapViewOfSection</span>( ), <span class="hljs-built_in">VirtualAllocEx</span>( ), <span class="hljs-built_in">WriteProcessMemory</span>( ), <span class="hljs-built_in">GetThreadContext</span>( ),<br><span class="hljs-built_in">SetThreadContext</span> ( ) <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">ResumeThread</span><span class="hljs-params">( )</span></span><br></code></pre></td></tr></table></figure><h3 id="5-6-AtomBombing"><a href="#5-6-AtomBombing" class="headerlink" title="5.6 AtomBombing"></a>5.6 AtomBombing</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">OpenThread</span>( ) -&gt; <br><span class="hljs-built_in">GlobalAddAtom</span>( ) -&gt;<br><span class="hljs-built_in">GlobalGetAtomName</span>( ) -&gt;<br><span class="hljs-built_in">QueueUserAPC</span>( )<br></code></pre></td></tr></table></figure><h3 id="5-7-Process-Doppelganging"><a href="#5-7-Process-Doppelganging" class="headerlink" title="5.7 Process Doppelgänging"></a>5.7 Process Doppelgänging</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">CreateTransaction</span>( ), <span class="hljs-built_in">CreateFileTransaction</span>( ), NtCreateSection, <span class="hljs-built_in">NtCreateProcessEx</span>( ),<br><span class="hljs-built_in">NtQueryInformationProcess</span>( ), <span class="hljs-built_in">NtCreateThreadEx</span>( ) <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">RollbackTransaction</span><span class="hljs-params">( )</span></span><br></code></pre></td></tr></table></figure><h3 id="5-8-Process-Herpaderping"><a href="#5-8-Process-Herpaderping" class="headerlink" title="5.8 Process Herpaderping"></a>5.8 Process Herpaderping</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">CreateFile</span>( ), <span class="hljs-built_in">NtCreateSection</span>( ), <span class="hljs-built_in">NtCreateProcessEx</span>( ) <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">NtCreateThreadEx</span><span class="hljs-params">( )</span></span><br></code></pre></td></tr></table></figure><h3 id="5-9-全局钩子注入"><a href="#5-9-全局钩子注入" class="headerlink" title="5.9 全局钩子注入"></a>5.9 全局钩子注入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">SetWindowsHookEx</span>( ) <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">PostThreadMessage</span><span class="hljs-params">( )</span></span><br></code></pre></td></tr></table></figure><h3 id="5-10-额外窗口内存注入"><a href="#5-10-额外窗口内存注入" class="headerlink" title="5.10 额外窗口内存注入"></a>5.10 额外窗口内存注入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">FindWindowsA</span>( ),<br><span class="hljs-built_in">GetWindowThreadProcessId</span>( ), <span class="hljs-built_in">OpenProcess</span>( ), <span class="hljs-built_in">VirtualAllocEx</span>( ), <span class="hljs-built_in">WriteProcessMemory</span>( ),<br><span class="hljs-built_in">SetWindowLongPtrA</span>( ) <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">SendNotify</span><span class="hljs-params">( )</span></span><br></code></pre></td></tr></table></figure><h3 id="5-11-Propagate注入"><a href="#5-11-Propagate注入" class="headerlink" title="5.11 Propagate注入"></a>5.11 Propagate注入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">FindWindow</span>( ), <span class="hljs-built_in">FindWindowEx</span>( ), <span class="hljs-built_in">GetProp</span>( ),<br><span class="hljs-built_in">GetWindowThreadProcessId</span>( ), <span class="hljs-built_in">OpenProcess</span>( ), <span class="hljs-built_in">ReadProcessMemory</span>( ), <span class="hljs-built_in">VirtualAllocEx</span>( ),<br><span class="hljs-built_in">WriteProcessMemory</span>( ), <span class="hljs-built_in">SetProp</span>( ) <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">PostMessage</span><span class="hljs-params">( )</span></span><br></code></pre></td></tr></table></figure><h2 id="6-脱壳手段"><a href="#6-脱壳手段" class="headerlink" title="6.脱壳手段"></a>6.脱壳手段</h2><h3 id="6-1-关键API设置断点"><a href="#6-1-关键API设置断点" class="headerlink" title="6.1 关键API设置断点"></a>6.1 关键API设置断点</h3><ul><li><strong>CreateProcessInternalW( )</strong></li><li><strong>VirtualAlloc( )</strong> | <strong>VirtualAllocEx( )</strong></li><li><strong>VirtualProtect( ) | ZwProtectVirtualMemory( )</strong></li><li><strong>WriteProcessMemory( ) | NtWriteProcessMemory( )</strong></li><li><strong>ResumeThread( ) | NtResumeThread( )</strong></li><li><strong>CryptDecrypt( ) | RtlDecompressBuffer( )</strong></li><li><strong>NtCreateSection( ) + MapViewOfSection( ) | ZwMapViewOfSection( )</strong></li><li><strong>UnmapViewOfSection( ) | ZwUnmapViewOfSection( )</strong></li><li><strong>NtWriteVirtualMemory( )</strong></li><li><strong>NtReadVirtualMemory( )</strong></li></ul><p><strong>注意事项：</strong></p><p>1.需要执行到程序模板后设置断点，越过系统初始化部分。</p><p>2.使用反调试插件，有时候还需要忽略全部异常。</p><p>3.在VirtualAlloc( )函数设置断点时，建议设置在返回代码（ret 10）处，之后设置内存写入断点来监控这块内存。</p><p>4.可以使用Intel PIN工具来追踪OEP</p><h3 id="6-2-设置DLL加载断点"><a href="#6-2-设置DLL加载断点" class="headerlink" title="6.2 设置DLL加载断点"></a>6.2 设置DLL加载断点</h3><p>在每个DLL加载的过程中去检索内存</p><h3 id="6-3-自动化脱壳工具"><a href="#6-3-自动化脱壳工具" class="headerlink" title="6.3 自动化脱壳工具"></a>6.3 自动化脱壳工具</h3><p>内存扫描工具1：<a href="https://github.com/hasherezade/hollows_hunter">hasherezade&#x2F;hollows_hunter: Scans all running processes. Recognizes and dumps a variety of potentially malicious implants (replaced&#x2F;implanted PEs, shellcodes, hooks, in-memory patches). (github.com)</a></p><p>内存扫描工具2：<a href="https://github.com/hasherezade/pe-sieve">Releases · hasherezade&#x2F;pe-sieve (github.com)</a></p><p>内存转储：<a href="https://github.com/hasherezade/mal_unpack">hasherezade&#x2F;mal_unpack: Dynamic unpacker based on PE-sieve (github.com)</a></p><h3 id="6-4-付费脱壳"><a href="#6-4-付费脱壳" class="headerlink" title="6.4 付费脱壳"></a>6.4 付费脱壳</h3><p><a href="https://www.unpac.me/#/">https://www.unpac.me/#/</a></p><h2 id="7-示例分析"><a href="#7-示例分析" class="headerlink" title="7.示例分析"></a>7.示例分析</h2><h3 id="7-1-脱壳"><a href="#7-1-脱壳" class="headerlink" title="7.1 脱壳"></a>7.1 脱壳</h3><p>先用PE bear看一下，导入表中不存在网络相关的API吗。可能被隐藏了。</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006224007945.png" alt="查看导入表"></p><p>再使用PEStdudio查看一下节表，.data段的raw size与virtual size差别很大，很可疑。</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006224140735.png" alt="查看节表"></p><p>因为目标程序是DLL，可以使用rundll32.exe以及指定导出函数的方式进行调试。</p><p>命令行参数：”C:\Windows\SysWOW64\rundll32.exe” C:\Users\mas\Desktop\8ff43b6ddf6243bd5ee073f9987920fa223809f589d151d7e438fd8cc08ce292\sample_1.bin,#1</p><p><strong>表示调用第一个导出函数</strong></p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006224700218.png" alt="x32dbg调试dll"></p><p>在内存相关API下断点。（VirtualAlloc ret 0x10、VirtualProtect、ResumeThread）</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006224745648.png" alt="设置断点"></p><p>F9运行，会在VirtualAlloc处首次断下，将eax所指的地址放到内存窗口1进行观察；继续F9，还会在此函数断下，继续将地址放入内存窗口2观察；继续F9，重复上述步骤；继续F9，会在VirtualProtected处断下，并且内存窗口3中的内容如下：</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006225231324.png" alt="内存窗口3"></p><p>可以看见是 aPLib 压缩格式，将此内存区域的内存dump出来。</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006225413256.png" alt="内存dump"></p><p>拖入010editor，搜索字符串MZ，可以发现存在PE文件。</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006225754919.png" alt="010搜索PE"></p><p>将MZ前的数据全部删除，并保存，此时得到一个完整的PE文件，拖入PE Bear中查看导入表，可以发现网络相关的API都出现了。</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006225928161.png" alt="dump_1.bin"></p><h3 id="7-2-分析解密算法"><a href="#7-2-分析解密算法" class="headerlink" title="7.2 分析解密算法"></a>7.2 分析解密算法</h3><p>此时基本的脱壳已经完成，接下来寻找这个程序的C2配置，在IDA中打开dump_1.binv并点击ida中的Unexplored区域头部。</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006230229938.png" alt="Unexplored区域"></p><p>此处根据经验猜测 byte_10004010 为8字节密钥，unk_10004018 为加密后的数据，查看byte_10004010处的交叉引用，定位操作代码。</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006230628513.png" alt="sub_10001CB7"></p><p>向上分析一下，可以判断sub_100011A4函数是申请堆内存，如图所示：</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006230756414.png" alt="sub_100011A4"></p><p>sub_10001214函数就是memcpy函数，如图所示：</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006230904227.png" alt="sub_10001214"></p><p>此时代码变成如下：</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006231019430.png" alt="sub_10001CB7整理"></p><p>sub_10002131函数中进行加解密操作，分析结果如下：</p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006231229805.png" alt="sub_10002131整理"></p><p><strong>解密算法为：</strong></p><p>使用SHA1对8字节的key进行hash，得到rc4的5字节密钥，再使用此密钥进行rc4解密得到C2配置。</p><p><strong>信息整理如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">原始key: C58B00157F8E9288 (after first 16 bytes of .data section)<br>加密数据地址: 0x10004018<br>加密数据大小: 0x2000<br><span class="hljs-built_in">hash</span>算法: SHA1 (20 bytes)<br>解密算法: RC4<br>RC4 Key 长度: 5 bytes<br></code></pre></td></tr></table></figure><h3 id="7-3-编写自动化脚本"><a href="#7-3-编写自动化脚本" class="headerlink" title="7.3 编写自动化脚本"></a>7.3 编写自动化脚本</h3><p><strong>编写python3脚本实现自动提取C2配置：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> pefile<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> ARC4<br><span class="hljs-keyword">from</span> Crypto.Hash <span class="hljs-keyword">import</span> SHA<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_data</span>(<span class="hljs-params">filename</span>):<br><br>    pe = pefile.PE(filename)<br>    <span class="hljs-keyword">for</span> section <span class="hljs-keyword">in</span> pe.sections:<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;.data&quot;</span> <span class="hljs-keyword">in</span> section.Name.decode(encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>).rstrip(<span class="hljs-string">&#x27;x00&#x27;</span>):<br>            <span class="hljs-keyword">return</span> section.get_data(section.VirtualAddress, section.SizeOfRawData)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_decryptor</span>(<span class="hljs-params">rc4key, encrypted_config</span>):<br>    <br>    rc4_cipher = ARC4.new(rc4key)<br>    decrypted_config = rc4_cipher.decrypt(encrypted_config)<br>    <span class="hljs-keyword">return</span> decrypted_config<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br><br>    filename = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Filename: &quot;</span>)<br>    <span class="hljs-comment"># 获取.data节数据</span><br>    datasec = extract_data(filename)<br>    datesec2 = datasec[<span class="hljs-number">16</span>:]<br>    <span class="hljs-comment"># 获取8字节key</span><br>    key = (datesec2[:<span class="hljs-number">8</span>])<br>    <span class="hljs-comment"># 获取加密数据</span><br>    encrypted_data = binascii.hexlify(datesec2[<span class="hljs-number">8</span>:<span class="hljs-number">0x2000</span>])<br>    <span class="hljs-comment"># SHA1计算hash</span><br>    hashed_key = SHA.new(key).hexdigest()<br>    <span class="hljs-comment"># 得到rc4密钥（10表示前10个十六进制数，5个字节）</span><br>    true_key = hashed_key[:<span class="hljs-number">10</span>]<br>    <span class="hljs-comment"># rc4解密C2配置</span><br>    c2_config = data_decryptor(binascii.unhexlify(true_key), binascii.unhexlify(encrypted_data))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n\nThe decrypted configuration follows: \n&quot;</span>)<br>    <span class="hljs-built_in">print</span>(c2_config.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span> :<br>    main( )<br></code></pre></td></tr></table></figure><p><strong>执行结果如下：</strong></p><p><img src="/2022/10/04/malware-analysis-tuo-ke-yu-c2-ti-qu/image-20221006232524037.png" alt="脚本执行结果"></p><h3 id="7-4-额外收获"><a href="#7-4-额外收获" class="headerlink" title="7.4 额外收获"></a>7.4 额外收获</h3><ul><li>调试dll，使用rundll32.exe加参数的方式。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;C:\Windows\SysWOW64\rundll32.exe&quot;</span> C:\Users\mas\Desktop\test.bin,<span class="hljs-comment">#1</span><br></code></pre></td></tr></table></figure><ul><li>python导入第三方库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pycryptodome（python 2.7需要改cypto文件夹首字母大写）<br>pip install pefile<br></code></pre></td></tr></table></figure><ul><li>unbuntu解压带密码的zip</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install p7zip-full<br>7z x test.zip<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> malware analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Malware Analysis 环境构建</title>
      <link href="/2022/10/04/malware-analysis-huan-jing-gou-jian/"/>
      <url>/2022/10/04/malware-analysis-huan-jing-gou-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-虚拟机"><a href="#1-虚拟机" class="headerlink" title="1.虚拟机"></a>1.虚拟机</h2><p><strong>操作系统：</strong></p><p>Windows 7&#x2F;10&#x2F;11</p><p>REmnux<a href="https://docs.remnux.org/install-distro/get-virtual-appliance">Get the Virtual Appliance - REMnux Documentation</a></p><p>Ubuntu  <a href="https://ubuntu.com/download/desktop">Download Ubuntu Desktop | Download | Ubuntu</a></p><h2 id="2-静态分析"><a href="#2-静态分析" class="headerlink" title="2.静态分析"></a>2.静态分析</h2><p>IDA Pro<a href="https://hex-rays.com/ida-pro/">Hex Rays - State-of-the-art binary code analysis solutions (hex-rays.com)</a></p><p>Ghidra <a href="https://github.com/NationalSecurityAgency/ghidra">NationalSecurityAgency&#x2F;ghidra: Ghidra is a software reverse engineering (SRE) framework (github.com)</a></p><h2 id="3-动态调试"><a href="#3-动态调试" class="headerlink" title="3.动态调试"></a>3.动态调试</h2><p>Windbg</p><p>x64dbg  <a href="https://x64dbg.com/#start">x64dbg</a></p><p>​ScyllaHide<a href="https://github.com/x64dbg/ScyllaHide/releases">Releases · x64dbg&#x2F;ScyllaHide (github.com)</a></p><p>​Labeless<a href="https://github.com/a1ext/labeless/releases">Releases · a1ext&#x2F;labeless (github.com)</a></p><p>​    DbgChild   <a href="https://github.com/therealdreg/DbgChild">therealdreg&#x2F;DbgChild: Debug Child Process Tool (auto attach) (github.com)</a></p><h2 id="4-PE查看与修复"><a href="#4-PE查看与修复" class="headerlink" title="4.PE查看与修复"></a>4.PE查看与修复</h2><p>PEBear：用于修复脱壳后的PE文件，以及查看pe信息</p><p><a href="https://github.com/hasherezade/pe-bear-releases">hasherezade&#x2F;pe-bear-releases: PE-bear (builds only) (github.com)</a></p><p>CFF Explorer<br><a href="https://ntcore.com/?page_id=388">Explorer Suite – NTCore</a></p><p>Pestudio：用于快速获取恶意软件相关信息</p><p><a href="https://www.winitor.com/">Winitor</a></p><p>pe_unmapper：用于完成PE文件映射与非映射状态的转换</p><p><a href="https://github.com/hasherezade/libpeconv/tree/master/pe_unmapper">libpeconv&#x2F;pe_unmapper at master · hasherezade&#x2F;libpeconv (github.com)</a></p><h2 id="5-二进制编辑"><a href="#5-二进制编辑" class="headerlink" title="5.二进制编辑"></a>5.二进制编辑</h2><p>010Editor：16进制文本编辑工具</p><p>HxD：16进制文本编辑工具</p><p><a href="https://mh-nexus.de/en/hxd/">HxD - Freeware Hex Editor and Disk Editor | mh-nexus</a></p><p>XVI32 Hex Editor：16进制文本编辑工具</p><p><a href="http://www.chmaas.handshake.de/delphi/freeware/xvi32/xvi32.htm">Freeware Hex Editor XVI32 (handshake.de)</a></p><h2 id="6-样本信息收集"><a href="#6-样本信息收集" class="headerlink" title="6.样本信息收集"></a>6.样本信息收集</h2><h3 id="6-1-Malware-Bazaar"><a href="#6-1-Malware-Bazaar" class="headerlink" title="6.1 Malware Bazaar"></a>6.1 Malware Bazaar</h3><p>支持查看样本信息以及根据hash下载样本。常用命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 根据<span class="hljs-built_in">hash</span>下载样本<br>malwoverview.py -b 5 -B <span class="hljs-built_in">hash</span><br><br>// 粗略分析样本行为<br>malwoverview.py -b 1 -B <span class="hljs-built_in">hash</span><br><br>// 获取Botnet的一些信息<br>malwoverview.py -x 1 -X <span class="hljs-built_in">hash</span><br>malwoverview.py -x 2 -X Triage_ID<br><br>// 获取沙箱分析报告<br>malwoverview.py -x 7 -X Triage_ID<br></code></pre></td></tr></table></figure><p><strong>常用命令如下：</strong></p><p>-h：查看命令帮助</p><p>-c：手动指定API配置文件(.malwapi.conf)，模板如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span>VIRUSTOTAL<span class="hljs-punctuation">]</span><br>VTAPI = https<span class="hljs-punctuation">:</span><span class="hljs-comment">//www.virustotal.com/gui/join-us</span><br><br><span class="hljs-punctuation">[</span>HYBRID-ANALYSIS<span class="hljs-punctuation">]</span><br>HAAPI = https<span class="hljs-punctuation">:</span><span class="hljs-comment">//www.hybrid-analysis.com/signup</span><br><br><span class="hljs-punctuation">[</span>MALSHARE<span class="hljs-punctuation">]</span><br>MALSHAREAPI = https<span class="hljs-punctuation">:</span><span class="hljs-comment">//malshare.com/doc.php</span><br><br><span class="hljs-punctuation">[</span>HAUSSUBMIT<span class="hljs-punctuation">]</span><br>HAUSSUBMITAPI =https<span class="hljs-punctuation">:</span><span class="hljs-comment">//urlhaus.abuse.ch/api/#account</span><br><br><span class="hljs-punctuation">[</span>POLYSWARM<span class="hljs-punctuation">]</span><br>POLYAPI =  https<span class="hljs-punctuation">:</span><span class="hljs-comment">//docs.polyswarm.io/consumers</span><br><br><span class="hljs-punctuation">[</span>ALIENVAULT<span class="hljs-punctuation">]</span><br>ALIENAPI = https<span class="hljs-punctuation">:</span><span class="hljs-comment">//otx.alienvault.com/api</span><br><br><span class="hljs-punctuation">[</span>MALPEDIA<span class="hljs-punctuation">]</span><br>MALPEDIAAPI =<br><br><span class="hljs-punctuation">[</span>TRIAGE<span class="hljs-punctuation">]</span><br>TRIAGEAPI = https<span class="hljs-punctuation">:</span><span class="hljs-comment">//tria.ge/signup</span><br></code></pre></td></tr></table></figure><p>-o：指定输出信息颜色（0、1）</p><table><thead><tr><th>-o</th><th>info</th></tr></thead><tbody><tr><td>0</td><td>深色</td></tr><tr><td>1</td><td>浅色</td></tr></tbody></table><p>-b：从MALWARE和THREATFOX中检索信息，-B指定附加参数，可以获得API分析分析报告</p><table><thead><tr><th>-b</th><th>-B</th><th>info</th></tr></thead><tbody><tr><td>1</td><td>hash</td><td>检索hash信息</td></tr><tr><td>2</td><td>tag</td><td>根据标签获取相关信息以及样本列表</td></tr><tr><td>3</td><td>imphash</td><td>根据imphash样本列表</td></tr><tr><td>4</td><td>100&#x2F;time</td><td>查询最新的恶意样本</td></tr><tr><td>5</td><td>hash</td><td>下载样本，解压密码：infected</td></tr><tr><td>6</td><td>days</td><td>获取IOC数据集</td></tr><tr><td>7</td><td>ioc</td><td>搜索指定IOC</td></tr><tr><td>8</td><td>tag</td><td>根据指定标签检索IOC</td></tr><tr><td>9</td><td>family</td><td>根据家族检索IOC</td></tr><tr><td>10</td><td></td><td>列出所有可用的家族</td></tr></tbody></table><p>-x：从TRIAGE中检索信息，-X指定附加参数，可以获得更详细的分析报告。</p><table><thead><tr><th>-x</th><th>-X</th><th>info</th></tr></thead><tbody><tr><td>1</td><td>hash&#x2F;md5&#x2F;family&#x2F;score&#x2F;tag&#x2F;url&#x2F;wallet&#x2F;ip</td><td>获取信息</td></tr><tr><td>2</td><td>Triage ID</td><td>获取报告</td></tr><tr><td>3</td><td></td><td>提交样本进行分析</td></tr><tr><td>4</td><td>url</td><td>提交url进行分析</td></tr><tr><td>5</td><td>Triage ID</td><td>下载Triage ID指定的样本</td></tr><tr><td>6</td><td>Triage ID</td><td>下载pcapng文件</td></tr><tr><td>7</td><td>Triage ID</td><td>获取沙箱动态报告</td></tr></tbody></table><p>-d：指定目录进行VT扫描，-D指定api</p><table><thead><tr><th>-d</th><th>-D</th><th>info</th></tr></thead><tbody><tr><td>dir</td><td>0</td><td>公开api</td></tr><tr><td>dir</td><td>1</td><td>优质api</td></tr></tbody></table><p>-v：从VIRUS TOTAL中检索信息，-V指定扫描参数</p><table><thead><tr><th>-v</th><th>-V</th><th>info</th></tr></thead><tbody><tr><td>1</td><td>file</td><td>获取VT报告</td></tr><tr><td>2</td><td>file</td><td>获取反病毒报告</td></tr><tr><td>3</td><td>file</td><td>获取反病毒报告，包括IAT和EAT</td></tr><tr><td>4</td><td>file</td><td>提取overlay</td></tr><tr><td>5</td><td>url</td><td>获取VT报告</td></tr><tr><td>6</td><td>ip</td><td>获取VT报告</td></tr><tr><td>7</td><td>file</td><td>获取provided domain报告</td></tr><tr><td>8</td><td>hash</td><td>验证指定Hash</td></tr><tr><td>9</td><td>file(&gt;&#x3D;20m)</td><td>获取VT报告</td></tr><tr><td>10</td><td>file</td><td>从指定文件中验证Hash，使用公开API</td></tr><tr><td>11</td><td>file</td><td>从指定文件中验证Hash，使用优质API</td></tr><tr><td>12</td><td>file</td><td>获取Hash样本行为</td></tr><tr><td>13</td><td>file(&gt;&#x3D;32m)</td><td>向vt提交超过32MB的文件</td></tr></tbody></table><p>-a 从HYBRID中检索信息。-A 指定附加参数</p><table><thead><tr><th>-a</th><th>-A</th><th>info</th></tr></thead><tbody><tr><td>1</td><td>hash&#x2F;file</td><td>获取Windows 32位分析报告</td></tr><tr><td>2</td><td>hash&#x2F;file</td><td>获取Windows32位分析报告，HWP支持</td></tr><tr><td>3</td><td>hash&#x2F;file</td><td>获取Windows 64位分析报告</td></tr><tr><td>4</td><td>hash&#x2F;file</td><td>获取Android环境分析报告</td></tr><tr><td>5</td><td>hash&#x2F;file</td><td>获取Linux 64分析报告</td></tr><tr><td>6</td><td>hash&#x2F;file</td><td>提交Windows 32位样本</td></tr><tr><td>7</td><td>hash&#x2F;file</td><td>提交Windows 32位样本，HWP支持</td></tr><tr><td>8</td><td>hash&#x2F;file</td><td>提交Windows 64位样本</td></tr><tr><td>9</td><td>hash&#x2F;file</td><td>提交安卓环境样本</td></tr><tr><td>10</td><td>hash&#x2F;file</td><td>提交Linux 64位样本</td></tr><tr><td>11</td><td>hash&#x2F;file</td><td>下载Windows 32位样本</td></tr><tr><td>12</td><td>hash&#x2F;file</td><td>下载Windows 32位样本，HWP支持</td></tr><tr><td>13</td><td>hash&#x2F;file</td><td>下载安卓环境样本</td></tr><tr><td>14</td><td>hash&#x2F;file</td><td>下载Linux 64样本</td></tr></tbody></table><p>-l：从MALSHARE中检索信息，-L指定附加参数</p><table><thead><tr><th>-l</th><th>-L</th><th>info</th></tr></thead><tbody><tr><td>1</td><td>hash</td><td>默认下载样本</td></tr><tr><td>2</td><td>hash</td><td>PE32</td></tr><tr><td>3</td><td>hash</td><td>ELF</td></tr><tr><td>4</td><td>hash</td><td>Java</td></tr><tr><td>5</td><td>hash</td><td>PDF</td></tr><tr><td>6</td><td>hash</td><td>Composite(OLE)</td></tr></tbody></table><p>-j：从URLHaus中检索信息，-J指定附加参数</p><table><thead><tr><th>-j</th><th>-J</th><th>info</th></tr></thead><tbody><tr><td>1</td><td>hash</td><td>下载样本</td></tr><tr><td>2</td><td>hash</td><td>查询样本信息</td></tr><tr><td>3</td><td>url</td><td>查询url信息</td></tr><tr><td>4</td><td>tag</td><td>根据标签检索恶意url</td></tr><tr><td>5</td><td>tag</td><td>根据标签检索payload</td></tr><tr><td>6</td><td></td><td>检索最近有效载荷的可下载链接列表</td></tr><tr><td>7</td><td></td><td>检索最近的恶意url列表</td></tr></tbody></table><p>-p：从POLYSWARM中检索Linux样本相关信息，-P指定附加参数</p><p>-y：从Hybrid中检索Android样本相关信息，-Y指定附加参数</p><p>-n：从ALIENVAULT中检索信息，-N指定附加参数</p><table><thead><tr><th>-n</th><th>-N</th><th>info</th></tr></thead><tbody><tr><td>1</td><td>subscribed pulses</td><td>获取subscribed pulses信息</td></tr><tr><td>2</td><td>ip</td><td>获取ip地址信息</td></tr><tr><td>3</td><td>domain</td><td>获取域名信息</td></tr><tr><td>4</td><td>hash</td><td>获取hash信息</td></tr><tr><td>5</td><td>url</td><td>获取url信息</td></tr></tbody></table><p>-m：从MALPEDIA中检索家族信息，-M指定附加参数，这个api不好获取</p><h3 id="6-2-Malware-Bazaar-bug修复"><a href="#6-2-Malware-Bazaar-bug修复" class="headerlink" title="6.2 Malware Bazaar-bug修复"></a>6.2 Malware Bazaar-bug修复</h3><p>在使用-x命令检索TRIAGE数据库时，需要指定api的同时指定token，而原项目代码中没有提供设置token的接口，执行-x指令会出现如下错误。</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221004220527110.png" alt="报错信息"></p><p>添加代码从json文件中读取token</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221004220244614.png" alt="添加json解析"></p><p>将所有的引用处改为如下格式：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221004220335138.png" alt="修改代码"></p><p>修改完成后可以得到正确结果：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221004220621915.png" alt="正确结果"></p><h2 id="7-IDA插件"><a href="#7-IDA插件" class="headerlink" title="7.IDA插件"></a>7.IDA插件</h2><h3 id="7-1-Labeless插件"><a href="#7-1-Labeless插件" class="headerlink" title="7.1 Labeless插件"></a>7.1 Labeless插件</h3><p>用于实现IDA与x64dbg同步注释</p><h4 id="7-1-1-安装"><a href="#7-1-1-安装" class="headerlink" title="7.1.1 安装"></a>7.1.1 安装</h4><h5 id="调试机"><a href="#调试机" class="headerlink" title="调试机"></a>调试机</h5><p>1.安装python 2.7（x86和x64都要装，x86添加进环境变量）</p><p>2.进行如下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> c:\deploy<br>c:\Python27\python.exe setup_protobuf.py<br><br>// 有网络<br>pip install --upgrade labeless<br><br>// 无网络<br>c:\Python27\Scripts\pip.exe install labeless-1.1.2.65-py2.py3-none-any.whl<br></code></pre></td></tr></table></figure><p>3.将插件dll复制进x96dbg的plugins目录</p><h5 id="分析机"><a href="#分析机" class="headerlink" title="分析机"></a>分析机</h5><p>1.安装python 2.7（x86和x64都要装，x86添加进环境变量）</p><p>2.拷贝IDA插件到plugins目录</p><h4 id="7-1-2-使用"><a href="#7-1-2-使用" class="headerlink" title="7.1.2 使用"></a>7.1.2 使用</h4><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005191959119.png" alt="Labeless"></p><h3 id="7-2-ret-sync插件"><a href="#7-2-ret-sync插件" class="headerlink" title="7.2 ret-sync插件"></a>7.2 ret-sync插件</h3><p>支持调试器与IDA同步调试，源项目支持为Windbg开启Trace功能，但是不够完善，不支持清除trace痕迹，同时x64dbg不具备trace功能。</p><h4 id="7-2-1-windbg添加trace清除"><a href="#7-2-1-windbg添加trace清除" class="headerlink" title="7.2.1 windbg添加trace清除"></a>7.2.1 windbg添加trace清除</h4><p>在IDAxx&#x2F;plugins&#x2F;SyncPlugin.py中添加如下代码：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005203116973.png" alt="SyncPlugin.py中添加代码"></p><p>在windbg插件项目中sync.cpp文件中添加如下代码来注册命令：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005203525574.png" alt="修改windbg插件代码"></p><p>此时只需要在windbg中输入 !bc cls 即可清空当前函数的痕迹。</p><h4 id="7-2-2-x64dbg添加trace功能"><a href="#7-2-2-x64dbg添加trace功能" class="headerlink" title="7.2.2 x64dbg添加trace功能"></a>7.2.2 x64dbg添加trace功能</h4><p>思路：既然windbg可以使用这个功能，x64dbg只需要改自己的这一部分代码来调用windbg的接口即可。分析windbg命令发包代码，格式如下：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005204011991.png" alt="msg封装"></p><p>x64dbg中没有bc这个命令，参考其他命令实现来自己添加一个。首先是命令处理函数声明：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005204204302.png" alt="函数声明"></p><p>为了方便使用，也注册一个help来告诉使用方法：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005204423469.png" alt="注册help"></p><p>在初始化函数中添加注册项：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005204817236.png" alt="init注册"></p><p>在关闭函数中注册销毁项：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005204932046.png" alt="stop注册"></p><p>实现一下初始化函数：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005205129438.png" alt="init实现"></p><p>发包函数实现如下：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005233154515.png" alt="发包函数"></p><p>效果如下：</p><p><img src="/2022/10/04/malware-analysis-huan-jing-gou-jian/image-20221005233453603.png" alt="x64dbg效果"></p><h4 id="7-2-3-配置与使用"><a href="#7-2-3-配置与使用" class="headerlink" title="7.2.3 配置与使用"></a>7.2.3 配置与使用</h4><h5 id="Windbg-Preview："><a href="#Windbg-Preview：" class="headerlink" title="Windbg Preview："></a>Windbg Preview：</h5><p>插件目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\用户名\AppData\Local\Microsoft\WindowsApps<br></code></pre></td></tr></table></figure><p>指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">.load <span class="hljs-built_in">sync</span>// 加载64位插件<br>.load sync32// 加载32位插件<br><br>!<span class="hljs-built_in">sync</span>     // 开启同步<br><br>!bc on     // 开启trace<br>!bc off        // 关闭trace<br>!bc cls    // 清空屏幕中函数<br></code></pre></td></tr></table></figure><h5 id="x64dbg："><a href="#x64dbg：" class="headerlink" title="x64dbg："></a>x64dbg：</h5><p>指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-built_in">sync</span>// 开启同步<br><br>!syncbc on// 开启trace<br>!syncbc off// 关闭trace<br>!syncbc cls// 清空屏幕中函数<br></code></pre></td></tr></table></figure><p><strong>远程调试：</strong></p><p>需要在idb所在的目录新建文件 .sync，内容如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[INTERFACE]</span><br><span class="hljs-attr">host</span> = 分析机ip<br><span class="hljs-attr">port</span> = 监听端口<br></code></pre></td></tr></table></figure><p>同时将配置文件拷贝到调试机的C:\Users\用户名\目录下，在使用过程中ida需要一直开着插件窗口。</p><h3 id="7-3-Flare-Capa-Explorer"><a href="#7-3-Flare-Capa-Explorer" class="headerlink" title="7.3 Flare Capa Explorer"></a>7.3 Flare Capa Explorer</h3><h4 id="7-3-1-安装"><a href="#7-3-1-安装" class="headerlink" title="7.3.1 安装"></a>7.3.1 安装</h4><p><strong>注：IDA安装目录下的 idapyswitch.exe 可以切换IDA Python版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">// ida 7.7<br>pip install wheel<br>python -m pip install git+https://github.com/mandiant/capa<br><br>git <span class="hljs-built_in">clone</span> http://github.com/mandiant/capa.git.<br>git <span class="hljs-built_in">clone</span> https://github.com/mandiant/capa-rules.git<br><br><span class="hljs-built_in">cp</span> capa\capa\ida\plugin\capa_explorer.py IDA Pro7.7\plugins<br></code></pre></td></tr></table></figure><h4 id="7-3-2-使用"><a href="#7-3-2-使用" class="headerlink" title="7.3.2 使用"></a>7.3.2 使用</h4><p>Edit -&gt; Plugin -&gt; Flare capa explorer窗口下点击Analyze，选择rules文件夹进行分析。</p><p><strong>注：时不时的更新一下rules</strong></p><h3 id="7-4-ApplyCalleType-and-StructTyper-plugins"><a href="#7-4-ApplyCalleType-and-StructTyper-plugins" class="headerlink" title="7.4 ApplyCalleType and StructTyper plugins"></a>7.4 ApplyCalleType and StructTyper plugins</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/mandiant/flare-ida<br></code></pre></td></tr></table></figure><h3 id="7-5-Findcrypt-yara"><a href="#7-5-Findcrypt-yara" class="headerlink" title="7.5 Findcrypt-yara"></a>7.5 Findcrypt-yara</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install yara-python<br>git <span class="hljs-built_in">clone</span> https://github.com/polymorf/findcrypt-yara.git<br>copy both findcrypt3.py and findcrypt3.rule to IDA’s plugin folder (C:\Program Files\IDA Pro<br>7.7\plugins)<br></code></pre></td></tr></table></figure><h3 id="7-6-HashDB"><a href="#7-6-HashDB" class="headerlink" title="7.6 HashDB"></a>7.6 HashDB</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/OALabs/hashdb-ida<br>copy hashdb.py to IDA’s plugin directory (C:\Program Files\IDA Pro 7.7\plugins)<br>Attention: as HashDB performs lookup on OALabs server, so you should remember to keep Internet access <span class="hljs-keyword">in</span> your environment<br></code></pre></td></tr></table></figure><p>- </p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> malware analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL partI</title>
      <link href="/2022/10/03/c-stl-parti/"/>
      <url>/2022/10/03/c-stl-parti/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h2><p>STL 标准模板库 | 泛型编程思想</p><p><strong>参考：</strong></p><ul><li><p><a href="https://cplusplus.com/">C++</a></p></li><li><p><a href="https://en.cppreference.com/w/">C++Reference</a></p></li></ul><h2 id="2-六大部件"><a href="#2-六大部件" class="headerlink" title="2.六大部件"></a>2.六大部件</h2><ul><li>容器 Containers</li><li>分配器         Allocators</li><li>算法             Algorithms</li><li>迭代器         Iterators</li><li>适配器         Adapters</li><li>仿函数         Functors</li></ul><p>结构图如下：</p><p><img src="/2022/10/03/c-stl-parti/image-20221003221715050.png" alt="六大部件关系图"></p><p><strong>示范代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ia[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>, allocator&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">vi</span>(ia, ia + <span class="hljs-number">6</span>);<br><br>cout &lt;&lt; <span class="hljs-built_in">count_if</span>(vi.<span class="hljs-built_in">begin</span>(), vi.<span class="hljs-built_in">end</span>(), <br>                     <span class="hljs-built_in">not1</span>(<span class="hljs-built_in">bind2nd</span>(<span class="hljs-built_in">less</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">3</span>))) &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>容器遍历：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = vec.<span class="hljs-built_in">begin</span>(); i != vec.<span class="hljs-built_in">end</span>(); i++)<br>&#123;<br>    cout &lt;&lt; *i &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">13</span>&#125;)<br>&#123;<br>cout &lt;&lt; i &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : vec)<br>&#123;<br>cout &lt;&lt; elem &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; elem : vec)<br>&#123;<br>elem++;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++异常处理</title>
      <link href="/2022/10/02/c-yi-chang-chu-li/"/>
      <url>/2022/10/02/c-yi-chang-chu-li/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1.基础语法"></a>1.基础语法</h2><p>try：可能出现异常的代码，使用throw抛出指定类型的异常。</p><p>throw：抛出异常语句。</p><p>catch：捕获指定类型的异常，并尝试做出处理。可以定义多个用于捕获各种类型的异常。</p><p><strong>基本类型异常</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">division</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Division by zero condition.&quot;</span>;<span class="hljs-comment">// 抛出const char* 类型异常</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a / b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br>std::cout &lt;&lt; <span class="hljs-built_in">division</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg)<br>&#123;<br>std::cout &lt;&lt; msg &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-built_in">catch</span> (...)<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;exception catched.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>C++标准异常</strong></p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002161750871.png" alt="C++标准异常继承树"></p><p><strong>自定义异常</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> : <span class="hljs-keyword">public</span> std::exception<span class="hljs-comment">// 继承自标准异常</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span><span class="hljs-comment">// throw()表示该函数不抛出任何异常</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyException.&quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">MyException</span>();<br>&#125;<br><span class="hljs-built_in">catch</span> (MyException&amp; e)<br>&#123;<br>std::cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-built_in">catch</span> (std::exception&amp; e)<span class="hljs-comment">// 捕获C++标准异常</span><br>&#123;<br>std::cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-x86异常处理"><a href="#2-x86异常处理" class="headerlink" title="2.x86异常处理"></a>2.x86异常处理</h2><h3 id="2-1-异常栈帧结构图"><a href="#2-1-异常栈帧结构图" class="headerlink" title="2.1 异常栈帧结构图"></a>2.1 异常栈帧结构图</h3><p><img src="/2022/10/02/c-yi-chang-chu-li/igor1_cpp_eh_stack_layout.gif" alt="栈帧结构图"></p><h3 id="2-2-结构定义"><a href="#2-2-结构定义" class="headerlink" title="2.2 结构定义"></a>2.2 结构定义</h3><h4 id="2-2-1-FuncInfo"><a href="#2-2-1-FuncInfo" class="headerlink" title="2.2.1 FuncInfo"></a>2.2.1 FuncInfo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数信息结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FuncInfo</span> &#123;<br>    <span class="hljs-comment">// 编译器版本号</span><br>    <span class="hljs-comment">// 0x19930520: up to VC6, 0x19930521: VC7.x(2002-2003), 0x19930522: VC8 (2005)</span><br>    DWORD magicNumber;<br><br>    <span class="hljs-comment">// 最大栈展开数的下标</span><br>    <span class="hljs-type">int</span> maxState;<br><br>    <span class="hljs-comment">// 栈展开结构数组指针</span><br>    UnwindMapEntry* pUnwindMap;<br><br>    <span class="hljs-comment">// 函数中try块个数</span><br>    DWORD nTryBlocks;<br><br>    <span class="hljs-comment">// try块结构数组指针</span><br>    TryBlockMapEntry* pTryBlockMap;<br><br>    <span class="hljs-comment">// x86未使用</span><br>    DWORD nIPMapEntries;<br><br>    <span class="hljs-comment">// x86未使用</span><br>    <span class="hljs-type">void</span>* pIPtoStateMap;<br><br>    <span class="hljs-comment">// VC7+ only, expected exceptions list (function &quot;throw&quot; specifier) </span><br>    ESTypeList* pESTypeList;<br><br>    <span class="hljs-comment">// VC8+ only, bit 0 set if function was compiled with /EHs</span><br>    <span class="hljs-type">int</span> EHFlags;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-UnwindMapEntry"><a href="#2-2-2-UnwindMapEntry" class="headerlink" title="2.2.2 UnwindMapEntry"></a>2.2.2 UnwindMapEntry</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 栈展开信息结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UnwindMapEntry</span> &#123;<br>    <span class="hljs-type">int</span> toState;        <span class="hljs-comment">// 栈展开下标数</span><br>    <span class="hljs-built_in">void</span> (*action)();   <span class="hljs-comment">// 展开执行函数地址</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-2-3-TryBlockMapEntry"><a href="#2-2-3-TryBlockMapEntry" class="headerlink" title="2.2.3 TryBlockMapEntry"></a>2.2.3 TryBlockMapEntry</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// try块结构</span><br><span class="hljs-comment">// 用于判断异常产生在哪个try块中</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TryBlockMapEntry</span> &#123;<br>    <span class="hljs-type">int</span> tryLow;<span class="hljs-comment">// try块最小状态索引，范围检查</span><br>    <span class="hljs-type">int</span> tryHigh;    <span class="hljs-comment">// try块最大状态索引，范围检查</span><br>    <span class="hljs-type">int</span> catchHigh;  <span class="hljs-comment">// catch块的最高状态索引，范围检查</span><br>    <span class="hljs-type">int</span> nCatches;   <span class="hljs-comment">// catch块个数</span><br>    HandlerType* pHandlerArray; <span class="hljs-comment">//catch块描述数组指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-2-4-HandlerType"><a href="#2-2-4-HandlerType" class="headerlink" title="2.2.4 HandlerType"></a>2.2.4 HandlerType</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// catch块结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HandlerType</span> &#123;<br>  <span class="hljs-comment">// 0x01: const, 0x02: volatile, 0x08: reference</span><br>  DWORD adjectives;<br><br>  <span class="hljs-comment">// catch块要捕获的RTTI类型指针</span><br>  TypeDescriptor* pType;<br><br>  <span class="hljs-comment">// 异常对象在当前ebp中的偏移位置</span><br>  <span class="hljs-type">int</span> dispCatchObj;<br><br>  <span class="hljs-comment">// address of the catch handler code.</span><br>  <span class="hljs-comment">// returns address where to continues execution (i.e. code after the try block)</span><br>  <span class="hljs-comment">// catch处理代码地址</span><br>  <span class="hljs-type">void</span>* addressOfHandler;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-2-5-ESTypeList"><a href="#2-2-5-ESTypeList" class="headerlink" title="2.2.5 ESTypeList"></a>2.2.5 ESTypeList</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实现了但是msvc默认不开启，可以使用 /d1Esrt 开启</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ESTypeList</span> &#123;<br><span class="hljs-comment">// 类型数组的数量</span><br><span class="hljs-type">int</span> nCount;<br><br><span class="hljs-comment">// list of exceptions; it seems only pType field in HandlerType is used</span><br>HandlerType* pTypeArray;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-2-6-TypeDescriptor"><a href="#2-2-6-TypeDescriptor" class="headerlink" title="2.2.6 TypeDescriptor"></a>2.2.6 TypeDescriptor</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TypeDescriptor</span> &#123;<br>  <span class="hljs-comment">// type_info类的虚表</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span> * pVFTable;<br><br>  <span class="hljs-comment">// used to keep the demangled name returned by type_info::name()</span><br>  <span class="hljs-comment">// type_info::name()得到的名字</span><br>  <span class="hljs-type">void</span>* spare;<br><br>  <span class="hljs-comment">// mangled type name, e.g. &quot;.H&quot; = &quot;int&quot;, &quot;.?AUA@@&quot; = &quot;struct A&quot;, &quot;.?AVA@@&quot; = &quot;class A&quot;</span><br>  <span class="hljs-type">char</span> name[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-3-throw结构定义"><a href="#2-3-throw结构定义" class="headerlink" title="2.3 throw结构定义"></a>2.3 throw结构定义</h3><h4 id="2-3-1-ThrowInfo"><a href="#2-3-1-ThrowInfo" class="headerlink" title="2.3.1 ThrowInfo"></a>2.3.1 ThrowInfo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThrowInfo</span> &#123;<br>      <span class="hljs-comment">// 0x01: const, 0x02: volatile</span><br>      DWORD attributes;<br><br>      <span class="hljs-comment">// 抛出异常对象的析构函数地址</span><br>      <span class="hljs-built_in">void</span> (*pmfnUnwind)();<br><br>      <span class="hljs-comment">// forward compatibility handler</span><br>      <span class="hljs-built_in">int</span> (*pForwardCompat)();<br><br>      <span class="hljs-comment">// catch块类型结构数组指针</span><br>      CatchableTypeArray* pCatchableTypeArray;<br>    &#125;;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CatchableTypeArray</span> &#123;<br>      <span class="hljs-comment">// number of entries in the following array</span><br>      <span class="hljs-type">int</span> nCatchableTypes; <br>      CatchableType* arrayOfCatchableTypes[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-CatchableTypeArray"><a href="#2-3-2-CatchableTypeArray" class="headerlink" title="2.3.2 CatchableTypeArray"></a>2.3.2 CatchableTypeArray</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CatchableTypeArray</span> &#123;<br>    <span class="hljs-comment">// 下面数组元素个数</span><br>    <span class="hljs-type">int</span> nCatchableTypes; <br>    <span class="hljs-comment">// catch类型信息</span><br>    CatchableType* arrayOfCatchableTypes[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-3-3-CatchableType"><a href="#2-3-3-CatchableType" class="headerlink" title="2.3.3 CatchableType"></a>2.3.3 CatchableType</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CatchableType</span> &#123;<br>      <span class="hljs-comment">// 0x01: simple type (can be copied by memmove), 0x02: can be caught by reference only, 0x04: has virtual bases</span><br>      DWORD properties;<br><br>      <span class="hljs-comment">// RTTI类型信息，catch块就是比较这个结构</span><br>      TypeDescriptor* pType;<br><br>      <span class="hljs-comment">// 基类信息</span><br>      PMD thisDisplacement;<br><br>      <span class="hljs-comment">// 抛出对象的字节大小</span><br>      <span class="hljs-type">int</span> sizeOrOffset;<br><br>      <span class="hljs-comment">// 抛出对象的拷贝构造函数地址</span><br>      <span class="hljs-built_in">void</span> (*copyFunction)();<br>&#125;;<br><br>    <span class="hljs-comment">// Pointer-to-member descriptor.</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PMD</span> &#123;<br>      <span class="hljs-comment">// 基类偏移</span><br>      <span class="hljs-type">int</span> mdisp;<br><br>      <span class="hljs-comment">// 虚基类偏移 （-1表示没有）</span><br>      <span class="hljs-type">int</span> pdisp;<br><br>      <span class="hljs-comment">// 基类虚表偏移</span><br>      <span class="hljs-type">int</span> vdisp;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-示例分析"><a href="#3-示例分析" class="headerlink" title="3. 示例分析"></a>3. 示例分析</h2><h3 id="3-1-try-x2F-catch块分析"><a href="#3-1-try-x2F-catch块分析" class="headerlink" title="3.1 try&#x2F;catch块分析"></a>3.1 try&#x2F;catch块分析</h3><p>函数头部：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002163402049.png" alt="异常回调函数注册"></p><p>异常处理函数体：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002163804479.png" alt="注册异常"></p><p>函数信息结构内容：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002164324887.png" alt="FuncInfo结构"></p><p>可以看出main函数中有2个栈展开结构，1一个try块。</p><p>其中，栈展开信息内容如下：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002165850690.png" alt="UnwindMapEntry结构"></p><p>try块信息如下：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002165920882.png" alt="TryBlockMapEntry结构"></p><p>可以看出该try块对应2个catch异常处理。</p><p>pHandlerArray信息如下：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002171219284.png" alt="HandlerType数组"></p><p>其中，catch_code1和catch_code2就是编写的catch块内的异常处理代码，如下所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002171302166.png" alt="异常处理代码1"></p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002171335263.png" alt="异常处理代码2"></p><h3 id="3-2-回调注册分析–对象类型异常"><a href="#3-2-回调注册分析–对象类型异常" class="headerlink" title="3.2 回调注册分析–对象类型异常"></a>3.2 回调注册分析–对象类型异常</h3><p>__CxxFrameHandler3函数将参数向下传递。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002222308026.png" alt="__CxxFrameHandler3"></p><p>__InternalCxxFrameHandler函数主要是对一些信息进行校验，然后调用FindHandler函数查找try&#x2F;catch块。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002222149322.png" alt="__InternalCxxFrameHandler"></p><p>FindHandler函数中使用三层循环对try块的范围进行校验，并将符合要求的try与catch进行类型比对，比对成功调用CatchIt完成异常处理。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002224707704.png" alt="FindHandler"></p><p>__TypeMatch函数中使用strcmp比较了RTTI的name字符串。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002224551011.png" alt="__TypeMatch"></p><p>CatchIt函数中主要是处理异常对象、执行栈展开、执行catch块。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003154623042.png" alt="CatchIt"></p><p>其中栈展开调用了如下API：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002230309773.png" alt="栈展开API"></p><p>之后循环调用UnwindMapEntry.action完成局部对象的析构。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003153615756.png" alt="执行action"></p><p>最终执行catch块代码，完成异常处理。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002230512362.png" alt="catch块执行"></p><p>在catch块代码执行完后，会将eax修改为catch块结束位置，返回给上一层函数。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003151051042.png" alt="设置eax"></p><p>最终由JumpToContinuation函数跳转到catch块结束位置完成异常处理。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003151150445.png" alt="JumpToContinuation函数"></p><h3 id="3-3-throw过程分析"><a href="#3-3-throw过程分析" class="headerlink" title="3.3 throw过程分析"></a>3.3 throw过程分析</h3><p>异常对象抛出位置，可以看到ThrowInfo作为参数传递。<strong>如果抛出的是对象类型的异常，这里会调用它的构造函数。</strong></p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002175014250.png" alt="抛出异常位置"></p><p>相关结构信息如下：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221002175156338.png" alt="抛出异常结构"></p><p>根据上述信息可以看出抛出的异常类型为 基本类型 ，可以被char*、void*类型的catch块捕获。</p><p>在__CxxThrowException函数中调用API向内核抛出异常。</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003151505632.png" alt="API抛异常"></p><p>之后就是内核对异常的处理，实现方式由系统决定。</p><h2 id="4-x64异常处理"><a href="#4-x64异常处理" class="headerlink" title="4.x64异常处理"></a>4.x64异常处理</h2><p>​x64中几乎每个函数都存在一个RUNTIME_FUNCTION结构（除了不操作rsp、没有异常处理的函数、不会调用其他函数），保存在pe文件的.pdata段。从这个结构出发可以找到UNWIND_INFO，最终找到FuncInfo结构，需要注意的是x64下指针位置都是RVA，需要加上ImageBase来定位真实地址。</p><h3 id="4-1-结构定义"><a href="#4-1-结构定义" class="headerlink" title="4.1  结构定义"></a>4.1  结构定义</h3><h4 id="4-1-1-RUNTIME-FUNCTION"><a href="#4-1-1-RUNTIME-FUNCTION" class="headerlink" title="4.1.1 RUNTIME_FUNCTION"></a>4.1.1 RUNTIME_FUNCTION</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 该结构在内存中必须4字节对齐</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_RUNTIME_FUNCTION</span> &#123;<span class="hljs-comment">// 均为RVA</span><br>        ULONG BeginAddress;<span class="hljs-comment">// 函数起始地址</span><br>        ULONG EndAddress;<span class="hljs-comment">// 函数结束地址</span><br>        ULONG UnwindData;<span class="hljs-comment">// UNWIND_INFO指针</span><br>&#125; RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;<br></code></pre></td></tr></table></figure><h4 id="4-1-2-UNWIND-INFO"><a href="#4-1-2-UNWIND-INFO" class="headerlink" title="4.1.2 UNWIND_INFO"></a>4.1.2 UNWIND_INFO</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_UNWIND_INFO</span> &#123;<span class="hljs-comment">// 均为RVA</span><br>        UCHAR Version : <span class="hljs-number">3</span>;<span class="hljs-comment">// 结构体版本号</span><br>        UCHAR Flags : <span class="hljs-number">5</span>;<span class="hljs-comment">// 异常处理信息</span><br>        UCHAR SizeOfProlog;<span class="hljs-comment">// 函数序言部分大小</span><br>        UCHAR CountOfCodes;<span class="hljs-comment">// 后面跟随的 UNWIND_CODE 结构所占的字节数</span><br>        UCHAR FrameRegister : <span class="hljs-number">4</span>;<span class="hljs-comment">// 帧寄存器</span><br>        UCHAR FrameOffset : <span class="hljs-number">4</span>;<span class="hljs-comment">// 帧寄存器偏移量</span><br>        UNWIND_CODE UnwindCode[<span class="hljs-number">1</span>];<span class="hljs-comment">// UNWIND_CODE数组</span><br>    <br>    ULONG FunctionEntry;<span class="hljs-comment">// CxxFrameHandler3地址</span><br>    ULONG ExceptionData;<span class="hljs-comment">// FuncInfo结构的rva</span><br>    <br>    <br>&#125; UNWIND_INFO, *PUNWIND_INFO;<br><br>Flag：<br>        <span class="hljs-built_in">UNW_FLAG_NHANDLER</span> (<span class="hljs-number">0x0</span>):  表示既没有 EXCEPT_FILTER 也没有 <span class="hljs-function">EXCEPT_HANDLER</span><br><span class="hljs-function">      <span class="hljs-title">UNW_FLAG_EHANDLER</span> <span class="hljs-params">(<span class="hljs-number">0x1</span>)</span>:  表示该函数有 EXCEPT_FILTER &amp; EXCEPT_HANDLER</span><br><span class="hljs-function">     UNW_FLAG_UHANDLER (<span class="hljs-number">0x2</span>): 表示该函数有 FINALLY_HANDLER</span><br><span class="hljs-function">      UNW_FLAG_CHAININFO (<span class="hljs-number">0x4</span>): 表示该函数有多个 UNWIND_INFO，它们串接在一起（所谓的 chain）</span><br></code></pre></td></tr></table></figure><h4 id="4-1-3-UNWIND-CODE"><a href="#4-1-3-UNWIND-CODE" class="headerlink" title="4.1.3 UNWIND_CODE"></a>4.1.3 UNWIND_CODE</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> <span class="hljs-title class_">_UNWIND_CODE</span> &#123;<br>    <span class="hljs-keyword">struct</span> &#123;<br>        UCHAR CodeOffset;<span class="hljs-comment">// 回滚位置距离函数入口的偏移</span><br>        UCHAR UnwindOp : <span class="hljs-number">4</span>;<span class="hljs-comment">// 对应下面的枚举，表示栈回滚类型</span><br>        UCHAR OpInfo : <span class="hljs-number">4</span>;<span class="hljs-comment">// 归滚操作的具体信息，如栈提升多少个字节</span><br>    &#125;;<br>    USHORT FrameOffset;<br>&#125; UNWIND_CODE, *PUNWIND_CODE;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">_UNWIND_OP_CODES</span> &#123;<br>        UWOP_PUSH_NONVOL = <span class="hljs-number">0</span>,   <span class="hljs-comment">// 0压入非易失寄存器，操作信息是寄存器编号</span><br>        UWOP_ALLOC_LARGE,       <span class="hljs-comment">// 1堆栈中分配一个大区域，操作信息为0时，分配大小除以8放在下一个字节上；1时，未缩放的大小放在之后的两个字节上</span><br>        UWOP_ALLOC_SMALL,       <span class="hljs-comment">// 2堆栈中分配一个小区域，操作信息为分配大小除以8再减去1</span><br>        UWOP_SET_FPREG,         <span class="hljs-comment">// 3通过将寄存器设置为当前 RSP 的某个偏移量来建立帧指针寄存器，操作信息为偏移量除以16</span><br>        UWOP_SAVE_NONVOL,       <span class="hljs-comment">// 4使用mov指令保存非易失寄存器，操作信息为寄存器编号</span><br>        UWOP_SAVE_NONVOL_FAR,   <span class="hljs-comment">// 5使用mov指令保存长偏移非易失寄存器，操作信息为寄存器编号，未缩放的堆栈偏移保存在后两个字节</span><br>        UWOP_SPARE_CODE1,       <span class="hljs-comment">// 6</span><br>        UWOP_SPARE_CODE2,       <span class="hljs-comment">// 7</span><br>        UWOP_SAVE_XMM128,       <span class="hljs-comment">// 8堆栈上保存xmm寄存器，操作信息为寄存器编号</span><br>        UWOP_SAVE_XMM128_FAR,   <span class="hljs-comment">// 9堆栈上保存长偏移xmm寄存器，操作信息为寄存器编号</span><br>        UWOP_PUSH_MACHFRAME     <span class="hljs-comment">// 10硬件中断相关</span><br>&#125; UNWIND_OP_CODES, *PUNWIND_OP_CODES;<br></code></pre></td></tr></table></figure><h4 id="4-1-3-FuncInfo变化"><a href="#4-1-3-FuncInfo变化" class="headerlink" title="4.1.3 FuncInfo变化"></a>4.1.3 FuncInfo变化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// x64函数信息结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FuncInfo</span> &#123;<span class="hljs-comment">// RVA</span><br>    <span class="hljs-comment">// 编译器版本号</span><br>    <span class="hljs-comment">// 0x19930520: up to VC6, 0x19930521: VC7.x(2002-2003), 0x19930522: VC8 (2005)</span><br>    DWORD magicNumber;<br><br>    <span class="hljs-comment">// 最大栈展开数的下标</span><br>    <span class="hljs-type">int</span> maxState;<br><br>    <span class="hljs-comment">// 栈展开结构数组指针</span><br>    UnwindMapEntry* pUnwindMap;<br><br>    <span class="hljs-comment">// 函数中try块个数</span><br>    DWORD nTryBlocks;<br><br>    <span class="hljs-comment">// try块结构数组指针</span><br>    TryBlockMapEntry* pTryBlockMap;<br><br>    <span class="hljs-comment">// IP映射表的数量</span><br>    DWORD nIPMapEntries;<br><br>    <span class="hljs-comment">// IP映射表的RVA，指向IPtoStateMapEntry结构</span><br>    <span class="hljs-type">void</span>* pIPtoStateMap;<br><br>    <span class="hljs-comment">// 异常展开帮助RVA</span><br>    UnWindMapEntry* pUnWindMapEntry;<br>    <br>    <span class="hljs-comment">// 异常类型列表RVA</span><br>    ESTypeList* pESTypeList;<br><br>    <span class="hljs-comment">// 一些功能标志</span><br>    <span class="hljs-type">int</span> EHFlags;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-1-4-IptoStateMapEntry"><a href="#4-1-4-IptoStateMapEntry" class="headerlink" title="4.1.4 IptoStateMapEntry"></a>4.1.4 IptoStateMapEntry</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IptoStateMapEntry</span> &#123;<br>    ULONG __Ip;<span class="hljs-comment">// try块起始rip的RVA</span><br>    ULONG State;<span class="hljs-comment">// try块状态索引</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-2-结构关系图"><a href="#4-2-结构关系图" class="headerlink" title="4.2  结构关系图"></a>4.2  结构关系图</h3><p>​x86应用程序中，使用栈空间的一个变量标 识try块的状态索引，在x64中不再使用该变量，而是通过产生异常的 地址（RIP）查询IP状态映射表来获取try块的状态索引，结构如下图所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003172703707.png" alt="FuncInfo结构关系"></p><h3 id="4-3-示例分析"><a href="#4-3-示例分析" class="headerlink" title="4.3  示例分析"></a>4.3  示例分析</h3><p>查看main函数的交叉引用可以定位到它的RUNTIME_FUNCTION结构，如下图所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003173146049.png" alt="定位RUNTIME_FUNCTIONJ结构"></p><p>根据RUNTIME_FUNCTION的第三个成员定位到UNWIND_INFO结构，如下图所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003173320384.png" alt="定位UNWIND_INFO"></p><p>UNWIND_INFO结构信息如下：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003173410710.png" alt="UNWIND_INFO信息"></p><p>根据rva定位到FuncInfo结构，如下图所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003173530359.png" alt="定位FuncInfo"></p><p>进而定位到TryBlockMapEntry数组以及HandlerType数组，得到try1的索引为0~0，如下图所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003173713036.png" alt="定位TryBlockMapEntry"></p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003173740699.png" alt="定位HandlerType"></p><p>最终定位到catch块地址，如下图所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003173901686.png" alt="catch块地址"></p><p>根据FuncInfo定位IP状态表，如下图所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003180040935.png" alt="IP状态表"></p><p>根据try1的索引0<del>0可以在IP表中确定边界为0x1400A8BC9</del>0x1400A8BEB，验证如下：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003180205523.png" alt="try范围"></p><p>catch1的范围为0x1401DC1B4<del>0x1401DC1ED，catch2的范围为0x1401DC210</del>0x1401DC249，如下图所示：</p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003180346164.png" alt="catch1范围"></p><p><img src="/2022/10/02/c-yi-chang-chu-li/image-20221003180427885.png" alt="catch2范围"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ul><li>基于Windows SEH实现，在函数头部构造异常链，以及异常处理回调函数的注册。</li><li>异常处理结构信息在编译阶段生成好。</li><li>throw调用了Windows API来完成异常的抛出。</li><li>类型识别基于RTTI实现，本质就是编译器生成的类型字符串，使用strcmp比对来寻找合适的catch进行执行。</li><li>栈展开机制是在当前函数中找不到catch时，需要向上层函数寻找时被触发，展开过程需要调用局部对象的析构函数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常见问题整理</title>
      <link href="/2022/10/01/c-chang-jian-wen-ti-hui-zong/"/>
      <url>/2022/10/01/c-chang-jian-wen-ti-hui-zong/</url>
      
        <content type="html"><![CDATA[<h2 id="1-关键字"><a href="#1-关键字" class="headerlink" title="1.关键字"></a>1.关键字</h2><h3 id="1-1-const"><a href="#1-1-const" class="headerlink" title="1.1 const"></a>1.1 const</h3><p><strong>底层const指针：</strong>可以修改指向，不可以改值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> dwVal1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> dwVal2 = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p1 = &amp;dwVal1;<br><br>p1 = &amp;dwVal2;<span class="hljs-comment">// 正确</span><br>*p1 = <span class="hljs-number">5</span>;<span class="hljs-comment">// 不正确</span><br></code></pre></td></tr></table></figure><p><strong>底层const指针：</strong>可以改值，不可以改指向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> dwVal1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> dwVal2 = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p1 = &amp;dwVal1;<br><br>p1 = &amp;dwVal2;<span class="hljs-comment">// 不正确</span><br>*p1 = <span class="hljs-number">5</span>;<span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><p><strong>成员函数指针：</strong>表示这个函数不会修改成员变量的内容，mutable关键字修饰的成员变量除外，同时该函数不能被static关键字修饰。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">m_fun1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>m_dwVal1 = <span class="hljs-number">5</span>;<span class="hljs-comment">// 错误</span><br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_dwVal1;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-2-static"><a href="#1-2-static" class="headerlink" title="1.2 static"></a>1.2 static</h3><p>static本质与全局符号的概念一致，只是在语法层面存在细微差别。</p><ul><li>修饰全局变量：语法层面限制该变量只在当前文件内有效。</li><li>修饰全局函数：语法层面限制该函数只在当前文件内有效。</li><li>修饰局部变量：语法层面用来扩展栈变量的生命周期。</li><li>修饰成员变量：语法层面表示多个对象中共享数据，可以通过类名访问，需要在类外初始化，可以被普通成员函数访问。</li><li>修饰成员函数：语法层面可以被类名直接调用，不传递this指针，不能访问普通成员变量。</li></ul><h3 id="1-3-virtual"><a href="#1-3-virtual" class="headerlink" title="1.3 virtual"></a>1.3 virtual</h3><p>用于声明一个类成员函数为虚函数。存在虚函数的类对象，首个成员固定为一个指针，指向该类的虚函数表。</p><p>当父类指针指向子类对象，子类重写父类虚函数，此时虚函数会以指针寻址的方式动态调用，构成多态性。</p><p>构造函数中完成虚表指针的初始化，所以构造函数不能被定义为虚函数。</p><p><strong>析构函数声明为虚函数的原因：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Base* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br><span class="hljs-keyword">delete</span> p;<br></code></pre></td></tr></table></figure><p>如果析构函数不为虚函数，上面的代码会只调用父类的析构函数，子类的对象没有被正确释放。</p><p>当析构函数声明为虚函数时，会在子类虚函数表中找到子类的析构函数进行调用，先析构子类再析构父类，整个派生类被完全释放。</p><p><img src="/2022/10/01/c-chang-jian-wen-ti-hui-zong/image-20221001164349840.png" alt="析构函数对比图"></p><h3 id="1-4-volatile"><a href="#1-4-volatile" class="headerlink" title="1.4 volatile"></a>1.4 volatile</h3><p>告诉编译器，这个变量的值需要每次都从内存中去读取，不允许暂存到寄存器中，可以用在多线程对某个全局标志的访问时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-type">int</span> g_Flag = <span class="hljs-number">0</span>;<br><br><span class="hljs-function">DWORD <span class="hljs-title">ThreadProc1</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">LPVOID lpThreadParameter</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br>g_Flag = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (g_Flag) &#123;&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">DWORD <span class="hljs-title">ThreadProc2</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">LPVOID lpThreadParameter</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>::<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">5000</span>);<br>g_Flag = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>HANDLE hThread1 = ::<span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)ThreadProc1, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>HANDLE hThread2 = ::<span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)ThreadProc2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码在Release版编译下，会死循环，汇编如下：</p><p><img src="/2022/10/01/c-chang-jian-wen-ti-hui-zong/image-20221001171456415.png" alt="死循环"></p><p>在将g_Flag使用volatile修饰后，不会产生死循环，汇编代码如下：</p><p><img src="/2022/10/01/c-chang-jian-wen-ti-hui-zong/image-20221001171816455.png" alt="修复死循环"></p><h3 id="1-5-explict"><a href="#1-5-explict" class="headerlink" title="1.5 explict"></a>1.5 explict</h3><p>用于修饰类构造函数，不允许对象发生隐式类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A::constor\n&quot;</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a = <span class="hljs-number">2</span>;<span class="hljs-comment">// 错误</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-字节对齐"><a href="#2-字节对齐" class="headerlink" title="2.字节对齐"></a>2.字节对齐</h2><h3 id="2-1-规则"><a href="#2-1-规则" class="headerlink" title="2.1 规则"></a>2.1 规则</h3><ul><li>结构体成员：第一个成员放在offset为0的位置，之后的每个数据成员按照#pragma pack指定的数值和sizeof()中的较小值进行对齐。</li><li>结构体总体：总大小按照#pragma pack指定的数值和sizeof()中的较小值进行对齐。</li></ul><h3 id="2-2-原因"><a href="#2-2-原因" class="headerlink" title="2.2 原因"></a>2.2 原因</h3><ul><li><p>平台原因：某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p></li><li><p>性能原因：访问未对齐的内存，处理器需要作两次访问；而访问对齐的内存仅需要一次访问。</p><p>如int类型的四字节存储在0x1地址上，cpu需要首先从0x0位置读4字节，舍去0x0这1个字节，再从0x4位置读4字节，舍去0x5开始的3个字节，最终拼接得到最终结果。</p></li></ul><h2 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3.类型转换"></a>3.类型转换</h2><ul><li><p>const_cast</p><p>用于对指针或引用去const属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* pCa = &amp;a;<br><span class="hljs-comment">// *p = 10;// 错误</span><br><span class="hljs-comment">// b= 20;// 错误</span><br><span class="hljs-type">int</span>* pa = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(pCa);<span class="hljs-comment">// 指针去const</span><br><span class="hljs-type">int</span>&amp; rb = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(b);<span class="hljs-comment">// 引用去const</span><br><br>*pa = <span class="hljs-number">10</span>;<span class="hljs-comment">// 正确</span><br>rb = <span class="hljs-number">20</span>;<span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure></li><li><p>static_cast</p><p>与C风格强制类型转换基本一样，不存在运行时类型检查。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">float fVal1 <span class="hljs-operator">=</span> <span class="hljs-number">3.1415926</span>f<span class="hljs-comment">;</span><br>int dwVal2 <span class="hljs-operator">=</span> static_cast&lt;int&gt;(fVal1)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>dynamic_cast</p><p>具有运行时类型检查，可以防止在具有虚函数的派生关系中，将父类对象地址交给子类指针，会返回NULL。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Base *base = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base</span>();<br>Sub  *pSub = <span class="hljs-built_in">dynamic_cast</span>&lt;Sub*&gt;(base);<span class="hljs-comment">// 转换失败，此时pSub为NULL</span><br><span class="hljs-keyword">if</span>(pSub != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-comment">// do something.</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>reinterpret_cast</p><p>对要转换的二进制流重新解释，常用于指针与整数之间的转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-title">Hash</span><span class="hljs-params">(<span class="hljs-type">void</span> *p)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(p);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)(val ^ (val &gt;&gt; <span class="hljs-number">16</span>));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征码搜索</title>
      <link href="/2022/09/23/te-zheng-ma-sou-suo/"/>
      <url>/2022/09/23/te-zheng-ma-sou-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Sunday字符串搜索算法"><a href="#1-Sunday字符串搜索算法" class="headerlink" title="1.Sunday字符串搜索算法"></a>1.Sunday字符串搜索算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">String2Bytes</span><span class="hljs-params">(<span class="hljs-type">char</span>* szSrc, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>* szDst)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>WORD TzmLength = <span class="hljs-built_in">strlen</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)szSrc) / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//将十六进制特征码转为十进制</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)szSrc); )<br>&#123;<br><span class="hljs-type">char</span> num[<span class="hljs-number">2</span>];<br>num[<span class="hljs-number">0</span>] = szSrc[i++];<br>num[<span class="hljs-number">1</span>] = szSrc[i++];<br>i++;<br><span class="hljs-keyword">if</span> (num[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;?&#x27;</span> &amp;&amp; num[<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;?&#x27;</span>)<br>&#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>WORD a[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (num[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; num[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br>a[i] = num[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; num[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>&#123;<br>a[i] = num[i] - <span class="hljs-number">87</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; num[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)<br>&#123;<br>a[i] = num[i] - <span class="hljs-number">55</span>;<br>&#125;<br><br>&#125;<br>sum = a[<span class="hljs-number">0</span>] * <span class="hljs-number">16</span> + a[<span class="hljs-number">1</span>];<br>szDst[len++] = sum;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>szDst[len++] = <span class="hljs-number">256</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> TzmLength;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SundayStrSearch</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* szSrc, <span class="hljs-type">char</span>* szDst, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; vRes)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">size_t</span> sSrc = <span class="hljs-built_in">strlen</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)szSrc);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>* pDst = (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span> * (<span class="hljs-built_in">strlen</span>(szDst) / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>));<br><span class="hljs-type">size_t</span> sDst = <span class="hljs-built_in">String2Bytes</span>(szDst, pDst);<br><br><span class="hljs-comment">// 构造Next数组</span><br><span class="hljs-type">short</span> szNext[<span class="hljs-number">260</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">260</span>; i++)<br>szNext[i] = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sDst; i++)<br>szNext[pDst[i]] = i;<br><br><span class="hljs-comment">// 字符串匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j, k; i &lt; sSrc;)<br>&#123;<br>j = i; k = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (; k &lt; sDst &amp;&amp; j &lt; sSrc &amp;&amp; (pDst[k] == szSrc[j] || pDst[k] == <span class="hljs-number">256</span>); k++, j++);<br><br><span class="hljs-keyword">if</span> (k == sDst)<br>&#123;<br>vRes.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">size_t</span>)(i + sDst) &gt;= sSrc)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-type">int</span> num = szNext[szSrc[sDst + i]];<br><span class="hljs-keyword">if</span> (num == <span class="hljs-number">-1</span>)<br>i += (sDst - szNext[<span class="hljs-number">256</span>]);<br><span class="hljs-keyword">else</span><br>i += (sDst - num);<br>&#125;<br><span class="hljs-keyword">if</span> (pDst)<br>&#123;<br><span class="hljs-built_in">free</span>(pDst);<br>pDst = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> pSrc[] = <br>&#123;<br><span class="hljs-number">0xFF</span>, <span class="hljs-number">0x87</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0x00</span><br>&#125;;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br><span class="hljs-built_in">SundayStrSearch</span>(pSrc, <span class="hljs-string">&quot;88 ?? 67&quot;</span>, res);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); i++)<br>cout &lt;&lt; res[i] &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> lib </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类逆向</title>
      <link href="/2022/09/14/class-reverse/"/>
      <url>/2022/09/14/class-reverse/</url>
      
        <content type="html"><![CDATA[<h2 id="1-对象内存布局"><a href="#1-对象内存布局" class="headerlink" title="1.对象内存布局"></a>1.对象内存布局</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span>: <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>    &#123;<br>        <span class="hljs-comment">// 虚表指针</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Base_vtable</span>*<br>    <span class="hljs-comment">// 父类成员结构</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Base_member</span><br>        &#123;<br>            <span class="hljs-type">int</span> m_iVal1;<br>            <span class="hljs-type">char</span> m_cVal2;<br>        &#125;;<br>    &#125;;<br>    <span class="hljs-comment">// 子类自身成员结构</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">A1_member</span><br>    &#123;<br>        <span class="hljs-type">float</span> m_fVal1;<br>        <span class="hljs-type">char</span>* m_pcVal2;<br>    &#125;;<br>&#125;;<br><br><span class="hljs-comment">// Base虚表结构</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base_vtable</span><br>&#123;<br>   int64 fun1;<br>   int64 fun2;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-1-基本类"><a href="#1-1-基本类" class="headerlink" title="1.1 基本类"></a>1.1 基本类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">short</span> z)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br><span class="hljs-keyword">this</span>-&gt;z = z;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; x &lt;&lt; std::endl;<br>std::cout &lt;&lt; y &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">char</span> y;<br><span class="hljs-type">short</span> z;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-function">A1 <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>)</span></span>;<br>a1.<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于基本类，从对象创建的地方找到构造函数，根据结构偏移使用情况来确定边界和成员类型，并在之后分析过程中不断修改完善。</p><p><strong>结构体定义模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914173617123.png" alt="基本结构模板"></p><h3 id="1-2-组合类"><a href="#1-2-组合类" class="headerlink" title="1.2 组合类"></a>1.2 组合类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A2</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetX</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetY</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> y;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">float</span> x;<br><span class="hljs-type">float</span> y;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">short</span> z)<br>:<span class="hljs-built_in">a2</span>(<span class="hljs-number">3.2</span>, <span class="hljs-number">4.3</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;y[i] = i+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;z = z;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; x &lt;&lt; std::endl;<br>std::cout &lt;&lt; y &lt;&lt; std::endl;<br><br>std::cout &lt;&lt; y[<span class="hljs-number">5</span>] &lt;&lt; std::endl;<br><br>std::cout &lt;&lt; a2.<span class="hljs-built_in">GetX</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; a2.<span class="hljs-built_in">GetY</span>() &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">char</span> y[<span class="hljs-number">20</span>];<br><span class="hljs-type">short</span> z;<br>A2 a2;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-function">A1 <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>)</span></span>;<br>a1.<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>组合类在分析的时候可以看见很明显的特征，就是在class1的构造函数中会将 this + x 的地址传入class2的构造函数中进行初始化，这个偏移x的位置就是class2的起始位置。</p><p><img src="/2022/09/14/class-reverse/image-20220914104738064.png" alt="组合类特征"></p><p><strong>结构体定义模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914173829653.png" alt="组合类结构模板"></p><h3 id="1-3-单继承类"><a href="#1-3-单继承类" class="headerlink" title="1.3 单继承类"></a>1.3 单继承类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A2</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> len)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>(len);<br><span class="hljs-built_in">strcpy</span>(b, <span class="hljs-string">&quot;Base&quot;</span>);<br>&#125;<br>~<span class="hljs-built_in">A2</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;b)<br>&#123;<br><span class="hljs-built_in">free</span>(<span class="hljs-keyword">this</span>-&gt;b);<br><span class="hljs-keyword">this</span>-&gt;b = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">char</span> *b;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>: <span class="hljs-keyword">public</span> A2<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">short</span> c)<br>:<span class="hljs-built_in">A2</span>(<span class="hljs-number">8</span>, <span class="hljs-number">12</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br><span class="hljs-keyword">this</span>-&gt;c = c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">encrypt</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> key + b[<span class="hljs-number">3</span>] + b[<span class="hljs-number">5</span>] * arr[<span class="hljs-number">1</span>] / a + c;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">short</span> c;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-function">A1 <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span></span>;<br>std::cout &lt;&lt; a.<span class="hljs-built_in">encrypt</span>(<span class="hljs-number">10</span>) &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于继承关系的类识别，可以看构造函数中是否有将原始this指针直接传递给父类构造函数的操作。实际上在不含有虚函数的继承关系中，可以把子类和父类合并来看待。<strong>普通继承关系实际上就是把父类的成员原封不动的拷贝过来，作为子类对象结构开头的一部分。</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914113639610.png" alt="继承关系特征"></p><p><strong>结构体定义标准模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914165807726.png" alt="单继承结构模板"></p><h3 id="1-4-多继承类"><a href="#1-4-多继承类" class="headerlink" title="1.4 多继承类"></a>1.4 多继承类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TopBase</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">TopBase</span>(<span class="hljs-type">int</span> id, <span class="hljs-type">char</span>* name)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;dwId = id;<br><span class="hljs-keyword">this</span>-&gt;sName = name;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> dwId;<br><span class="hljs-type">char</span>* sName;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mid1</span><br>:<span class="hljs-keyword">public</span> TopBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Mid1</span>(<span class="hljs-type">int</span> age)<br>:<span class="hljs-built_in">TopBase</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;jack&quot;</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;age = age;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mid2</span><br>:<span class="hljs-keyword">public</span> TopBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Mid2</span>(<span class="hljs-type">char</span> high)<br>:<span class="hljs-built_in">TopBase</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;tom&quot;</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;high = high;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">char</span> high;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bottom</span><br>:<span class="hljs-keyword">public</span> Mid1, Mid2<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Bottom</span>(<span class="hljs-type">char</span>* grade, <span class="hljs-type">char</span>* name)<br>:<span class="hljs-built_in">Mid1</span>(<span class="hljs-number">20</span>), <span class="hljs-built_in">Mid2</span>(<span class="hljs-number">185</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;grade = grade;<br><span class="hljs-keyword">this</span>-&gt;sName = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; age &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span>* grade;<br><span class="hljs-type">char</span>* sName;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Bottom <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-string">&quot;100&quot;</span>, <span class="hljs-string">&quot;xiaoming&quot;</span>)</span></span>;<br>obj.<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>继承关系呈现菱形结构，就是有两个类继承自同一个类，同时又有另外一个类同时继承自这两个。多重继承会在子类中出现<strong>多个父类的members结构</strong>，并根据先后顺序排列，可以从最上层依次分析，逐渐向下递进，直至分析出继承树结构。</p><p><strong>多重继承结构体定义标准模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914173422053.png" alt="多重继承结构定义模板"></p><h3 id="1-4-虚表类"><a href="#1-4-虚表类" class="headerlink" title="1.4 虚表类"></a>1.4 虚表类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base1</span>(<span class="hljs-type">char</span>* str)<br>&#123;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str);<br>pa = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len];<br><span class="hljs-built_in">strcpy</span>(pa, str);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Base1&quot;</span> &lt;&lt; std::endl;<br>std::cout &lt;&lt; pa &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base1</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (pa)<br>&#123;<br><span class="hljs-built_in">free</span>(pa);<br>pa = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">char</span>* pa;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base2</span>(<span class="hljs-type">int</span> a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base2</span>()<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;destory Base2&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> a;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>:<span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>()<br>:<span class="hljs-built_in">Base1</span>(<span class="hljs-string">&quot;Hello&quot;</span>), <span class="hljs-built_in">Base2</span>(<span class="hljs-number">5</span>)<br>&#123;<br><span class="hljs-built_in">strcpy</span>(buf, <span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;A1&quot;</span> &lt;&lt; std::endl;<br>std::cout &lt;&lt; buf &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">A1</span>()<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;A1 destory&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A1 a1;<br>Base1* p = &amp;a1;<br>p-&gt;<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>虚表指针属于基类，不属于子类，子类只是将其继承过来。</strong>所以在子类的结构中应包含父类的结构，在父类的结构中包含虚表结构和父类成员结构。多个父类结构在子类结构中顺序排列。</p><p><strong>多重继承虚表结构定义标准模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914162409783.png" alt="多重继承下的虚表结构模板"></p><h2 id="2-对象创建方式"><a href="#2-对象创建方式" class="headerlink" title="2.对象创建方式"></a>2.对象创建方式</h2><h3 id="2-1-局部对象"><a href="#2-1-局部对象" class="headerlink" title="2.1 局部对象"></a>2.1 局部对象</h3><p>局部对象是最常见的创建方式，反汇编可以看见直接将栈内存地址传给构造函数。</p><p><img src="/2022/09/14/class-reverse/image-20220914181153384.png" alt="局部对象创建"></p><h3 id="2-2-堆对象"><a href="#2-2-堆对象" class="headerlink" title="2.2 堆对象"></a>2.2 堆对象</h3><p>对象存在new关键字动态申请出来的内存中，反汇编可以看见直接将new得到的地址传入构造函数。</p><p><img src="/2022/09/14/class-reverse/image-20220914181409983.png" alt="堆对象创建"></p><h3 id="2-3-全局对象和静态对象"><a href="#2-3-全局对象和静态对象" class="headerlink" title="2.3 全局对象和静态对象"></a>2.3 全局对象和静态对象</h3><p>对于全局对象和静态对象，都是在.data段分配内存，区别就是静态对象说明对象作用域在当前文件中。识别全局对象的调用可以寻找 lea rcx, qword_xxx 指令。</p><p>全局对象的构造函数在main函数前完成，在 crt-&gt;initterm 中完成初始化。</p><p><img src="/2022/09/14/class-reverse/image-20220915114054354.png" alt="initterm"></p><p>可以在First到Last区间内找到所有的代理构造函数地址，代理构造函数负责调用构造函数完成初始化以及调用 atexit 函数来注册析构函数，以便在main函数结束后调用。</p><p><img src="/2022/09/14/class-reverse/image-20220915114452944.png" alt="代理构造函数"></p><h3 id="2-4-参数对象"><a href="#2-4-参数对象" class="headerlink" title="2.4 参数对象"></a>2.4 参数对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_dwVal1 = a;<br><span class="hljs-keyword">this</span>-&gt;m_cVal2[<span class="hljs-number">5</span>] = b;<br>&#125;<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">const</span> A1&amp; c)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_dwVal1 = c.m_dwVal1;<br><span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;m_cVal2, c.m_cVal2);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_dwVal1 &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_cVal2[<span class="hljs-number">8</span>] &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_dwVal1;<br><span class="hljs-type">char</span> m_cVal2[<span class="hljs-number">20</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(A1 arg)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; arg.m_cVal2[<span class="hljs-number">3</span>] &lt;&lt; std::endl;<br>arg.<span class="hljs-built_in">show</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-function">A1 <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-built_in">Show</span>(a1);<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用拷贝构造函数或直接复制对象空间内存来在参数区构造一个新的对象，并将新对象的内存首地址给调用的函数。</p><p><img src="/2022/09/14/class-reverse/image-20220915144147889.png" alt="参数对象传递"></p><h3 id="2-5-返回对象"><a href="#2-5-返回对象" class="headerlink" title="2.5 返回对象"></a>2.5 返回对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_dwVal1 = a;<br><span class="hljs-keyword">this</span>-&gt;m_cVal2[<span class="hljs-number">5</span>] = b;<br>&#125;<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">const</span> A1&amp; c)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_dwVal1 = c.m_dwVal1;<br><span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;m_cVal2, c.m_cVal2);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_dwVal1 &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_cVal2[<span class="hljs-number">8</span>] &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_dwVal1;<br><span class="hljs-type">char</span> m_cVal2[<span class="hljs-number">20</span>];<br>&#125;;<br><br><span class="hljs-function">A1 <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">A1 <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-keyword">return</span> a1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>A1 a1 = <span class="hljs-built_in">Show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对象作为返回值传递会先在调用之前将缓冲区首地址提前传进去（即使那个函数没有参数）。</p><p><img src="/2022/09/14/class-reverse/image-20220915145145190.png" alt="main函数"></p><p>在函数里面调用构造函数，在函数返回前根据传进来的上一个函数缓冲区的首地址和当前这个对象的首地址作为参数来调用拷贝构造函数。</p><p><img src="/2022/09/14/class-reverse/image-20220915145215817.png" alt="Show函数"></p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ida基础用法</title>
      <link href="/2022/09/13/ida-basic/"/>
      <url>/2022/09/13/ida-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="1-常用快捷键"><a href="#1-常用快捷键" class="headerlink" title="1.常用快捷键"></a>1.常用快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Shift + F12</td><td>打开字符串窗口</td></tr><tr><td>Y</td><td>改变函数原型或变量类型</td></tr><tr><td>D</td><td>宽度转换以及结构体中新增成员</td></tr><tr><td>R</td><td>字符转换</td></tr><tr><td>H</td><td>进制转换</td></tr><tr><td>&#x2F;</td><td>伪代码中添加注释</td></tr><tr><td>X</td><td>查看交叉引用</td></tr><tr><td>TAB</td><td>汇编指令和伪代码之间切换</td></tr><tr><td>Shift + E</td><td>得到数组</td></tr><tr><td>Alt + T</td><td>搜索字符串</td></tr><tr><td>Alt + I</td><td>搜索立即数</td></tr><tr><td>Alt + B</td><td>搜索二进制</td></tr><tr><td>Alt + P</td><td>修改函数边界</td></tr></tbody></table><h2 id="2-伪代码修复"><a href="#2-伪代码修复" class="headerlink" title="2.伪代码修复"></a>2.伪代码修复</h2><h3 id="2-1-逆向命名规则"><a href="#2-1-逆向命名规则" class="headerlink" title="2.1 逆向命名规则"></a>2.1 逆向命名规则</h3><h4 id="2-1-1-类型命名"><a href="#2-1-1-类型命名" class="headerlink" title="2.1.1 类型命名"></a><strong>2.1.1 类型命名</strong></h4><table><thead><tr><th>类型</th><th>前缀</th></tr></thead><tbody><tr><td>数组</td><td>a</td></tr><tr><td>布尔</td><td>b</td></tr><tr><td>字符byte</td><td>c</td></tr><tr><td>短整型word</td><td>w</td></tr><tr><td>整型dowrd</td><td>dw</td></tr><tr><td>整形qword</td><td>qw</td></tr><tr><td>指针</td><td>p</td></tr><tr><td>类成员</td><td>m_</td></tr><tr><td>字符串</td><td>sz</td></tr></tbody></table><h4 id="2-1-2-符号命名"><a href="#2-1-2-符号命名" class="headerlink" title="2.1.2 符号命名"></a><strong>2.1.2 符号命名</strong></h4><table><thead><tr><th>符号类型</th><th>规则</th><th>示例</th></tr></thead><tbody><tr><td>栈变量</td><td>类型前缀 + 名字</td><td>szWelcome</td></tr><tr><td>全局变量</td><td>g_类型前缀 + 名字</td><td>g_dwTime</td></tr><tr><td>普通函数</td><td>大功能 + 具体功能</td><td>memAlloc</td></tr><tr><td>成员函数</td><td>类名字::函数名</td><td>Student::getNum</td></tr></tbody></table><h3 id="2-2-不规则代码"><a href="#2-2-不规则代码" class="headerlink" title="2.2 不规则代码"></a>2.2 不规则代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">def <span class="hljs-title function_">LOBYTE</span><span class="hljs-params">(x)</span>:     <span class="hljs-keyword">return</span> x &amp; 0xff<br>def <span class="hljs-title function_">HIBYTE</span><span class="hljs-params">(x)</span>:     <span class="hljs-title function_">return</span> <span class="hljs-params">(x &gt;&gt; <span class="hljs-number">8</span>)</span> &amp; 0xff<br>def <span class="hljs-title function_">LOWORD</span><span class="hljs-params">(x)</span>:     <span class="hljs-keyword">return</span> x &amp; 0xffff<br>def <span class="hljs-title function_">HIWORD</span><span class="hljs-params">(x)</span>:     <span class="hljs-title function_">return</span> <span class="hljs-params">(x &gt;&gt; <span class="hljs-number">16</span>)</span> &amp; 0xffff<br>def <span class="hljs-title function_">LODWORD</span><span class="hljs-params">(x)</span>:    <span class="hljs-keyword">return</span> x &amp; 0xffffffff<br>def <span class="hljs-title function_">HIDWORD</span><span class="hljs-params">(x)</span>:    <span class="hljs-title function_">return</span> <span class="hljs-params">(x &gt;&gt; <span class="hljs-number">32</span>)</span> &amp; 0xffffffff<br></code></pre></td></tr></table></figure><h3 id="2-3-修复函数原型"><a href="#2-3-修复函数原型" class="headerlink" title="2.3 修复函数原型"></a>2.3 修复函数原型</h3><h4 id="2-3-1-返回值类型"><a href="#2-3-1-返回值类型" class="headerlink" title="2.3.1 返回值类型"></a>2.3.1 返回值类型</h4><p>​当分析出某个函数的返回值类型始终（交叉引用）不会被使用后，可以将函数原型的返回值类型改成void，可以优化掉多余代码。</p><h4 id="2-3-2-参数个数和类型"><a href="#2-3-2-参数个数和类型" class="headerlink" title="2.3.2 参数个数和类型"></a>2.3.2 参数个数和类型</h4><p>​在x64下，有些函数没有参数，但由于调用约定，F5后的伪代码中可能出现参数，将多余的参数删除，可以优化代码。而且有些参数是使用寄存器传递，如浮点寄存器，这时伪代码中可能无法正确识别，需要结合汇编分析，并手动添加参数，可以增加可读性。</p><h3 id="2-4-修复变量类型"><a href="#2-4-修复变量类型" class="headerlink" title="2.4 修复变量类型"></a>2.4 修复变量类型</h3><h4 id="2-4-1-结构体定义"><a href="#2-4-1-结构体定义" class="headerlink" title="2.4.1 结构体定义"></a>2.4.1 结构体定义</h4><p>​恢复结构体类型可以大大代码可读性，可以根据new的大小和分析成员使用情况来确定结构体边界和成员类型。下面展示类的结构定义模板：</p><p><img src="/2022/09/13/ida-basic/image-20220913182821578.png" alt="类结构模板"></p><h4 id="2-4-2-数组定义"><a href="#2-4-2-数组定义" class="headerlink" title="2.4.2 数组定义"></a>2.4.2 数组定义</h4><p>​对于连续的内存空间的操作，可以酌情还原为数组，增加可读性。</p><h2 id="3-符号还原"><a href="#3-符号还原" class="headerlink" title="3.符号还原"></a>3.符号还原</h2><h3 id="3-1-基于签名文件的符号还原"><a href="#3-1-基于签名文件的符号还原" class="headerlink" title="3.1 基于签名文件的符号还原"></a>3.1 基于签名文件的符号还原</h3><h3 id="3-2-基于Bindff的符号还原"><a href="#3-2-基于Bindff的符号还原" class="headerlink" title="3.2 基于Bindff的符号还原"></a>3.2 基于Bindff的符号还原</h3>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> ida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编指令基础</title>
      <link href="/2022/09/12/asm-basic/"/>
      <url>/2022/09/12/asm-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="1-EFLAGS"><a href="#1-EFLAGS" class="headerlink" title="1.EFLAGS"></a>1.EFLAGS</h2><p><img src="/2022/09/12/asm-basic/eflags.png" alt="eflags"></p><h2 id="2-测试与比较"><a href="#2-测试与比较" class="headerlink" title="2.测试与比较"></a>2.测试与比较</h2><h3 id="2-1-test"><a href="#2-1-test" class="headerlink" title="2.1 test"></a>2.1 test</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">test rax, rbx<br>; 等价形式如下<br>push rax<br>and rax, rbx<br>pop rax<br></code></pre></td></tr></table></figure><h3 id="2-2-cmp"><a href="#2-2-cmp" class="headerlink" title="2.2 cmp"></a>2.2 cmp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp rax, rbx<br>; 等价形式如下<br>push rax<br>sub rax, rbx<br>pop rax<br></code></pre></td></tr></table></figure><h2 id="3-跳转"><a href="#3-跳转" class="headerlink" title="3.跳转"></a>3.跳转</h2><h3 id="3-1-JCC条件跳转"><a href="#3-1-JCC条件跳转" class="headerlink" title="3.1 JCC条件跳转"></a>3.1 JCC条件跳转</h3><ul><li><strong>短跳：</strong>2字节，1字节硬编码 + 1字节有符号偏移</li><li><strong>长跳：</strong>6字节，2字节硬编码 + 4字节有符号地址</li></ul><table><thead><tr><th>指令</th><th>短跳</th><th>长跳</th><th>含义</th><th>EFLAGS</th></tr></thead><tbody><tr><td>JZ&#x2F;JE</td><td>0x74</td><td>0x0F 0x84</td><td>相等则跳转</td><td>ZF &#x3D;&#x3D; 1</td></tr><tr><td>JNZ&#x2F;JNE</td><td>0x75</td><td>0x0F 0x85</td><td>不相等则跳转</td><td>ZF &#x3D;&#x3D; 0</td></tr><tr><td>JS</td><td>0x78</td><td>0x0F 0x88</td><td>负数则跳转</td><td>SF &#x3D;&#x3D; 1</td></tr><tr><td>JNS</td><td>0x79</td><td>0x0F 0x89</td><td>正数则跳转</td><td>SF &#x3D;&#x3D; 0</td></tr><tr><td>JP&#x2F;JPE</td><td>0x7A</td><td>0x0F 0x8A</td><td>1出现次数为偶数则跳转</td><td>PF &#x3D;&#x3D; 1</td></tr><tr><td>JNP&#x2F;JPO</td><td>0x7B</td><td>0x0F 0x8B</td><td>1出现次数为奇数则跳转</td><td>PF &#x3D;&#x3D; 0</td></tr><tr><td>JC&#x2F;JB&#x2F;JNAE</td><td>0x72</td><td>0x0F 0x82</td><td>无符号数 (进位)低于则跳转</td><td>CF &#x3D;&#x3D; 1</td></tr><tr><td>JNC&#x2F;JNB&#x2F;JAE</td><td>0x73</td><td>0x0F 0x83</td><td>无符号数 (不进位)高于等于则跳转</td><td>CF &#x3D;&#x3D; 0</td></tr><tr><td>JO</td><td>0x70</td><td>0x0F 0x80</td><td>有符号数 溢出则跳转</td><td>OF &#x3D;&#x3D; 1</td></tr><tr><td>JNO</td><td>0x71</td><td>0x0F 0x81</td><td>有符号数 无溢出则跳转</td><td>OF &#x3D;&#x3D; 0</td></tr><tr><td>JBE&#x2F;JNA</td><td>0x76</td><td>0x0F 0x86</td><td>无符号数 低于等于则跳转</td><td>ZF &#x3D;&#x3D; 1 || CF &#x3D;&#x3D; 1</td></tr><tr><td>JNBE&#x2F;JA</td><td>0x77</td><td>0x0F 0x87</td><td>无符号数 高于则跳转</td><td>ZF &#x3D;&#x3D; 0 || CF &#x3D;&#x3D; 0</td></tr><tr><td>JL&#x2F;JNGE</td><td>0x7C</td><td>0x0F 0x8C</td><td>有符号数 小于则跳转</td><td>SF !&#x3D; OF</td></tr><tr><td>JNL&#x2F;JGE</td><td>0x7D</td><td>0x0F 0x8D</td><td>有符号数 大于等于则跳转</td><td>SF &#x3D;&#x3D; OF</td></tr><tr><td>JLE&#x2F;JNG</td><td>0x7E</td><td>0x0F 0x8E</td><td>有符号数 小于等于则跳转</td><td>ZF !&#x3D; OF || ZF &#x3D;&#x3D; 1</td></tr><tr><td>JNLE&#x2F;JG</td><td>0x7F</td><td>0x0F 0x8F</td><td>有符号数 大于则跳转</td><td>SF &#x3D;&#x3D; 0F &amp;&amp; ZF &#x3D;&#x3D; 0</td></tr></tbody></table><h3 id="3-2-CALL无条件跳转"><a href="#3-2-CALL无条件跳转" class="headerlink" title="3.2 CALL无条件跳转"></a>3.2 CALL无条件跳转</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E8</span> + <span class="hljs-number">4</span>字节有符号偏移：偏移CALL，最常见用法。<br></code></pre></td></tr></table></figure><p><strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 4字节偏移</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**FF 15 + 4字节：**</span>间接CALL，长用于调用导入表中函数。<br></code></pre></td></tr></table></figure><ul><li><p>x86：后面跟4字节内存地址。</p><p><strong>跳转目标地址 &#x3D; ptr:[ 4字节内存地址 ]</strong></p></li><li><p>x64：后面跟4字节偏移，再使用偏移计算公式得到4字节内存地址。</p></li></ul><p>​<strong>跳转目标地址 &#x3D; ptr:[ 当前指令地址 + 当前指令长度 + 4字节偏移 ]</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">9A + <span class="hljs-number">4</span>字节地址 + 目标<span class="hljs-built_in">cs</span>：绝对<span class="hljs-keyword">CALL</span>，仅x86有效，可以跳转到绝对地址同时改变<span class="hljs-built_in">cs</span>的值，<span class="hljs-built_in">far</span>常用于实现调用门。<br></code></pre></td></tr></table></figure><p>​<strong>跳转目标地址 &#x3D; 4字节地址、cs &#x3D; 目标cs</strong></p><h3 id="3-3-JMP无条件跳转"><a href="#3-3-JMP无条件跳转" class="headerlink" title="3.3 JMP无条件跳转"></a>3.3 JMP无条件跳转</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EB</span> + <span class="hljs-number">1</span>字节有符号偏移：偏移短跳转<br></code></pre></td></tr></table></figure><p>​<strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 1字节偏移</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E9</span> + <span class="hljs-number">4</span>字节有符号偏移：偏移近跳转<br></code></pre></td></tr></table></figure><p>​<strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 4字节偏移</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FF</span> <span class="hljs-number">25</span> + <span class="hljs-number">4</span>字节：间接跳转<br></code></pre></td></tr></table></figure><ul><li><p>x86：后面跟4字节内存地址。</p><p><strong>跳转目标地址 &#x3D; ptr:[ 4字节内存地址 ]</strong></p></li><li><p>x64：后面跟4字节偏移，再使用偏移计算公式得到4字节内存地址。</p></li></ul><p>​<strong>跳转目标地址 &#x3D; ptr:[ 当前指令地址 + 当前指令长度 + 4字节偏移 ]</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">EA + <span class="hljs-number">4</span>字节地址 + 目标<span class="hljs-built_in">cs</span>：绝对跳转，仅x86有效，可以跳转到绝对地址同时改变<span class="hljs-built_in">cs</span>的值，<span class="hljs-built_in">far</span>常用于实现调用门。<br></code></pre></td></tr></table></figure><p>​<strong>跳转目标地址 &#x3D; 4字节地址、cs &#x3D; 目标cs</strong></p><h3 id="3-4-x64下的Inline-HOOK"><a href="#3-4-x64下的Inline-HOOK" class="headerlink" title="3.4 x64下的Inline HOOK"></a>3.4 x64下的Inline HOOK</h3><p>enter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">方法1：12字节<br>mov rax, 0x123456789<br>jmp rax<br>方法2：12字节<br>mov rax, 0x123456789<br>push rax<br>ret<br>方法3：不破坏寄存器  13字节<br>push rax<br>mov rax, 0x123456789<br>jmp rax<br>```<br>pop rax<br></code></pre></td></tr></table></figure><p>ret</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">方法1：20字节<br>sub rsp, 0x8<br>mov dword ptr ss:[rsp], 0x1234<br>mov dword ptr ss:[rsp+0x4], 0x56789ABC<br>ret<br><br>方法2：14字节<br>push 0x12345678<br>mov dword ptr ss:[rsp+4], 0x9ABC<br>ret<br></code></pre></td></tr></table></figure><h2 id="4-基本运算"><a href="#4-基本运算" class="headerlink" title="4.基本运算"></a>4.基本运算</h2><h3 id="4-1-除法"><a href="#4-1-除法" class="headerlink" title="4.1 除法"></a>4.1 除法</h3><p>无符号：div + 除数</p><p>有符号：idiv + 除数，余数的符号与被除数相同。</p><table><thead><tr><th>被除数</th><th>除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td>ax</td><td>reg&#x2F;mem8</td><td>al</td><td>ah</td></tr><tr><td>dx:ax</td><td>reg&#x2F;mem16</td><td>ax</td><td>dx</td></tr><tr><td>edx:eax</td><td>reg&#x2F;mem32</td><td>eax</td><td>edx</td></tr><tr><td>rdx:rax</td><td>reg&#x2F;mem64</td><td>rax</td><td>rdx</td></tr></tbody></table><h3 id="4-2-乘法"><a href="#4-2-乘法" class="headerlink" title="4.2 乘法"></a>4.2 乘法</h3><p><strong>单操作数：</strong></p><p>​无符号：mul + 乘数</p><p>​有符号：imul + 乘数</p><table><thead><tr><th>被乘数</th><th>乘数</th><th>乘积</th></tr></thead><tbody><tr><td>al</td><td>reg&#x2F;mem8</td><td>ax</td></tr><tr><td>ax</td><td>reg&#x2F;mem16</td><td>dx:ax</td></tr><tr><td>eax</td><td>reg&#x2F;mem32</td><td>edx:eax</td></tr><tr><td>rax</td><td>reg&#x2F;mem64</td><td>rdx:rax</td></tr></tbody></table><p>对于无符号数，计算后如果dx&#x2F;edx&#x2F;rdx寄存器不为0，则CF位被置位。</p><p>对于有符号数，计算后如果dx&#x2F;edx&#x2F;rdx寄存器不为ax&#x2F;eax&#x2F;rax的符号扩展，则OF和CF位被置位。</p><p><strong>双操作数：</strong>不支持8位，必须是有符号数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul reg1, reg2/mem/imm<br>; 等价形式如下<br>reg1 = reg1 * reg2/mem/imm<br></code></pre></td></tr></table></figure><p><strong>三操作数：</strong>不支持8位，必须是有符号数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul reg1, reg2/mem, imm<br>; 等价形式如下<br>reg1 = reg2/mem * imm<br></code></pre></td></tr></table></figure><h3 id="4-3-移位"><a href="#4-3-移位" class="headerlink" title="4.3 移位"></a>4.3 移位</h3><p><strong>逻辑：</strong>shl、shr</p><p><strong>算数：</strong>sal、sar</p><p>逻辑左移与逻辑左移没区别，算数右移左边补符号位，逻辑右移坐标补0。右移除以2，左移乘以2。</p><h2 id="5-数据传送"><a href="#5-数据传送" class="headerlink" title="5.数据传送"></a>5.数据传送</h2><h3 id="5-1-扩展传送"><a href="#5-1-扩展传送" class="headerlink" title="5.1 扩展传送"></a>5.1 扩展传送</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movsx：符号位扩展<br>movzx：0扩展<br></code></pre></td></tr></table></figure><h3 id="5-2-隐式传送"><a href="#5-2-隐式传送" class="headerlink" title="5.2 隐式传送"></a>5.2 隐式传送</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movs_b/w/d/q<br>; 等价形式如下<br>if(DF == 0); cld<br>&#123;<br>[edi++] = [esi++]<br>&#125;<br>else; std<br>&#123;<br>[edi--] = [esi--]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-字符串获取"><a href="#5-3-字符串获取" class="headerlink" title="5.3 字符串获取"></a>5.3 字符串获取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lods_b/w/d/q<br>; 等价形式如下<br>if(DF == 0); cld<br>&#123;<br>eax = [esi++]<br>&#125;<br>else; std<br>&#123;<br>eax = [esi--]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-字符串加载"><a href="#5-4-字符串加载" class="headerlink" title="5.4 字符串加载"></a>5.4 字符串加载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">stos_b/w/d/q<br>; 等价形式如下<br>if(DF == 0); cld<br>&#123;<br>[edi++] = eax <br>&#125;<br>else; std<br>&#123;<br>[edi--] = eax <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> x86/x64 asm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
