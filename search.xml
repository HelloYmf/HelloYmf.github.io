<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Class-reverse</title>
      <link href="/2022/09/14/class-reverse/"/>
      <url>/2022/09/14/class-reverse/</url>
      
        <content type="html"><![CDATA[<h2 id="1-对象内存布局"><a href="#1-对象内存布局" class="headerlink" title="1.对象内存布局"></a>1.对象内存布局</h2><h3 id="1-1-基本类"><a href="#1-1-基本类" class="headerlink" title="1.1 基本类"></a>1.1 基本类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 基本类</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">short</span> z)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br><span class="hljs-keyword">this</span>-&gt;z = z;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; x &lt;&lt; std::endl;<br>std::cout &lt;&lt; y &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">char</span> y;<br><span class="hljs-type">short</span> z;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-function">A1 <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>)</span></span>;<br>a1.<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于基本类，从对象创建的地方找到构造函数，根据结构偏移使用情况来确定边界和成员类型，并在之后分析过程中不断修改完善。</p><p><strong>结构体定义模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914103536513.png" alt="基本类结构模板"></p><h3 id="1-2-组合类"><a href="#1-2-组合类" class="headerlink" title="1.2 组合类"></a>1.2 组合类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 组合关系以及数组成员</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A2</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetX</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetY</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> y;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">float</span> x;<br><span class="hljs-type">float</span> y;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">short</span> z)<br>:<span class="hljs-built_in">a2</span>(<span class="hljs-number">3.2</span>, <span class="hljs-number">4.3</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;y[i] = i+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;z = z;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; x &lt;&lt; std::endl;<br>std::cout &lt;&lt; y &lt;&lt; std::endl;<br><br>std::cout &lt;&lt; y[<span class="hljs-number">5</span>] &lt;&lt; std::endl;<br><br>std::cout &lt;&lt; a2.<span class="hljs-built_in">GetX</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; a2.<span class="hljs-built_in">GetY</span>() &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">char</span> y[<span class="hljs-number">20</span>];<br><span class="hljs-type">short</span> z;<br>A2 a2;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-function">A1 <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>)</span></span>;<br>a1.<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>组合类在分析的时候可以看见很明显的特征，就是在class1的构造函数中会将his + x的地址传入class2的构造函数中进行初始化，这个偏移x的位置就是class2的起始位置。</p><p><img src="/2022/09/14/class-reverse/image-20220914104738064.png" alt="组合类特征"></p><p><strong>结构体定义模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914104204262.png" alt="组合类结构模板"></p><h3 id="1-3-单继承类"><a href="#1-3-单继承类" class="headerlink" title="1.3 单继承类"></a>1.3 单继承类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 成员重叠继承关系，即子类覆盖父类成员</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A2</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> len)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>(len);<br><span class="hljs-built_in">strcpy</span>(b, <span class="hljs-string">&quot;Base&quot;</span>);<br>&#125;<br>~<span class="hljs-built_in">A2</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;b)<br>&#123;<br><span class="hljs-built_in">free</span>(<span class="hljs-keyword">this</span>-&gt;b);<br><span class="hljs-keyword">this</span>-&gt;b = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">char</span> *b;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>: <span class="hljs-keyword">public</span> A2<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">short</span> c)<br>:<span class="hljs-built_in">A2</span>(<span class="hljs-number">8</span>, <span class="hljs-number">12</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br><span class="hljs-keyword">this</span>-&gt;c = c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">encrypt</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> key + b[<span class="hljs-number">3</span>] + b[<span class="hljs-number">5</span>] * arr[<span class="hljs-number">1</span>] / a + c;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">short</span> c;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-function">A1 <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span></span>;<br>std::cout &lt;&lt; a.<span class="hljs-built_in">encrypt</span>(<span class="hljs-number">10</span>) &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于继承关系的类识别，可以看构造函数中是否将原始this指针直接传递给父类构造函数的操作。实际上在不含有虚函数的继承关系中，可以把子类和父类合并来看待。<strong>普通继承关系实际上就是把父类的成员原封不动的拷贝过来，作为子类对象结构开头的一部分。</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914113639610.png" alt="继承关系特征"></p><p><strong>结构体定义标准模板</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914112142545.png" alt="继承类结构模板"></p><p><strong>将父类子类合并看待的结构定义</strong></p><p><img src="/2022/09/14/class-reverse/image-20220914113741832.png" alt="继承类合并结构模板"></p><h3 id="1-4-多继承类"><a href="#1-4-多继承类" class="headerlink" title="1.4 多继承类"></a>1.4 多继承类</h3><h3 id="1-4-虚表类"><a href="#1-4-虚表类" class="headerlink" title="1.4 虚表类"></a>1.4 虚表类</h3><h2 id="2-对象创建方式"><a href="#2-对象创建方式" class="headerlink" title="2.对象创建方式"></a>2.对象创建方式</h2><h3 id="2-1-局部对象"><a href="#2-1-局部对象" class="headerlink" title="2.1 局部对象"></a>2.1 局部对象</h3><h3 id="2-2-堆对象"><a href="#2-2-堆对象" class="headerlink" title="2.2 堆对象"></a>2.2 堆对象</h3><h3 id="2-3-全局对象"><a href="#2-3-全局对象" class="headerlink" title="2.3 全局对象"></a>2.3 全局对象</h3><h3 id="2-4-静态对象"><a href="#2-4-静态对象" class="headerlink" title="2.4 静态对象"></a>2.4 静态对象</h3>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ida Basic</title>
      <link href="/2022/09/13/ida-basic/"/>
      <url>/2022/09/13/ida-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="1-常用快捷键"><a href="#1-常用快捷键" class="headerlink" title="1.常用快捷键"></a>1.常用快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Shift + F12</td><td>打开字符串窗口</td></tr><tr><td>Y</td><td>改变函数原型或变量类型</td></tr><tr><td>D</td><td>宽度转换以及结构体中新增成员</td></tr><tr><td>R</td><td>字符转换</td></tr><tr><td>H</td><td>进制转换</td></tr><tr><td>&#x2F;</td><td>伪代码中添加注释</td></tr><tr><td>X</td><td>查看交叉引用</td></tr><tr><td>TAB</td><td>汇编指令和伪代码之间切换</td></tr><tr><td>Shift + E</td><td>得到数组</td></tr><tr><td>Alt + T</td><td>搜索字符串</td></tr><tr><td>Alt + I</td><td>搜索立即数</td></tr><tr><td>Alt + B</td><td>搜索二进制</td></tr></tbody></table><h2 id="2-伪代码修复"><a href="#2-伪代码修复" class="headerlink" title="2.伪代码修复"></a>2.伪代码修复</h2><h3 id="2-1-逆向命名规则"><a href="#2-1-逆向命名规则" class="headerlink" title="2.1 逆向命名规则"></a>2.1 逆向命名规则</h3><h4 id="2-1-1-类型命名"><a href="#2-1-1-类型命名" class="headerlink" title="2.1.1 类型命名"></a><strong>2.1.1 类型命名</strong></h4><table><thead><tr><th>类型</th><th>前缀</th></tr></thead><tbody><tr><td>数组</td><td>a</td></tr><tr><td>布尔</td><td>b</td></tr><tr><td>字符byte</td><td>c</td></tr><tr><td>短整型word</td><td>w</td></tr><tr><td>整型dowrd</td><td>dw</td></tr><tr><td>整形qword</td><td>qw</td></tr><tr><td>指针</td><td>p</td></tr><tr><td>类成员</td><td>m_</td></tr><tr><td>字符串</td><td>sz</td></tr></tbody></table><h4 id="2-1-2-符号命名"><a href="#2-1-2-符号命名" class="headerlink" title="2.1.2 符号命名"></a><strong>2.1.2 符号命名</strong></h4><table><thead><tr><th>符号类型</th><th>规则</th><th>示例</th></tr></thead><tbody><tr><td>栈变量</td><td>类型前缀 + 名字</td><td>szWelcome</td></tr><tr><td>全局变量</td><td>g_类型前缀 + 名字</td><td>g_dwTime</td></tr><tr><td>普通函数</td><td>大功能 + 具体功能</td><td>memAlloc</td></tr><tr><td>成员函数</td><td>类名字::函数名</td><td>Student::getNum</td></tr></tbody></table><h3 id="2-2-不规则代码"><a href="#2-2-不规则代码" class="headerlink" title="2.2 不规则代码"></a>2.2 不规则代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">def <span class="hljs-title function_">LOBYTE</span><span class="hljs-params">(x)</span>:     <span class="hljs-keyword">return</span> x &amp; 0xff<br>def <span class="hljs-title function_">HIBYTE</span><span class="hljs-params">(x)</span>:     <span class="hljs-title function_">return</span> <span class="hljs-params">(x &gt;&gt; <span class="hljs-number">8</span>)</span> &amp; 0xff<br>def <span class="hljs-title function_">LOWORD</span><span class="hljs-params">(x)</span>:     <span class="hljs-keyword">return</span> x &amp; 0xffff<br>def <span class="hljs-title function_">HIWORD</span><span class="hljs-params">(x)</span>:     <span class="hljs-title function_">return</span> <span class="hljs-params">(x &gt;&gt; <span class="hljs-number">16</span>)</span> &amp; 0xffff<br>def <span class="hljs-title function_">LODWORD</span><span class="hljs-params">(x)</span>:    <span class="hljs-keyword">return</span> x &amp; 0xffffffff<br>def <span class="hljs-title function_">HIDWORD</span><span class="hljs-params">(x)</span>:    <span class="hljs-title function_">return</span> <span class="hljs-params">(x &gt;&gt; <span class="hljs-number">32</span>)</span> &amp; 0xffffffff<br></code></pre></td></tr></table></figure><h3 id="2-3-修复函数原型"><a href="#2-3-修复函数原型" class="headerlink" title="2.3 修复函数原型"></a>2.3 修复函数原型</h3><h4 id="2-3-1-返回值类型"><a href="#2-3-1-返回值类型" class="headerlink" title="2.3.1 返回值类型"></a>2.3.1 返回值类型</h4><p>​当分析出某个函数的返回值类型始终（交叉引用）不会被使用后，可以将函数原型的返回值类型改成void，可以优化掉多余代码。</p><h4 id="2-3-2-参数个数和类型"><a href="#2-3-2-参数个数和类型" class="headerlink" title="2.3.2 参数个数和类型"></a>2.3.2 参数个数和类型</h4><p>​在x64下，有些函数没有参数，但由于调用约定，F5后的伪代码中可能出现参数，将多余的参数删除，可以优化代码。而且有些参数是使用寄存器传递，如浮点寄存器，这时伪代码中可能无法正确识别，需要结合汇编分析，并手动添加参数，可以增加可读性。</p><h3 id="2-4-修复变量类型"><a href="#2-4-修复变量类型" class="headerlink" title="2.4 修复变量类型"></a>2.4 修复变量类型</h3><h4 id="2-4-1-结构体定义"><a href="#2-4-1-结构体定义" class="headerlink" title="2.4.1 结构体定义"></a>2.4.1 结构体定义</h4><p>​恢复结构体类型可以大大代码可读性，可以根据new的大小和分析成员使用情况来确定结构体边界和成员类型。下面展示类的结构定义模板：</p><p><img src="/2022/09/13/ida-basic/image-20220913182821578.png" alt="类结构模板"></p><h4 id="2-4-2-数组定义"><a href="#2-4-2-数组定义" class="headerlink" title="2.4.2 数组定义"></a>2.4.2 数组定义</h4><p>​对于连续的内存空间的操作，可以酌情还原为数组，增加可读性。</p><h2 id="3-符号还原"><a href="#3-符号还原" class="headerlink" title="3.符号还原"></a>3.符号还原</h2><h3 id="3-1-基于签名文件的符号还原"><a href="#3-1-基于签名文件的符号还原" class="headerlink" title="3.1 基于签名文件的符号还原"></a>3.1 基于签名文件的符号还原</h3><h3 id="3-2-基于Bindff的符号还原"><a href="#3-2-基于Bindff的符号还原" class="headerlink" title="3.2 基于Bindff的符号还原"></a>3.2 基于Bindff的符号还原</h3>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> ida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Assembly Basic</title>
      <link href="/2022/09/12/asm-basic/"/>
      <url>/2022/09/12/asm-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="1-EFLAGS"><a href="#1-EFLAGS" class="headerlink" title="1.EFLAGS"></a>1.EFLAGS</h2><p><img src="/2022/09/12/asm-basic/eflags.png" alt="eflags"></p><h2 id="2-测试与比较"><a href="#2-测试与比较" class="headerlink" title="2.测试与比较"></a>2.测试与比较</h2><h3 id="2-1-test"><a href="#2-1-test" class="headerlink" title="2.1 test"></a>2.1 test</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">test rax, rbx<br>; 等价形式如下<br>push rax<br>and rax, rbx<br>pop rax<br></code></pre></td></tr></table></figure><h3 id="2-2-cmp"><a href="#2-2-cmp" class="headerlink" title="2.2 cmp"></a>2.2 cmp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp rax, rbx<br>; 等价形式如下<br>push rax<br>sub rax, rbx<br>pop rax<br></code></pre></td></tr></table></figure><h2 id="3-跳转"><a href="#3-跳转" class="headerlink" title="3.跳转"></a>3.跳转</h2><h3 id="3-1-JCC条件跳转"><a href="#3-1-JCC条件跳转" class="headerlink" title="3.1 JCC条件跳转"></a>3.1 JCC条件跳转</h3><ul><li><strong>短跳：</strong>2字节，1字节硬编码 + 1字节有符号偏移</li><li><strong>长跳：</strong>6字节，2字节硬编码 + 4字节有符号地址</li></ul><table><thead><tr><th>指令</th><th>短跳</th><th>长跳</th><th>含义</th><th>EFLAGS</th></tr></thead><tbody><tr><td>JZ&#x2F;JE</td><td>0x74</td><td>0x0F 0x84</td><td>相等则跳转</td><td>ZF &#x3D;&#x3D; 1</td></tr><tr><td>JNZ&#x2F;JNE</td><td>0x75</td><td>0x0F 0x85</td><td>不相等则跳转</td><td>ZF &#x3D;&#x3D; 0</td></tr><tr><td>JS</td><td>0x78</td><td>0x0F 0x88</td><td>负数则跳转</td><td>SF &#x3D;&#x3D; 1</td></tr><tr><td>JNS</td><td>0x79</td><td>0x0F 0x89</td><td>正数则跳转</td><td>SF &#x3D;&#x3D; 0</td></tr><tr><td>JP&#x2F;JPE</td><td>0x7A</td><td>0x0F 0x8A</td><td>1出现次数为偶数则跳转</td><td>PF &#x3D;&#x3D; 1</td></tr><tr><td>JNP&#x2F;JPO</td><td>0x7B</td><td>0x0F 0x8B</td><td>1出现次数为奇数则跳转</td><td>PF &#x3D;&#x3D; 0</td></tr><tr><td>JC&#x2F;JB&#x2F;JNAE</td><td>0x72</td><td>0x0F 0x82</td><td>无符号数 (进位)低于则跳转</td><td>CF &#x3D;&#x3D; 1</td></tr><tr><td>JNC&#x2F;JNB&#x2F;JAE</td><td>0x73</td><td>0x0F 0x83</td><td>无符号数 (不进位)高于等于则跳转</td><td>CF &#x3D;&#x3D; 0</td></tr><tr><td>JO</td><td>0x70</td><td>0x0F 0x80</td><td>有符号数 溢出则跳转</td><td>OF &#x3D;&#x3D; 1</td></tr><tr><td>JNO</td><td>0x71</td><td>0x0F 0x81</td><td>有符号数 无溢出则跳转</td><td>OF &#x3D;&#x3D; 0</td></tr><tr><td>JBE&#x2F;JNA</td><td>0x76</td><td>0x0F 0x86</td><td>无符号数 低于等于则跳转</td><td>ZF &#x3D;&#x3D; 1 || CF &#x3D;&#x3D; 1</td></tr><tr><td>JNBE&#x2F;JA</td><td>0x77</td><td>0x0F 0x87</td><td>无符号数 高于则跳转</td><td>ZF &#x3D;&#x3D; 0 || CF &#x3D;&#x3D; 0</td></tr><tr><td>JL&#x2F;JNGE</td><td>0x7C</td><td>0x0F 0x8C</td><td>有符号数 小于则跳转</td><td>SF !&#x3D; OF</td></tr><tr><td>JNL&#x2F;JGE</td><td>0x7D</td><td>0x0F 0x8D</td><td>有符号数 大于等于则跳转</td><td>SF &#x3D;&#x3D; OF</td></tr><tr><td>JLE&#x2F;JNG</td><td>0x7E</td><td>0x0F 0x8E</td><td>有符号数 小于等于则跳转</td><td>ZF !&#x3D; OF || ZF &#x3D;&#x3D; 1</td></tr><tr><td>JNLE&#x2F;JG</td><td>0x7F</td><td>0x0F 0x8F</td><td>有符号数 大于则跳转</td><td>SF &#x3D;&#x3D; 0F &amp;&amp; ZF &#x3D;&#x3D; 0</td></tr></tbody></table><h3 id="3-2-CALL无条件跳转"><a href="#3-2-CALL无条件跳转" class="headerlink" title="3.2 CALL无条件跳转"></a>3.2 CALL无条件跳转</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E8</span> + <span class="hljs-number">4</span>字节有符号偏移：偏移CALL，最常见用法。<br></code></pre></td></tr></table></figure><p><strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 4字节偏移</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**FF 15 + 4字节：**</span>间接CALL，长用于调用导入表中函数。<br></code></pre></td></tr></table></figure><ul><li><p>x86：后面跟4字节内存地址。</p><p><strong>跳转目标地址 &#x3D; ptr:[ 4字节内存地址 ]</strong></p></li><li><p>x64：后面跟4字节偏移，再使用偏移计算公式得到4字节内存地址。</p></li></ul><p>​<strong>跳转目标地址 &#x3D; ptr:[ 当前指令地址 + 当前指令长度 + 4字节偏移 ]</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">9A + <span class="hljs-number">4</span>字节地址 + 目标<span class="hljs-built_in">cs</span>：绝对<span class="hljs-keyword">CALL</span>，仅x86有效，可以跳转到绝对地址同时改变<span class="hljs-built_in">cs</span>的值，<span class="hljs-built_in">far</span>常用于实现调用门。<br></code></pre></td></tr></table></figure><p>​<strong>跳转目标地址 &#x3D; 4字节地址、cs &#x3D; 目标cs</strong></p><h3 id="3-3-JMP无条件跳转"><a href="#3-3-JMP无条件跳转" class="headerlink" title="3.3 JMP无条件跳转"></a>3.3 JMP无条件跳转</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EB</span> + <span class="hljs-number">1</span>字节有符号偏移：偏移短跳转<br></code></pre></td></tr></table></figure><p>​<strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 1字节偏移</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E9</span> + <span class="hljs-number">4</span>字节有符号偏移：偏移近跳转<br></code></pre></td></tr></table></figure><p>​<strong>跳转目标地址 &#x3D; 当前指令地址 + 当前指令长度 + 4字节偏移</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FF</span> <span class="hljs-number">25</span> + <span class="hljs-number">4</span>字节：间接跳转<br></code></pre></td></tr></table></figure><ul><li><p>x86：后面跟4字节内存地址。</p><p><strong>跳转目标地址 &#x3D; ptr:[ 4字节内存地址 ]</strong></p></li><li><p>x64：后面跟4字节偏移，再使用偏移计算公式得到4字节内存地址。</p></li></ul><p>​<strong>跳转目标地址 &#x3D; ptr:[ 当前指令地址 + 当前指令长度 + 4字节偏移 ]</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">EA + <span class="hljs-number">4</span>字节地址 + 目标<span class="hljs-built_in">cs</span>：绝对跳转，仅x86有效，可以跳转到绝对地址同时改变<span class="hljs-built_in">cs</span>的值，<span class="hljs-built_in">far</span>常用于实现调用门。<br></code></pre></td></tr></table></figure><p>​<strong>跳转目标地址 &#x3D; 4字节地址、cs &#x3D; 目标cs</strong></p><h3 id="3-4-x64下的Inline-HOOK"><a href="#3-4-x64下的Inline-HOOK" class="headerlink" title="3.4 x64下的Inline HOOK"></a>3.4 x64下的Inline HOOK</h3><p>enter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">方法1：12字节<br>mov rax, 0x123456789<br>jmp rax<br>方法2：12字节<br>mov rax, 0x123456789<br>push rax<br>ret<br>方法3：不破坏寄存器  13字节<br>push rax<br>mov rax, 0x123456789<br>jmp rax<br>```<br>pop rax<br></code></pre></td></tr></table></figure><p>ret</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">方法1：20字节<br>sub rsp, 0x8<br>mov dword ptr ss:[rsp], 0x1234<br>mov dword ptr ss:[rsp+0x4], 0x56789ABC<br>ret<br><br>方法2：14字节<br>push 0x12345678<br>mov dword ptr ss:[rsp+4], 0x9ABC<br>ret<br></code></pre></td></tr></table></figure><h2 id="4-基本运算"><a href="#4-基本运算" class="headerlink" title="4.基本运算"></a>4.基本运算</h2><h3 id="4-1-除法"><a href="#4-1-除法" class="headerlink" title="4.1 除法"></a>4.1 除法</h3><p>无符号：div + 除数</p><p>有符号：idiv + 除数，余数的符号与被除数相同。</p><table><thead><tr><th>被除数</th><th>除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td>ax</td><td>reg&#x2F;mem8</td><td>al</td><td>ah</td></tr><tr><td>dx:ax</td><td>reg&#x2F;mem16</td><td>ax</td><td>dx</td></tr><tr><td>edx:eax</td><td>reg&#x2F;mem32</td><td>eax</td><td>edx</td></tr><tr><td>rdx:rax</td><td>reg&#x2F;mem64</td><td>rax</td><td>rdx</td></tr></tbody></table><h3 id="4-2-乘法"><a href="#4-2-乘法" class="headerlink" title="4.2 乘法"></a>4.2 乘法</h3><p><strong>单操作数：</strong></p><p>​无符号：mul + 乘数</p><p>​有符号：imul + 乘数</p><table><thead><tr><th>被乘数</th><th>乘数</th><th>乘积</th></tr></thead><tbody><tr><td>al</td><td>reg&#x2F;mem8</td><td>ax</td></tr><tr><td>ax</td><td>reg&#x2F;mem16</td><td>dx:ax</td></tr><tr><td>eax</td><td>reg&#x2F;mem32</td><td>edx:eax</td></tr><tr><td>rax</td><td>reg&#x2F;mem64</td><td>rdx:rax</td></tr></tbody></table><p>对于无符号数，计算后如果dx&#x2F;edx&#x2F;rdx寄存器不为0，则CF位被置位。</p><p>对于有符号数，计算后如果dx&#x2F;edx&#x2F;rdx寄存器不为ax&#x2F;eax&#x2F;rax的符号扩展，则OF和CF位被置位。</p><p><strong>双操作数：</strong>不支持8位，必须是有符号数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul reg1, reg2/mem/imm<br>; 等价形式如下<br>reg1 = reg1 * reg2/mem/imm<br></code></pre></td></tr></table></figure><p><strong>三操作数：</strong>不支持8位，必须是有符号数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul reg1, reg2/mem, imm<br>; 等价形式如下<br>reg1 = reg2/mem * imm<br></code></pre></td></tr></table></figure><h3 id="4-3-移位"><a href="#4-3-移位" class="headerlink" title="4.3 移位"></a>4.3 移位</h3><p><strong>逻辑：</strong>shl、shr</p><p><strong>算数：</strong>sal、sar</p><p>逻辑左移与逻辑左移没区别，算数右移左边补符号位，逻辑右移坐标补0。右移除以2，左移乘以2。</p><h2 id="5-数据传送"><a href="#5-数据传送" class="headerlink" title="5.数据传送"></a>5.数据传送</h2><h3 id="5-1-扩展传送"><a href="#5-1-扩展传送" class="headerlink" title="5.1 扩展传送"></a>5.1 扩展传送</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movsx：符号位扩展<br>movzx：0扩展<br></code></pre></td></tr></table></figure><h3 id="5-2-隐式传送"><a href="#5-2-隐式传送" class="headerlink" title="5.2 隐式传送"></a>5.2 隐式传送</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movs_b/w/d/q<br>; 等价形式如下<br>if(DF == 0); cld<br>&#123;<br>[edi++] = [esi++]<br>&#125;<br>else; std<br>&#123;<br>[edi--] = [esi--]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-字符串获取"><a href="#5-3-字符串获取" class="headerlink" title="5.3 字符串获取"></a>5.3 字符串获取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lods_b/w/d/q<br>; 等价形式如下<br>if(DF == 0); cld<br>&#123;<br>eax = [esi++]<br>&#125;<br>else; std<br>&#123;<br>eax = [esi--]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-字符串加载"><a href="#5-4-字符串加载" class="headerlink" title="5.4 字符串加载"></a>5.4 字符串加载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">stos_b/w/d/q<br>; 等价形式如下<br>if(DF == 0); cld<br>&#123;<br>[edi++] = eax <br>&#125;<br>else; std<br>&#123;<br>[edi--] = eax <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> x86/x64 asm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
